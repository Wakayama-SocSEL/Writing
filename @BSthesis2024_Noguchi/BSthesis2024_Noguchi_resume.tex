%
% 卒論レジュメフォーマット Ver.2.0 pLaTeX版
%
\documentclass[twocolumn]{jarticle} % 2段組のスタイルを用いている


\usepackage{url}	% \url{}コマンド用．URLを表示する際に便利
\usepackage{xcolor} 	% 色を扱うためのパッケージ
\usepackage{listings}
\usepackage[dvipdfmx]{graphicx}
\usepackage{amsmath}
\usepackage{multirow}
\usepackage{array}
\usepackage{tabularx}
\usepackage{jvlisting}
\usepackage{wuse_resume}
\usepackage{url}	% \url{}コマンド用．URLを表示する際に便利
%\usepackage[dvipdfmx]{graphicx}  % ←graphicx.styを用いてEPSを取り込む場合有効にする
			% 他のパッケージ・スタイルを使う場合には適宜追加
\newcommand{\RQone}{コーディングパターンとして抽出すべき基準はどこなのか}
\newcommand{\RQtwo}{抽出したコーディングパターンはプロジェクトでどの程度使用されているのか}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% タイトル，学生番号，氏名などを設定する
%%

\タイトル{プロジェクト特有のコーディングパターン収集方法の定量的評価}
\研究室{ソーシャルソフトウェア工学}
\学生番号{60266227}
\氏名{野口 朋弥}

\概要{%
ソフトウェア開発において，開発効率の向上を目指して深層学習や正規表現などを利用したソースコードの自動生成の手法が多数提案されている．その多くは，多数のプロジェクトを学習することにより特定のプログラミング言語における汎用的なソースコードが生成される．しかし，個別プロジェクトが定める規約やドメインによって必ずしも汎用的なソースコードの実装が適切とは限らない．従来研究では個別プロジェクトに特化したコーディングパターンを抽出する手法が提案されているが，実装パターンとして記録する基準は十分に議論されていないため，基準によって膨大なパターン数が生成されることもある．本研究では，個別プロジェクトに特化したコーディングパターンの抽出し，有用なパターンを選定する基準を定量的に評価することで，課題の解決を目指す．
}

\キーワード{Python}
\キーワード{コーディングパターン}
\キーワード{オープンソースソフトウェア}
\キーワード{プログラム解析}
\キーワード{静的解析}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%% 以下の3行は変更しない

\begin{document}
\maketitle
\thispagestyle{empty} % タイトルを出力したページにもページ番号を付けない

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 本文 - ここから
%%

\section{はじめに}
ソフトウェア開発において，開発効率の向上を目指して深層学習や正規表現などを利用したソースコードの自動生成の手法が多数提案されている\cite{smith}．その多くは，GitHub\footnote{GitHub:~\url{https://github.com}}やGerritGerrit\footnote{Gerrit:~\url{https://www.gerritcodereview.com}}などのオープンソースプラットフォームで公開されている大規模なプロジェクトの開発履歴を学習データとして利用している．これらの手法は，多数のプロジェクトから関数・クラスの実装方法や，APIの使用方法，エラーハンドリングなどの特徴を学習することで，特定のプログラミング言語における汎用的なソースコードの生成を実現している．

しかし，個別プロジェクトが定める規約やドメインによって，必ずしも汎用的なソースコードの実装が適切とは限らない．例えば，金融システムや医療システムといった重要インフラでは，セキュリティ要件や法的規制が厳格であり，独自のアーキテクチャ設計が不可欠となっている．また，複数人で開発を行う際のコーディング規約もプロジェクトごとに異なることがあるため，汎用的な生成手法では，ドメイン固有の要件を満たすソースコードを適切に生成できないことが多い．

Uedaらは，単一のプロジェクトの開発履歴から頻出する修正方法を抽象化することで，コーディングパターンを特定した\cite{devreplay}．しかし，特定したコーディングパターンがプロジェクトの修正方法を反映しているかを十分に検証していない．その結果，従来手法では不要なパターンが大量に生成される，または必要なパターンを取りこぼしているという課題がある．本研究ではこれらの課題を解決するために，個別プロジェクトに特化したコーディングパターンを抽出する手法を提案する．それをもとに，取得した修正方法から，有用なコーディングパターンを選別する評価基準の確立を目指す．
具体的には，2つのResearch Questions（RQ）に回答する．
\begin{itemize}
    \item RQ1: \RQone
    \item RQ2: \RQtwo
\end{itemize}
RQ1では，プロジェクト内に存在する実装方法をコーディングパターンとして抽出するための条件を明確にする．これを実現するために，従来手法と提案手法を比較し，その違いを分析する．
RQ2では，RQ1にて抽出したコーディングパターンが生存している期間を分析することで，プロジェクトにとって有用なコーディングパターンが抽出できたのかを評価・議論する．

\section{コーディングパターン候補生成}
本研究では，従来手法を踏襲し修正方法を表したコーディングパターンを抽出するために，コーディングパターンになり得る候補を生成する．候補の中から，プロジェクトにとって有用なコーディングパターンを抽出する手法は，RQ1で議論する．
コーディングパターン候補は以下の3つのステップで生成する．
\begin{description}
    \item[変更履歴の取得:] プロジェクトの変更履歴を取得する．
    \item[前処理:] 変更履歴から，修正前後のソースコードを抽出し，比較可能な形に整える． 
    \item[コーディングパターン候補の生成:]修正前後のソースコードを比較することで，修正方法から想定されるコーディングパターン候補を生成する． 
\end{description}

\begin{table}[t]
    \centering
        \caption{条件ごとにパターンを抽出した結果}
        \label{table:created_pattern}
        \scalebox{0.63}{
        \begin{tabular}{r|rrr|r|p{2cm}|p{4.5cm}}
            \hline \hline
                 \multirow{2}{*}{id} & \multicolumn{3}{c|}{順位} & \multirow{2}{*}{\begin{tabular}{c} 出現\\回数 \end{tabular}} & \multirow{2}{*}{説明} & \multirow{2}{*}{パターン}\\ \cline{2-4}
                
                & 条件なし & 従来 & 提案 &  &\\ 
            \hline
                1 & 4,068     & 1   & 1  & 2,504  & 画像メタデータをオブジェクトとして渡すように変更 & 
                \colorbox{lightgray!50}{\texttt{VAR\_1}} \colorbox{lightgray!50}{\texttt{=}} \colorbox{lightgray!50}{\texttt{- \{}} \colorbox{lightgray!50}{\texttt{+ objects}} 
        \newline
        \colorbox{lightgray!50}{\texttt{+ .}} \colorbox{lightgray!50}{\texttt{+ ImageMeta}} \colorbox{lightgray!50}{\texttt{+ ,}} 
        \newline
        \colorbox{lightgray!50}{\texttt{+ from\_dict}} \colorbox{lightgray!50}{\texttt{+ (}} \colorbox{lightgray!50}{\texttt{+ self}} 
        \newline
        \colorbox{lightgray!50}{\texttt{+ .}} \colorbox{lightgray!50}{\texttt{+ test\_VAR\_1}} \colorbox{lightgray!50}{\texttt{+ )}} 
        \\
        \hline
                2 & 26,738    & -   & 2  & 1,067  & デコレータの名前・引数の変更 &
                \colorbox{lightgray!50}{\texttt{@}} \colorbox{lightgray!50}{\texttt{- exception}} \colorbox{lightgray!50}{\texttt{- .}} 
        \newline
        \colorbox{lightgray!50}{\texttt{wrap\_exception}}
        \colorbox{lightgray!50}{\texttt{= (}} 
        \newline
        \colorbox{lightgray!50}{\texttt{- notifier}} 
        \colorbox{lightgray!50}{\texttt{- =}} 
        \newline
        \colorbox{lightgray!50}{\texttt{- notifier}} \colorbox{lightgray!50}{\texttt{- ,}}
        \newline
        \colorbox{lightgray!50}{\texttt{- publisher\_id}} \colorbox{lightgray!50}{\texttt{- =}} 
        \newline
        \colorbox{lightgray!50}{\texttt{- publisher\_id}} \colorbox{lightgray!50}{\texttt{- (}} \colorbox{lightgray!50}{\texttt{- )}} \colorbox{lightgray!50}{\texttt{= )}}
        \\ \hline
                3 & 23,974    & 2   & -  & 1,311  & ログメッセージのローカライズ& 
                \colorbox{lightgray!50}{\texttt{VAR\_1}} \colorbox{lightgray!50}{\texttt{.}} \colorbox{lightgray!50}{\texttt{VAR\_2}} \colorbox{lightgray!50}{\texttt{(}}
        \newline
        \colorbox{lightgray!50}{\texttt{- VAR\_3}} \colorbox{lightgray!50}{\texttt{+ VAR\_4}}
        \colorbox{lightgray!50}{\texttt{(}}
                \\
             \hline
        \end{tabular}
        }
\end{table}

\section{ケーススタディ}
研究では，ケーススタディとして大規模なオープンソースプロジェクトであるOpenStackのコンポーネントの中で最大規模の Novaを対象とした．
\subsection{RQ1: \RQone}
本研究では，プロジェクト内に存在する実装方法をコーディングパターンとして抽出するための条件を明確にする．これを実現するために，従来手法と提案手法を比較し，その違いを分析する．
従来手法で用いられていた条件と，提案手法で用いる条件は以下である．
\textbf{従来手法}
\begin{itemize}
    \item 変更を示さないパターンを削除
    \item 重複したパターンを削除
\end{itemize}
\textbf{提案手法}
\begin{itemize}
    \item 変更を示すトークンが1つも含まれないパターンを削除
    \item 重複したパターンを削除
    \item 不正な構造（括弧が閉じられていない，記号のみ）のパターンを削除
\end{itemize}
\subsubsection{結果・考察}
表\ref{table:created_pattern}は，条件を適用しない場合，従来手法，および提案手法それぞれで抽出されたコーディンパターンの順位と，出現回数，抽出したパターンを示す．なお，表\ref{table:created_pattern}は，`\texttt{-}'は，その手法では，パターンとして抽出できなかったことを示す．

RQ1の検証では，従来手法のパターン除外条件を再設計することにより，プロジェクト固有のコーディングパターンをより広範に収集することに成功した．具体的には，従来手法では除外されていた引数の追加・削除といった変更パターンの抽出を可能とし，同時に冗長なパターンの除去も実現した.
\subsection{RQ2: \RQtwo}
従来手法\cite{devreplay}では，抽出したコーディングパターンが時間経過に伴い使用頻度が変動することが明らかになっている．本手法では，コーディングパターンの持続性分析を通じて，効果的なパターン収集方法の確立を試みる．
\subsubsection{結果・考察}
RQ2の検証においては，コーディングパターンの持続性分析を通じて，効果的なパターン収集方法の確立を試みた．分析の結果，パターンは以下の3種類に分類された．
\begin{itemize}
    \item 分析期間を通じて変更前/変更後パターンが継続的に共存する持続共存型パターン（id\_1）
    \item ある時点を境に，変更前パターンが完全に変更後パターンに置き換えられた移行完了型パターン（id\_2）
    \item ある時点で，変更前/変更後パターンが出現しなくなった消失型パターン（id\_3）
\end{itemize}

特に，移行完了型パターンは，プロジェクト独自に定義された関数への変更を含むケースが多く，多様なプログラミング言語を学習した深層学習モデルでは対応が困難な性質を持つことが明らかとなった．このことから，移行完了型パターンは本研究で定義するコーディングパターンとして特に重要な意義を持つと結論付けられる．
\section{おわりに}
本研究では，個別のプロジェクトに特化したコーディングパターンを収集するための条件を提案することで，自動修正に有用なパターンを抽出する方法を開発した．

本研究で提案した手法は，プロジェクトの変更履歴から抽出したコーディングパターン候補に対して，有用性に基づく選別を行うことで，対象プロジェクト固有の修正パターンの発見を可能にした．この成果は，従来の汎用的な深層学習アプローチでは対応が困難であった修正パターンの抽出を実現するものであり，プロジェクト特化型の自動修正技術に活用できることが示唆される．
%%
%% 本文 - ここまで
%%
%-------------------
%-------------------
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 参考文献
%%

\bibliographystyle{junsrt}
\bibliography{@BSthesis2024_Noguchi/BSthesis2024_Noguchi_thesis}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
