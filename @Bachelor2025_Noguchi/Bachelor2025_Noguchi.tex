\documentclass[11pt]{jreport}
\usepackage{wuse_thesis}
\usepackage{indentfirst}
\usepackage{url}	% \url{}コマンド用．URLを表示する際に便利
\usepackage{xcolor}
\usepackage{listings}
\usepackage{amsmath,amssymb}
\usepackage{tabularx}
\usepackage{stfloats}
\usepackage{booktabs}
\usepackage{threeparttable}
\usepackage{caption}
\usepackage[dvipdfmx]{graphicx}
%\usepackage{graphicx}  % ←graphicx.styを用いてEPSを取り込む場合有効にする
			% 他のパッケージ・スタイルを使う場合には適宜追加

\newcommand{\todo}[1]{\colorbox{yellow}{{\bf TODO}:}{\color{red} {\textbf{[#1]}}}}
\newcommand{\memo}[1]{\colorbox{magenta!30}{{\bf MEMO}:}{\color{red!50} {\textbf{[#1]}}}}
\newcommand{\ihara}[1]{\colorbox{green}{{\bf IHARA}:}{\color{blue} {\textbf{[#1]}}}}
\newcounter{patternID}

% コード例を載せるためのあれこれ
\definecolor{lightred}{RGB}{255,230,230}
\definecolor{lightgreen}{RGB}{230,255,230}

\lstset{
    basicstyle=\small\ttfamily,
    abovecaptionskip=0pt,
    captionpos=b,
    frame=tb,
    framexleftmargin=2em,
    numbers=left,
    numberstyle={\scriptsize},
    xleftmargin=\parindent,
    escapechar=|
}

%ListingのキャプションがFigureになってしまうのをListingに直すコマンド
\usepackage{caption}
\makeatletter
\let\MYcaption\@makecaption
\makeatother
\usepackage{caption}
\makeatletter
\let\@makecaption\MYcaption
\makeatother

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 主に表紙を作成するための情報
%%

%%  タイトル(修論の場合は英語表記も指定)
\title{修正による部分的な性能向上が期待される\\
       マイクロベンチマークにおける低速コードの検出}
%\etitle{Test\\Test\\Test}

%%  著者名(修論の場合は英語表記も指定)
\author{野口 隼杜}
%\eauthor{Akinori Ihara}

%% 卒業論文・修士論文(以下のどちらかを選択)
\bachelar	% 卒業論文(4年生用)

%%  学科・クラスタ
\department{システム工}

%%  学生番号
\studentid{60276185}

%%  卒業年度
\gyear{2025}		% 提出年が2022年なら，2021年度

%%  論文提出日
\date{2026年2月10日}	% 修士の場合は月(2021年2月)までとし，英語表記も指定
%\edate{February 2021}	% 修士の場合，こちら(英語表記)も有効化

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

%%
%%  概要
%%
\begin{abstract}
\todo{あとで作る}

「和歌山大学システム工学部卒業論文/
  大学院システム工学研究科修士論文用スタイルファイル」
は，
\begin{quote}
  \begin{description}
    \item[\tt wuse\_thesis.sty:] 卒業/修士論文用スタイルファイル
    \item[\tt thesis\_sample.tex:] スタイルファイル利用例
  \end{description}
\end{quote}
からなる．

なお，この卒業論文用スタイルファイル(p\LaTeX 版)に関する質問は，
メールにて
\begin{quote}
ihara@wakayama-u.ac.jp
\end{quote}
まで．

\end{abstract}

%%  目次
\tableofcontents

%%  図目次 (図目次をいれたければ以下のコメントをはずす)
%\listoffigures

%%  表目次 (表目次をいれたければ以下のコメントをはずす)
%\listoftables

\newpage
\pagenumbering{arabic}	% 以降のページ番号を算用数字に

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%%  本文はここから
%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{はじめに}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

ソフトウェア開発において，ソフトウェアの性能効率性は，JIS X 25010:2013（ISO/IEC 25010:2023）にシステム/ソフトウェア製品品質を図る尺度の一つとして記述され\cite{JISX25010}\cite{ISO25010}，システム全体の品質，さらにはユーザ体験や運用コストに直結する重要な要素である\cite{performance1}\cite{performance2}\cite{negative}．

このことから，開発者は，性能効率性の向上を目的に性能低下の要因特定および修正を行う．従来，こうした性能低下の要因を特定する手法としては，プロファイラなどを用いた動的解析が広く用いられる．しかし，この手法はプログラムが実行可能な状態でなければ適用ができず，開発の早期段階での適用が難しいという課題が存在する．
一般に，修正による影響範囲の拡大や，他の品質特性とのトレードオフの発生によって，開発が進行するに伴って修正コストは増大する傾向にある．そのため，開発の早期段階において性能効率性の評価を行う手法が求められている．

ここで，開発の早期段階において，システムやアルゴリズムの修正といった規模の大きな最適化だけでなく，既存のソースコード片をより効率的な実装へ置き換え，部分的な性能効率性の向上を図る「部分的な最適化」が行われることがある．\todo{引用？}

特定の処理に対する複数の実装方法の性能を定量的に比較するために，部分的なソースコード片の実行速度を計測する手法はマイクロベンチマークとよばれ，部分的な性能効率性の評価に用いられている．\todo{引用}
また．マイクロベンチマークを，開発者がWeb上で実行・共有することができるオンラインサービスも存在し，世界中の開発者が投稿した効率的な実装方法についての知見が蓄積されているとともに，開発に利用されることもある．

しかし，サービス上におけるマイクロベンチマークの知見を実プロジェクトの性能改善に直接転用することは難しい．これは，サービス上のソースコードは非常に短く，測定用の補助的コードなどが多分に含んでいることで，性能低下の本質的な要因が構造化されていないためである．このことから，ソースコードの構造的・意味的な特徴から本質的な要因を捉え，自身のプログラム中から低速な箇所を特定する処理が必要となる．

本研究は，マイクロベンチマークを共有するサービス上に存在する知見を利用し，修正することで実行速度の向上が期待されるソースコード片を静的に検出する手法を提案する．
具体的には，共有サービスに蓄積された実行速度が評価された機能的に等価な実装対に着目し，抽象構文木における構造的差分を解析することで，性能低下に寄与する本質的なコード構造を「低速コードパターン」として抽出する．このパターンを用いて，静的解析エンジンであるCodeQL\footnote{\url{https://codeql.github.com/}}\cite{ql}により，プログラムの実行を伴わずに大規模なソースコードから低速である実装箇所を特定する．
% なお，事前分析により，実装対の約4割に繰り返し処理が含まれていることから，特に反復構造に焦点を当ててパターンの抽出を行った．

これにより，提案手法は，動的解析に依存せずに性能効率性に寄与する潜在的なボトルネックを実装初期段階でも検出できる．

続く\ref{chap:background}章では，実行速度改善における課題，および関連研究を紹介し，本研究の立ち位置を述べる． \ref{chap:pre-analysis}章で事前分析について示し， \ref{chap:approach}章で，本研究の提案手法，\ref{chap:similarity}章で結果の分析手法について述べる．\ref{chap:case-study}章においてケーススタディの結果を述べ，\ref{chap:consideration}章で考察を行う．\ref{chap:threat}章で妥当性への脅威を示し，\ref{chap:finish}章でまとめる． 


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{プログラム実行速度の改善}
\label{chap:background}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

% -----------------------------------------
\section{ソフトウェアの性能効率性と部分的な最適化}
% -----------------------------------------

\todo{\textbf{はじめに}との棲み分けを考える}
ソフトウェアにおける性能効率性は，ユーザー体験の向上，運用コストの削減，およびシステム全体の品質を左右する極めて重要な指標である．
一般に，性能効率性の向上にはプロファイラといった動的解析を用いてボトルネックの特定が行われる．しかし，システムレベルの大規模なテストによる性能評価は，実行環境の構築や測定に多大なコストを要する\todo{引用}だけでなく，開発の後期工程で問題が発覚した場合，修正による影響範囲が広く\todo{引用}，実装が進むほどに開発者に対して広範な知識や経験を要するようになる．また，性能効率性を向上するためのプログラム変更では，可読性や保守性といった他の品質を損なうリスク（性能改善と他品質のトレードオフ）も指摘されている\cite{negative}．

これに対し，計算機能力やシステム設計の改善，アルゴリズムの抜本的な変更といった大規模な最適化だけでなく，既存のソースコード断片をより効率的な実装へ置き換える「部分的な最適化」を積み重ねることによって性能効率性の向上を実現することも多い．
% \todo{↓書くなら参考文献欲しい}
% 特に，ループ処理やデータ構造操作のように実行回数が多い箇所では，わずかな実装差が全体の実行時間に影響を与えることがある．このようなミクロな性能差を把握し，適切に改善することは，現実的な性能改善戦略の一つである．実際に，
Webアプリケーション開発では，数行のソースコード修正によって最適化した結果，プログラムの実行時間が25\%から70\%高速化している\cite{jsRefac}．
また，プログラムを構成する関数やメソッドなどの最小単位が正しく動作するかを検証するユニットテストを実行することや，ユニットテストをもとにしたベンチマークを作成することで，コンポーネント単位の微小な範囲でパフォーマンスの変化を早期に評価することが可能となる\todo{引用}．

% 参考文献候補リスト
% 大規模なシステムテストで性能テストやってますよ
% R. Gao, Z. M. Jiang, C. Barna, and M. Litoiu, “A framework to evaluate the effectiveness of different load testing analysis techniques,” in 2016 IEEE International Conference on Software Testing, Verification and Validation, ICST 2016, Chicago, IL, USA, April 11-15, 2016, 2016, pp.22–32.
%  H. Malik, H. Hemmati, and A. E. Hassan, “Automatic detection of performance deviations in the load testing of large scale systems,” in 35th International Conference on Software Engineering, ICSE ’13, San Francisco, CA, USA, May 18-26, 2013. IEEE Computer Society, 2013, pp. 1012–1021.
% T. H. D. Nguyen, B. Adams, Z. M. Jiang, A. E. Hassan, M. N. Nasser, and P. Flora, “Automated verification of load tests using control charts,” in 18th Asia Pacific Software Engineering Conference, APSEC 2011, Ho Chi Minh, Vietnam, December 5-8, 2011. IEEE Computer Society, 2011, pp. 282–289.
% システムテストはコストめっちゃかかりますよ
 % J. Chen, W. Shang, A. E. Hassan, Y. Wang, and J. Lin, “An experience report of generating load tests using log-recovered workloads at varying granularities of user behaviour,” in 34th IEEE/ACM International Conference on Automated Software Engineering, ASE 2019, San Diego, CA, USA, November 11-15, 2019. IEEE, 2019, pp. 669–681.
% これに対応するため，ユニットテストやマイクロベンチマークでコンポーネントレベルの小さな範囲でパフォーマンス測ってますよ（動的？ちゃんと見る）
% J. Chen and W. Shang, “An exploratory study of performance regression introducing code changes,” in 2017 IEEE International Conference on Software Maintenance and Evolution, ICSME 2017, Shanghai, China, September 17-22, 2017. IEEE Computer Society, 2017, pp. 341–352.
% Z. Ding, J. Chen, and W. Shang, “Towards the use of the readily available
% tests from the release pipeline as performance tests: are we there yet?” in ICSE ’20: 42nd International Conference on Software Engineering, Seoul, South Korea, 27 June - 19 July, 2020. ACM, 2020, pp. 1435–1446.
% V. Horky, P. Libic, L. Marek, A. Steinhauser, and P. Tuma, “Utilizing performance unit tests to increase performance awareness,” in Proceedings of the 6th ACM/SPEC International Conference on Performance Engineering, Austin, TX, USA, January 31 - February 4, 2015. ACM,2015, pp. 289–300.
% D. G. Reichelt, S. Kuhne, and W. Hasselbring, “Peass: A tool for ¨identifying performance changes at code level,” in 34th IEEE/ACM International Conference on Automated Software Engineering, ASE 2019, San Diego, CA, USA, November 11-15, 2019. IEEE, 2019, pp.1146–1149
% ↓マイクロベンチマークも使ってるやつ
% M. Jangali, Y. Tang, N. Alexandersson, P. Leitner, J. Yang, and W. Shang, “Automated generation and evaluation of jmh microbenchmark suites from unit tests,” IEEE Transactions on Software Engineering, 2022.
% C. Laaber and P. Leitner, “An evaluation of open-source software microbenchmark suites for continuous performance assessment,” in Proceedings of the 15th International Conference on Mining Software Repositories, MSR 2018, Gothenburg, Sweden, May 28-29, 2018. ACM, 2018, pp. 119–130.（ソフトウェアマイクロベンチマークスイートの評価に関してLaaberとLeitner[41]は，ほとんどのJavaプロジェクトで50%を超える（すなわち，1.5倍遅い）速度低下はしばしば確実に検出できると観察しています．）

% -----------------------------------------
\section{マイクロベンチマーク共有サービス}
% -----------------------------------------

実装段階において，特定の処理に対する複数の実装方法の性能を定量的に比較する手法として，マイクロベンチマークが活用されている．マイクロベンチマークは，機能的に等価な複数のソースコード断片に対して実行時間を測定し，その効率性を相対的に評価するものである．

マイクロベンチマーク共有サービスは，マイクロベンチマークを開発者がWeb上で実行・共有するプラットフォームとして機能するオンラインサービスである．例として，JavaScript言語を対象としたJsPerf\footnote{JsPerf: \url{https://jsperf.app/}}やMeasureThat.net\footnote{MeasureThat.net: \url{https://measurethat.net/}}が挙げられる．これらのサービスは，ブラウザ上での実行環境を提供するとともに，世界中の開発者が投稿したソースコード断片とその測定結果を公開している．

図\ref{fig:jsPerf}に，JsPerf上で実際に投稿されているマイクロベンチマークの例を示す．
マイクロベンチマーク共有サービスにおける各ベンチマークは，1つのセットアッププログラムと，1つ以上のテストプログラムから構成される．図上部に示すセットアッププログラムは，検証対象のソースコードで共通して利用される変数や関数の初期化などが行われる．一方，図下部に示すテストプログラムでは，同一の機能を異なる方法で実装したソースコード片が複数記述され，それぞれの実行速度をの計測，および比較ができる．
このようなマイクロベンチマークは，データ構造や制御構文の選択，メソッド呼び出しの方法などに多様性が見られ，実行速度の差とその要因となる実装方法を捉えることができる．

実際の開発現場においても，GitHub上のプルリクエスト等において，提案する改善案の正当性を示すエビデンスとしてこれら共有サービスのURLが引用される事例が確認されており\cite{saiki},マイクロベンチマーク共有サービスは「効率的な実装パターン」を示すデータベースとして機能していることが示唆される．

% 本研究では，このようなマイクロベンチマーク共有サービス上の実装対を，性能効率性，特に実行速度に影響を与える構造的特徴を分析および抽出するために利用する．

%----------------------
\begin{figure}[!h]
    \centering
    \includegraphics[width=0.6\linewidth]{./fig/jsPerf_example.pdf}
    \caption{マイクロベンチマーク共有サービスの投稿例\protect\footnotemark}
    \label{fig:jsPerf}
\end{figure}

\footnotetext{\url{https://jsperf.app/qiwudo}}
%----------------------

% -----------------------------------------
\section{低速箇所の検出における課題}
% -----------------------------------------

ここで，既存の実装から性能向上の余地がある低速な箇所を特定する際，従来の性能評価手法における課題と，その解決策として期待されるマイクロベンチマーク共有サービスの利用における特有の課題について述べる．

従来の性能評価手法における主要な課題は，その多くがプログラムの動的実行に依存している点である．プロファイラやマイクロベンチマークを用いた手法は，実際の動作状況や実行時間を計測することでボトルネックを特定する．そのため，解析対象となるプログラムがコンパイル可能であり，かつ実行に必要な依存ライブラリやテストデータが整備された「実行可能状態」にあることが前提となる．

しかし，開発の初期段階やリファクタリングの検討段階において，断片的なソースコードに対して即座に実行環境を構築することは容易ではない．また，実装が進むにつれて性能改善のためのプログラム変更は複雑化する傾向にあることが示されている\cite{complicate}．したがって，動的解析を利用する従来の手法では，実装の最中にリアルタイムで低速な記述を検出し，開発を支援することが困難であるという課題がある．

これに対し，マイクロベンチマーク共有サービスを活用するアプローチは，事前に第三者によって実行速度が評価された実装方法を利用できるため，自身のプログラムに対する動的実行への依存を排除，あるいは最小化できる可能性がある．

しかし，同サービスに保存されたマイクロベンチマークを実際の開発に適用するには，サービス特有の性質に起因する課題が存在する．共有サービス上のソースコード片は，不特定の開発者が特定の文脈で局所的な比較を目的に作成したものである．そのため，
% 特定の実行環境や入力データに対してのみ有意な差が生じる「コンテキストへの依存」や，
測定用の補助的な変数宣言や処理など，実行速度の差を生み出す要因とは無関係な記述が混在している．

マイクロベンチマークという極めて小さなソースコード片において，低速の本質的な要因が構造化されていないため，自身のプログラム中から類似の箇所を特定し，改善案を適応することは容易ではない．したがって，膨大な公開データから汎用的な「低速な要因」を抽出・検出するためには，ソースコードの構造的・意味的な特徴を捉え，ソースコード片から本質的なパターンを識別する解析手法が必要となる．


% -----------------------------------------
\section{関連研究}
% -----------------------------------------

\subsection{実行速度向上を目的としたリファクタリングの調査}

Selakovicら\cite{jsRefac}は，JavaScriptを利用しているプロジェクトにおいて，開発者が高速化のために行ったリファクタリングを調査している．調査の結果，開発者は10行程度の小さい範囲の修正によって高速化への対処を行なっていることを明らかにした．この結果から，マイクロベンチマークで評価される短いソースコード片を利用した修正が，ソフトウェア高速化につながっていることを示唆していると考えられる，また，\cite{jsRefac}では，JavaScriptプロジェクトの解析によって10件の頻出する高速化修正パターンを作成している．この改良パターンを用いた自動修正は一定の高速化効果を示しているが，該当箇所の特定における制約などから，広範な適用には至っていない．

\subsection{静的解析と動的解析を用いた性能ボトルネックの検出}

Turcotte ら\cite{DrAsync}は，JavaScript 言語における非同期処理に注目し，ソースコードの目視調査やStack Overflow上の知見から，より効率的・簡潔な記述方法が存在する実装方法を性能アンチパターンとして定義し，静的解析エンジンであるCodeQL\cite{ql}と動的解析による実行頻度や呼び出し関係の監視を組み合わせて，修正可能な性能アンチパターンの検出手法の提案した．

非同期処理という特定のドメインに対する手動定義されたパターンに限定しているものの，静的解析による広範な実装形態への適用を実現している．本研究では，マイクロベンチマーク共有サービスに保存された多様な実装対から，自動的にパターンを抽出・生成することを目指す．これにより，静的検出アプローチを継承・発展させつつ，より汎用的な性能改善支援を提供する．

% -----------------------------------------
\section{本研究の位置付け}
% -----------------------------------------

本研究では，修正によって実行速度の向上が期待される箇所を，開発の早期段階で静的に検出する手法を確立することを目的とし，マイクロベンチマーク共有サービスにおいて実行速度が評価された実装対から，構文構造をデータ構造に変換した抽象構文木における構造的な差分をもとに，静的な解析に利用できる汎用的な「低速コードパターン」を作成し，その検出を行う手法を提案する．
マイクロベンチマーク共有サービスで示される多様な実装方法と動的解析の結果（実行速度の差異）から，静的なパターンへと変換することで，より多様な低速要因を抽出し，開発者がプログラムを動作させる前の実装の初期段階において，静的解析のみで潜在的な高速化修正候補を検出することが可能となる．
\memo{難しさで触れた小さなコード片の検出の話をからめて，正規表現やコードクローンではなく，構造情報を検出に利用する話を埋め込みたいけどどこがいいか．．．4.3節あたりで回収する方がいい？}


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{事前分析：マイクロベンチマークにおける低速コードの特徴}
\label{chap:pre-analysis}
%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{データセット}

本研究では，大森ら\cite{omori}が作成したデータセットを分析対象とする．当該データセットは，JavaScript言語を対象としたマイクロベンチマーク共有サービスJsPerfにおいて，公開されているマイクロベンチマークの中で，実行速度に有意差があり，外的振る舞いが等しいことが検証された29,809件の実装対である．以降，分析対象とする，マイクロベンチマークで比較されたソースコード片の対をマイクロベンチマーク実装対，各実装対において，実行速度が遅いコードを低速コード，実行時間が速いコードを高速コードとする．


\section{抽象構文木に基づく実装方法の分析}

低速コードパターンを抽出するための指針を獲得することを目的とし，マイクロベンチマーク実装対における構造的特徴に関する調査を行った．
具体的には，マイクロベンチマーク実装対のソースコードを抽象構文木に変換し，各コード断片に含まれる構文要素の分析を実施した．その結果，11,893件の実装対（全実装対の39.9\%）において，繰り返し処理に関連する構文（JavaScriptにおける \texttt{for}，\texttt{for-of}，\texttt{for-in}，\texttt{while}，および \texttt{do-while}）が含まれていることがわかった．

この結果から，繰り返し処理を含むマイクロベンチマーク実装対11,893件について，さらに詳細な差分解析および目視調査を行った．具体的には実装対を構成する2つのソースコード片間の抽象構文木における構造的な差分を抽出し，差分と元の実装対の特徴について目視で確認を行った．
次節において，構造的差分および目視調査において確認したマイクロベンチマーク実装対のもつ特徴について具体例を示す．


\section{繰り返し処理を含む低速コードの主要パターン}

マイクロベンチマーク実装対において確認した，実行速度に差が生じる繰り返し処理の使用パターンとその特徴について，具体例として，Listing~\ref{diff-loop}，Listing~\ref{diff-inloop}，Listing~\ref{diff-method}に示す．

Listing~\ref{diff-loop}は，それぞれ\texttt{for-in}文を用いて配列に含まれる要素にアクセスする実装と，同様の処理を\texttt{for}文で実装したソースコード片である．ここで示すパターンは，実行時間の差が，繰り返し処理を行う構文そのものが異なることに起因する実装対である．

%----------------------------------
\begin{lstlisting}[caption=繰り返し処理自体の実装方法が異なる実装対, label=diff-loop, captionpos=t, columns=flexible]
// slow
for (key in VAR_1) {
    if (!VAR_1.hasOwnProperty(key)) continue;
    VAR_2 = VAR_1[key];
}

// fast
for (var VAR_8=0; VAR_8<VAR_1.length; ++VAR_8) {
    VAR_2 = VAR_1[VAR_8];
}
\end{lstlisting}
%----------------------------------

Listing~\ref{diff-inloop}は，それぞれ\texttt{for}文内で \texttt{concat}メソッド，\texttt{push}メソッドを用いている実装対である．これは，同一の繰り返し処理を行う構文において，その繰り返し内部で実行する処理の記述方法が異なることによって実行速度の差が生じている実装対である．

%----------------------------------
\begin{lstlisting}[caption=繰り返し内部で実行する処理の記述方法が異なる実装対, label=diff-inloop, captionpos=t, columns=flexible]
// slow
for (var VAR_2=0; VAR_2<5000; VAR_2++)
    VAR_1 = VAR_1.concat([\"1\", \"2\"]);

// fast
for (var VAR_2=0; VAR_2<5000; VAR_2++)
    VAR_1.push(\"1\", \"2\");
\end{lstlisting}
%----------------------------------

Listing~\ref{diff-method}は，繰り返し処理を\texttt{forEach}メソッドで実装したソースコード片と\texttt{for-of}文で実装したソースコード片である．これは，メソッドによる処理とそれに代替する繰り返し処理について比較した実装対であり，メソッド呼び出しのオーバーヘッドや内部的な最適化の有無により実行速度の差が生じていることが示唆される実装対である．

%----------------------------------
\begin{lstlisting}[caption=メソッド処理と代替する繰り返し処理に関する実装対, label=diff-method, captionpos=t, columns=flexible]
// slow
var VAR_5 = new Set(VAR_2);
VAR_5.forEach(VAR_6 => {});

// fast
for (let VAR_7 of VAR_2) {}
\end{lstlisting}
%----------------------------------

これらの結果から，マイクロベンチマーク実装対において，抽象構文木の構造的差分の中に，性能低下の要因となる特徴的なノード構成が含まれていることを確認したとともに，繰り返し処理および繰り返す処理の記述内容の違いが性能差の要因の1つとして存在することを確認した．
以上の事前分析の結果に基づき，本研究では，繰り返し処理に焦点を当て，マイクロベンチマーク実装対の構造的差分を解析することで低速コードの特徴を抽出し，次章以降で述べる低速コードパターンの作成および静的検出に利用する．


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{構造的差分に基づく低速コードパターンの検出手法}\todo{全体概要図を作る}
\label{chap:approach}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{分析対象となるマイクロベンチマーク実装対の収集}
\label{collectLoop}

% \ref{chap:pre-analysis}章より，本研究では，従来研究\cite{omori}で対象とするマイクロベンチマークの中で，比較されるソースコードに繰り返し処理を含むマイクロベンチマーク実装対を収集する．

事前分析に基づき，本研究では，データセットにおいてソースコード片に繰り返し処理を含むマイクロベンチマーク実装対を対象として収集する．
\ref{chap:pre-analysis}章と同様に，29,809件のマイクロベンチマーク実装対について，各実装対のソースコードを抽象構文木へ変換した．次に，繰り返し処理である構文のノードを含んでいるかどうかを確認し，結果として 11,889件の実装対を収集した．

\section{低速コードパターンの作成}
\subsection{差分解析による低速コードの特徴抽出}\label{approach:extract}

マイクロベンチマーク実装対における低速コードの特徴として低速コード特有の処理や構造を示す要素を抽出するために，差分解析ツールであるGumTree\cite{gumtree}を使用する．
GumTreeは，ソースコードの抽象構文木を基にした差分解析ツールであり，変更前後のソースファイルまたは抽象構文木を受け取ると，抽象構文木におけるノード単位の編集操作とその差分要素を出力する．検出できる編集操作は，「削除」「挿入」「移動」「更新」である．

本手法では，収集したベンチマーク実装対において，低速コードから高速コードへの変更を想定し，GumTreeを利用して，編集操作とその差分要素を収集する．次に，収集した要素のうち，低速コードから削除または更新された要素を抽出する．これらの要素を，低速コード特有の処理や構造を示す要素であるとして，低速コードの特徴候補として収集する．

例として，Listing \ref{diff-loop} に示す低速コードと高速コードの実装対において，この処理を実施した結果をListing~\ref{candidates}に示す．この処理によって，Listing~\ref{candidates}における背景色のついた要素が低速コードの特徴候補として収集できる．

次に，収集した低速コードの特徴候補の中から，プログラムの振る舞いに意味的な影響を与える要素として，繰り返し処理，メソッド呼び出し，配列・オブジェクト操作を抽出・統合する．

図\ref{fig:slow_pattern}は，Listing~\ref{candidates}から作成した低速コードパターンを示す．当該パターンは，if 文内で.hasOwnProperty() を呼び出す for-in 文という特徴を有することが読み取れる．

%----------------------------------
\begin{lstlisting}[caption=Characteristic Candidates for Slow Code, label=candidates, captionpos=t, columns=flexible, literate=
    {for}{{\textcolor{black}{\colorbox{lightred}{for}}}}{3}
    {key}{{\textcolor{black}{\colorbox{lightred}{key}}}}{3}
    {in }{{\textcolor{black}{\colorbox{lightred}{in}}\kern0.5em}}{3}
    {VAR\_1}{{\textcolor{black}{\colorbox{lightred}{VAR\_1}}}}{5}
    {if}{{\textcolor{black}{\colorbox{lightred}{if}}}}{2}
    {!}{{\textcolor{black}{\colorbox{lightred}{!}}}}{1}
    {hasOwnProperty}{{\textcolor{black}{\colorbox{lightred}{hasOwnProperty}}}}{15}
    {continue}{{\textcolor{black}{\colorbox{lightred}{continue}}}}{8}
    {VAR\_1\_}{{\textcolor{black}{VAR\_1}}}{6}
]
for (key in VAR_1) {
  if(! VAR_1.hasOwnProperty(key))continue;
  VAR_2 = VAR_1_[key];
}
\end{lstlisting}
%----------------------------------

% \todo{後で直す}
%----------------------
\begin{figure}[!h]
    \centering
    \includegraphics[width=1.0\linewidth]{./fig/slow_pattern.pdf}
    \caption{低速コードパターン例}
    \label{fig:slow_pattern}
\end{figure}
%----------------------


\subsection{低速コードパターンの定義}

\ref{approach:extract}節で述べた手法に基づき，収集したマイクロベンチマーク実装対に対して構造的差分解析を適用し，重複する特徴を集約した．次に，集約された各特徴が，元のマイクロベンチマーク実装対における低速な要因を反映しているかを確認するため，元の実装対と抽出された構造的特徴との対応関係について目視調査を行い，繰り返し処理における低速な要因を適切に表現していると判断した6種類の低速コードパターンを定義した．

表\ref{tab:slow_code_patterns}の“特徴”に作成した6パターンについての概要，“元実装対数”にデータセットにおいて，そのパターンを抽出したマイクロベンチマーク実装対の数を示す．


\section{CodeQLによる低速コードパターンの静的検出}
\subsection{CodeQL}

本研究では，定義した6つの低速コードパターンを実プロジェクトから検出するために静的解析エンジンであるCodeQL\cite{ql}\cite{codeql}を用いる．CodeQLは，GitHub社が開発したコード解析プラットフォームであり，プログラムの構造的・意味的な探索を可能にするツールである．

CodeQLは，対象となるソースコードを解析し，抽象構文木，制御フロー，およびデータフローの情報を含むリレーショナルデータベースを構築する．これに対し，論理プログラミング言語であるQL言語を用いてクエリを記述することで，このデータベースから特定のパターンに合致するコード断片を検索できる．

なお，本研究においては抽象構文木に基づく構造情報をもとに作成した低速コードパターンの検出において，構造情報を参照して静的動作する点でCodeQLを採用した．


\subsection{低速コードパターンからCodeQLクエリへの変換}

6つの低速コードパターンをCodeQLで検出可能な形式に変換するため，各パターンの構造的特徴に基づいたQLクエリを手作業で作成した．検出対象の粒度はブロック単位とした．例としてListing~\ref{tab:slow_code_patterns}より，ID\ref{ptn:hasOwnProperty}：低速コードパターン“\texttt{if}文に\texttt{.hasOwnProperty()}呼び出しを持つ\texttt{for-in}文”から作成したQLクエリを\ref{query:ID3}に示す．

本研究では，6つの低速コードパターンから作成したクエリを，対象プロジェクトのCodeQLデータベースに対して実行することで，低速な実装方法が用いられている箇所を検出する．

%----------------------------------
\begin{lstlisting}[caption=\texttt{if}文に\texttt{.hasOwnProperty()}呼び出しを持つ\texttt{for-in}文のQLクエリ, label=query:ID3, captionpos=t, columns=flexible, escapechar=\@]
predicate forInWithIfhasOwnProperty(ForInStmt f) {
  exists(IfStmt ifStmt |
    // if 文が for-in 文の配下に含まれる
    f.getBody().getAChild*() = ifStmt and    
      // if 条件式内に hasOwnProperty 呼び出しが存在
      exists(CallExpr c |
        c = ifStmt.getCondition().getAChild*() and
        c.getCallee().(PropAccess).getPropertyName() = "hasOwnProperty"
      )
  )
}
\end{lstlisting}
%----------------------------------


\subsection{作成したクエリの妥当性検証}

作成したQLクエリが，低速コードパターンを正確に反映できているかを検証するため，収集済みのマイクロベンチマークデータセットを用いて検出実験を行った．ここでは，\ref{collectLoop}節で収集したマイクロベンチマーク実装対における低速コード全11,889件を対象とした．
作成した6種類のクエリを実行し，検出したソースコード片の件数およびその内容を分析した．クエリの性能を定量的に評価するため，以下の定義に基づき再現率および適合率を算出した．

再現率（Recall）: 特定のパターンを抽出した元の実装対における低速コード片のうち，クエリによって検出された割合．
$$\text{再現率} = \frac{\text{検出結果に含まれる元低速コード片の数}}{\text{元低速コード片の数}}$$

適合率（Precision）: クエリによって検出された全ソースコード片のうち，元の実装対における低速コード片が占める割合．
$$\text{適合率} = \frac{\text{検出結果に含まれる元低速コード片の数}}{\text{総検出数}}$$

検出したソースコード片の数を表\ref{tab:slow_code_patterns}の「検索結果」に示す．6種類全てのクエリにおいて，検出した全てのソースコード片の中に，パターンを抽出した元の実装対における低速コード片を全て検出した．
これにより，再現率は100\%となり，作成したクエリが意図した低速コードパターンを検出できることを確認した．
一方で，適合率はパターンの種類により13.5\%～61.1\%の範囲に留まった．この比較的低い適合率は，必ずしもクエリの精度の低さを意味するものではなく，本研究のパターン抽出手法の性質に起因するものである．

本研究では差分解析を用いてパターンを抽出しているため，特定のマイクロベンチマーク実装対において差分として現れなかった箇所であっても，クエリが示す特徴を備えている実装対が存在する．これらが検出されたことが，数値上の適合率を押し下げる要因となっている．\memo{具体例あった方がいい？}

ただし，本手法をGitHub上の実リポジトリ等の未知のソースコード群に適用する場合には，対象とする低速コードパターンに対して，偽陽性となるソースコード片が一定数検出される可能性がある．

%----------------------¬
\begin{table}[!h]
    \centering
    \caption{低速コードパターン}
    \label{tab:slow_code_patterns}
    \setcounter{patternID}{0} % 表が始まる前にカウンタを0にリセット
    \begin{threeparttable}
        \begin{tabular}{clrr}
            \toprule
            \textbf{ID} & \textbf{特徴} & \textbf{元実装対数\tnote{*}} & \textbf{検出結果} \\
            \midrule
            
            \refstepcounter{patternID}\label{ptn:for-in}
            \thepatternID & \texttt{for-in}文 & 534 & 1000 \\
            
            \refstepcounter{patternID}\label{ptn:forEach}
            \thepatternID & \texttt{.forEach()}呼び出し & 194 & 346 \\
            
            \refstepcounter{patternID}\label{ptn:hasOwnProperty}
            \thepatternID & \texttt{if}文に\texttt{.hasOwnProperty()}呼び出しを持つ\texttt{for-in}文 & 102 & 195 \\

            \refstepcounter{patternID}\label{ptn:applymap}
            \thepatternID & \texttt{.apply().map()}呼び出し & 12 & 89 \\
            
            \refstepcounter{patternID}\label{ptn:json}
            \thepatternID & \texttt{.parse(.stringify())}呼び出し & 11 & 18 \\
            
            \refstepcounter{patternID}\label{ptn:push}
                \thepatternID & \texttt{.push()}呼び出しを持つ\texttt{for-of}文 & 8 & 38\\
            \bottomrule
        \end{tabular}
        
        \begin{tablenotes}
            \raggedleft
            \item[*] 各パターンを抽出したマイクロベンチマーク実装対の数
        \end{tablenotes}
    \end{threeparttable}
\end{table}
%----------------------


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{類似度に基づく検出結果の順位付け}
\label{chap:similarity}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{妥当な検出結果の判定}

\todo{静的検出においては，本当の正解がわからないので正解っぽいやつを優先順位上げたい}
\todo{今回は，パターンを構造的なところで絞っているので，構造的な情報を付与した値を用いたい}

提案手法によって実際のプログラムから検出されたソースコード片が，低速コードパターンを実際に含んでいるかを評価するために，検出結果の妥当性を判定する必要がある．ここで，本研究における正しい検出結果は，低速コードパターンを含み，かつマイクロベンチマーク共有サービスにおいて実行速度が評価された実装方法を実際に採用している箇所である．
% 実際のソフトウェア文脈においても採用している箇所である．

しかし，実プロジェクトのソースコードを対象とする場合，どの箇所が真の正解であるかは自明ではなく，また，検出数が膨大になる場合，全ての検出結果に対して目視による分析を行うことは現実的ではない．
% そのため，適合率や再現率といった指標で評価を行うことは困難である．

そこで，パターンの元となったマイクロベンチマーク上の低速コードと，実際の検出結果との類似度を指標として用いる．類似度の高い順に検出結果を順位づけし，高類似度の検出結果，および低類似度の検出結果の傾向を比較・分析することで，検出結果の妥当性および本手法の特性を明らかにするアプローチを採る．

\section{ソースコード片の分散表現化}

ソースコード間の類似度を定量的に評価するため，コード断片を多次元のベクトルとして表現する分散表現を用いる．
本手法では，ソースコードにおける構造的な情報に基づいて低速コードパターンの作成および検出を行っていることから，ソースコードの構造的な特徴を考慮して分散表現を取得することが可能なCode2Vecを採用した．

Code2Vecは，ソースコードの抽象構文木から抽出されたパスに基づき，プログラムの構造的な情報を用いて分散表現を取得する手法である．利用においては，saikiら\cite{saiki} が作成した，JavaScript に対応したパスコンテキスト変換処理と学習モデルを利用する．


\section{コサイン類似度による検出結果の順位づけ}

\todo{マイクロベンチマークに対して算出した結果をここに載せるのもあり}

具体的な類似度の算出および順位づけの手順を示す．

まず、特定の低速コードパターンについて，パターンの抽出元となった複数のマイクロベンチマーク上の低速コード片と，実プロジェクトからの検出結果をそれぞれCode2Vecを用いて分散表現へと変換する．
次に，ある一つの検出コード片に対して，パターンの元となった個々の低速コード片との間で類似度を算出する．ここでは，ベクトル間の類似度の測定方法から，コサイン類似度を利用する．

2つのソースコード断片$A,B$のコードベクトルを$\overrightarrow{a},\overrightarrow{b}$とした時，内積の定義から，コサイン類似度は次のように計算される．

\begin{displaymath}
	cos(\overrightarrow{a}, \overrightarrow{b}) = \frac{\overrightarrow{a} \cdot \overrightarrow{b}}{|\overrightarrow{a}||\overrightarrow{b}|}
	= \frac{\sum_{i=1}^d \overrightarrow{a}_{i} \overrightarrow{b}_{i}}{\sqrt{\sum_{i=1}^d (\overrightarrow{a}_{i})^2} \cdot \sqrt{\sum_{i=1}^d (\overrightarrow{b}_{i})^2}}
\end{displaymath}

ソースコード断片$A,B$が意味的に類似している場合，2つのベクトル$\overrightarrow{a},\overrightarrow{b}$は間の角度が0に近づき，その結果$cos(\overrightarrow{a}, \overrightarrow{b})$が1に近づく．この$cos(\overrightarrow{a}, \overrightarrow{b})$がコサイン類似度であり，ベクトル間の類似度を$[-1,1]$の範囲で測定できる．

次に，パターンの元となった全ての低速コード片に対する類似度の平均値を算出し，その値を当該検出コード片の類似度スコアとする．この処理を全ての検出結果に対して実施し，スコアの降順でソートすることで，元の低速実装に近い特徴を持つ順に結果を並べる．

% この順位づけにより，類似度が高い上位の結果において期待通り正解（低速な実装方法の合致）が集中しているか，また類似度が低い結果においてどのような構造的ノイズや文脈の差が含まれているかを，効率的かつ体系的に分析することが可能となる．

%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{ケーススタディ}
\label{chap:case-study}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{概要}

ケーススタディとして，分散バージョン管理システムであるGitHubで公開されているリポジトリを対象に，本研究で定義した6つの低速コードパターンの検出実験を行う．
CodeQLを用いて，リポジトリごとにソースコードを解析したデータベースを構築し，低速コードパターンから作成したQLクエリを用いて低速コードパターンを含むソースコード片を検出する．この操作によって得た結果について，\ref{chap:similarity}章で述べた手順に従い類似度を算出し，類似度の値をもとに目視で検出結果を確認，および分析を行う．

\section{実験対象}

GitHubで公開されているリポジトリから，JavaScriptを主要言語とする，最終コミットが1年以内のスター数上位1,000件のリポジトリを収集する．収集したリポジトリから，2025年10月13日時点で最新のスナップショットにおけるJavaScriptファイルを対象とする．

\section{検出結果と類似度順位づけ}
\subsection{低速コードパターンによる検出結果}

表\ref{tab:result_detect}は，表\ref{tab:slow_code_patterns}に示した各低速コードパターンの検出結果を示す．表中には，パターンID，1つ以上のソースコード片が検出されたリポジトリ数，単一リポジトリにおける最大検出数，1,000リポジトリにおける総検出数を示す．

表\ref{tab:result_detect}から，パターンによって検出数に差があるものの，48リポジトリ〜842リポジトリで検出された．低速コードパターンID\ref{ptn:for-in}や，低速コードパターンID\ref{ptn:forEach}の低速コードパターンのように，マイクロベンチマーク実装対における検索結果の数が多いパターンはデータセット中のリポジトリにおいても検出数が多かった．なお，これらのパターンは一般的に利用される繰り返し処理の構文であることから，検出数が多いことは妥当であると考えられる．また，これに対し，低速コードパターンID\ref{ptn:push}では，マイクロベンチマーク実装対において，検索結果の数が少なかったものの，データセットにおけるリポジトリにおいては検出数が多くなった．これは，一般的に可読性が高いとされる\texttt{for-of}についての低速コードパターンであることから，実行速度以外の品質への考慮が示唆される．

%----------------------
\begin{table}[!h]
    \centering
    \caption{低速コードパターンによる検出結果}
    \label{tab:result_detect}
    \begin{tabular}{crrr}
        \toprule
        \textbf{ID} & \textbf{検出リポジトリ数} & \textbf{最大検出数 (件)} & \textbf{総検出数 (件)} \\
        \midrule           
        \ref{ptn:for-in} & 689 & 7,378 & 90,592 \\
        \ref{ptn:forEach} & 842 & 12,675 & 161,681 \\
        \ref{ptn:hasOwnProperty} & 308 & 1,125 & 9,516 \\
        \ref{ptn:applymap} & 48 & 12 & 138 \\
        \ref{ptn:json} & 282 & 142 & 2,684 \\
        \ref{ptn:push} & 477 & 3,351 & 30,075 \\
        \bottomrule
    \end{tabular}
\end{table}
%----------------------

%----------------------
\begin{figure}[t]
    \centering
    \includegraphics[width=0.8\linewidth]{./fig/log_ID3_spia.pdf}
    \caption{低速コードパターンID3による検出数と規模}
    \label{fig:plot_id3}
\end{figure}
%----------------------

図\ref{fig:plot_id3}は，低速コードパターンID\ref{ptn:hasOwnProperty}について，リポジトリ規模に対する検出数の関係を示す．横軸は各リポジトリに含まれるJavaScriptファイルの総行数，縦軸は検出数を示す．リポジトリ規模が大きくなるほど低速コードパターンの検出数が増加する傾向があり，スピアマンの順位相関係数は0.44，p値は\(5.12 \times 10^{-14} < 0.05\)より正の相関が認められる．他の低速コードパターンについても，同様の傾向が見られた．\memo{他のパターンの結果を載せる？}


\subsection{類似度に基づく検出結果の特徴分析}

\memo{他のパターンについてもやった方がいい？}
\todo{箱ひげ図作り直す}
図\todo{~}は，パターンID \ref{ptn:hasOwnProperty}“\texttt{if}文に\texttt{.hasOwnProperty()}呼び出しを持つ\texttt{for-in}文”の検出結果を対象としたコサイン類似度スコアを示した箱ひげ図である．また，Listing~\ref{ID3_highcos}にコサイン類似度の高い検出例，\todo{\ref{ID3_lowcos}にコサイン類似度の低い検出例を示す．}それぞれ，類似度スコアは$0.39$，\todo{類似度スコア}である．

なお，長大，または文法的に不正なソースコード片は，分散表現取得における構文解析で失敗する．したがって検出総数9,516件中，分散表現の取得に成功した7,039件が含まれている．

% 検出したソースコード片と，表\ref{tab:slow_code_patterns}に示すID \ref{ptn:hasOwnProperty}のパターン作成に使用した低速コード群102件を対象に，それぞれコサイン類似度を計算した結果を箱ひげ図で示す．左側の箱ひげ図（ID3検出結果）中の点は，検出した各ソースコード片別に，78件の低速コード群と総当たりでコサイン類似度を算出した平均値の分布を示す．右側の箱ひげ図（マイクロベンチマーク）中の点は，マイクロベンチマーク実装対において検出したソースコード片について，パターン作成に使用したベンチマーク実装対を除き，同様に総当たりでコサイン類似度を算出した平均値の分布を示す．なお，ID \ref{ptn:hasOwnProperty}における低速コードパターンを持つ低速コードの例は，Listing~\ref{diff-loop}に示す．\todo{マイクロベンチマークの方の結果は5章にでも載せる}

% %----------------------
% \begin{figure}[t]
%     \centering
%     \includegraphics[width=0.85\linewidth]{./fig/boxplot_compare.pdf}
%     \caption{低速コードパターンID \ref{ptn:hasOwnProperty}で検出されたソースコード片とパターン元低速コードのコサイン類似度}
%     \label{fig:boxplot_cosine}
% \end{figure}
% %----------------------

% 一方，マイクロベンチマークでは，平均値は0.61，中央値は0.68となった．コサイン類似度の高い検出例について，リポジトリにおけるソースコード片と，マイクロベンチマーク実装対におけるソースコード片をそれぞれ，Listing\ref{ID3_highcos}とListing\ref{MB_highcos}に示す．
% それぞれのコサイン類似度の平均値は0.39，0.78である．

検出結果の類似度スコアの範囲は\todo{A~Bで，}平均値は0.08，中央値は0.09となった．

% 図\ref{fig:boxplot_cosine}に示すように，マイクロベンチマーク実装対における検出結果は，データセット中のリポジトリにおける検出結果と比べ，コサイン類似度が高い値で分布している.
% なお，マイクロベンチマーク実装対においては，Listing\ref{diff-loop}とListing\ref{MB_highcos}に示す通り，変数名などが同じ規則で抽象化され，コード長も同程度であることから，比較している低速コードと非常に類似するソースコード片となっている．

Listing\ref{ID3_highcos}に示すような類似度スコアの高いソースコード片は，比較したマイクロベンチマーク実装対における低速コードと，コード長および構造が類似している．使用している変数名については，短く単純な変数名が多く見られた．
一方，\todo{Listing\ref{ID3_lowcos}に示すような}類似度スコアが低いソースコード片では，様々な処理が含まれたコード長の大きいものや，変数名が長いソースコード片が多く見られた．コサイン類似度が小さいほど，検出したソースコード片の構造は比較する低速コードに対して複雑になっていく傾向があることを確認した．

これらの結果から，コサイン類似度は，コード長や変数名の影響を受けることが示唆されるとともに，ソースコードの構造に基づいて検索を行ったことで，コード長や変数名といった表面的な情報に影響を受けずに，低速コードパターンを含むコード片を検出できたことが示唆される．

%----------------------------------
\begin{lstlisting}[caption=リポジトリ中の高類似度検出例, label=ID3_highcos, captionpos=t, columns=flexible]
for (var key in this.defaults) {
  if (!options.hasOwnProperty(key)) {
    attr[key] = this.defaults[key];
  }
}
\end{lstlisting}
%----------------------------------


%----------------------------------
\begin{lstlisting}[caption=マイクロベンチマーク中の高類似度検出例, label=MB_highcos, captionpos=t, columns=flexible]
VAR_1 = {
  KEY_1: 5,
  KEY_2: 13,
  KEY_3: 8,
};
var VAR_2 = [];
for (var VAR_3 in VAR_1) {
  if (VAR_1.hasOwnProperty(VAR_3)) {
    VAR_2.push(VAR_1[VAR_3]);
  }
}
\end{lstlisting}
%----------------------------------

\section{CodeQLを用いた静的検出の有効性}
\todo{結果のまとめとしての節タイトルは再考の余地あり}

ケーススタディの結果から，本研究において，マイクロベンチマーク共有サービスで保存された実装対を用いて定義した6つの低速コードパターンは，実際のOSSプロジェクトにおいても存在する実装方法であることを確認した．加えて，低速コードパターンの検出数は，プログラムの規模の大きさに伴って増加することを確認した．
また，類似度評価に基づいて，検出したソースコード片を目視で確認したところ，元のマイクロベンチマーク実装対と類似度が低いソースコード片であっても，低速コードパターンを含んでいるものも検出したことを確認した．

以上から，ソフトウェアの進化に伴う規模の増大が性能低下を招く一因となる\cite{emprical_perfomancebug}中で，本手法における，マイクロベンチマーク実装対の構造的差分に着目した低速コードパターンの作成，および，CodeQLを用いた構造的な特徴を反映させた静的解析が，潜在的な高速化修正候補の検出において有効であることが示唆される．


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{考察}
\label{chap:consideration}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{類似度評価の解釈と限界}

\memo{ブロック単位だから規模の差が大きく出てるかもみたいな話をする}
提案手法による低速コードパターンの検出結果に対して，コサイン類似度による評価と目視調査の結果から，CodeQLにより検出されたコード片は，低速コードパターンを含んでおり，作成したクエリが構造的に妥当であることを確認した．
検出されたソースコードに対するコサイン類似度の値について，コサイン類似度は，コード間の構造的な類似度を計測できる一方で，低速コードパターンとは無関係である，コードの長さや変数名といった表層的な特徴の影響を受ける傾向があることを確認した．したがって，長さにばらつきがあり多様な変数名や処理を含む，リポジトリにおける検出結果に対するコサイン類似度の値は，マイクロベンチマーク実装対の値と比較して小さくなるため，検出結果が正しいと判断できる類似度の値域について今後検討する．

\todo{意味的に等価ではないものの話もする}

% なお，低速コードパターンの元となった低速コードとコサイン類似度の高いソースコード片は，比較するマイクロベンチマーク実装対におけるコードと長さが同等で，変数名も短く単純なものが多かった．したがって，検出されたソースコード片について，コサイン類似度の高いものは，マイクロベンチマーク実装対における実装方法と非常に類似しており，マイクロベンチマークを参照した修正が比較的容易に適用できる箇所である可能性を示している．したがって，検出結果に対するコサイン類似度を用いた評価は，マイクロベンチマークを用いた性能改善の容易性を示す指標として有用である可能性が示唆される．


\section{修正適用による実行速度変化から得られる示唆}

\todo{実験頑張りましょう}


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{妥当性の脅威}
\label{chap:threat}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{内的妥当性}

本研究では，低速コードの特徴抽出をGumTreeによる差分解析に依存している．したがって，抽出された差分が必ずしも低速コードの特徴を正確に表現していない可能性がある．本研究では，差分から得られた要素を目視により確認し，実装例と照合した上でパターンを作成しているため，その影響は小さいと考えられる．

本研究で利用したマイクロベンチマーク共有サービスであるJsPerfは2020年にサービスを終了しており，当時の高速実装が現在においても最適であるとは限らない．この点については，関連研究\cite{omori}においても同様の指摘がなされている．

本研究における類似度計測においては，プログラム断片のベクトル化にCode2Vecを利用している．Code2VecはJavaおよびC\#を対象としているため，それらの言語への利用における精度と差異が生じる可能性がある．本研究ではJavaScript対応かつマイクロベンチマークをもとに学習された学習モデル\cite{saiki}を使用することで，この影響を抑えるよう努めた．
なお，分散表現の取得における内部処理において，学習の設定に応じて，ソースコード片のトークン数や抽象構文木における構造における制限，分散表現化に利用する特徴のフィルタリングが発生するため，コード長の大きいソースコード片については，分散表現において，十分にその特徴を反映できていない可能性がある．変数名の抽象化や，学習モデルの再構築によって改善が期待されるものの，開発初期における性能ボトルネックの検出が本研究の目的であることから，本研究において，長大なコードへの対応に関する影響は小さいと考える．


\section{外的妥当性}

本研究におけるケーススタディでは，時間的制約のため，GitHub上のスター数上位のリポジトリに対象を限定して分析を行った．そのため，結果の一般性は限定的である可能性がある．
特にスター数の多いリポジトリは，既に十分に最適化・保守が行われていることが多いため，このようなリポジトリにおける検出結果は，一般的な開発段階のソフトウェアとは異なる可能性がある．

本研究では，低速コードパターンを6個作成し，ケーススタディを実施した．また，類似度計測ではそのうち1つのパターンについての検証となっている．異なるパターンに対しては，同様の手法で実験を行う必要があり，複数パターンに基づく評価によって，提案手法の汎用性および有効性をさらに検証することが今後の課題である．


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{おわりに}
\label{chap:finish}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\todo{今後の展望をしっかりと}
本研究では，ソフトウェア中に潜在する，修正によって実行速度の向上が期待されるソースコード片を検出することを目的とした．そこで，繰り返し処理にターゲットを絞り，マイクロベンチマーク共有サービスで提供されるベンチマーク実装対の構造的差分から低速コードパターンを抽出し，静的解析エンジンであるCodeQLを用いて実際のソースコード中から低速コードを検出する手法を提案した．

ケーススタディとして，6件の低速コードパターンおよび，それぞれに対応するCodeQLクエリを作成し，GitHub上のリポジトリ1,000件を対象に検出する実験を行った．その結果，提案手法によって作成した低速コードパターンが実際のソースコード中から検出された．したがって，マイクロベンチマーク共有サービス由来の構造的差分が，実際のプログラムにおける処理構造を適切に捉えていることを確認した．また，低速コードパターンの検出において，CodeQLによる静的検出が有効であることを確認した．

さらに，提案手法によって検出されたソースコード片に対して，Code2Vecを用いて分散表現を取得し，コサイン類似度による評価および目視調査を実施した．その結果，CodeQLによって検出されたコード片はいずれも低速コードパターンを含んでおり，作成したクエリが妥当であることを確認した．一方で，コサイン類似度は構文的な類似性に加え，コードの長さや変数名などの表層的な特徴に影響される傾向が見られた．

% なお，データセット中のリポジトリにおいて検出された，コサイン類似度の高いソースコード片は，マイクロベンチマークのソースコードとコード長や処理構造が類似し，表層的な特徴による影響が小さいことから，マイクロベンチマークを用いた性能改善の容易性を示す指標として有用である可能性が示唆された．

今後の課題として，繰り返し処理に限らず，低速コードパターン作成における差分抽出や低速コードの特徴抽出の手法，およびクエリ作成方法の拡張を進めることが挙げられる．また，検出結果に対して，コサイン類似度や，その他の評価指標の検討を通じて，より意味的な類似性を捉えられる指標の構築を目指す．
これらを元に．高速化修正の可否および，修正の効果，影響範囲の推定を行うことで，より効果的な性能ボトルネック検出および修正候補の提示手法の構築を目指す．


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 謝辞
%%
%% \begin{acknowledgements}
%% 感謝します．
%% \end{acknowledgements}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 参考文献
%%
\bibliographystyle{junsrt}
\bibliography{@Bachelor2025_Noguchi/reference}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 付録
%%
% \appendix
% 
% \chapter{サンプルプログラム}
% 
% プログラムリストや実行結果など，本論を補足する上で必要と思われるものが
% あれば付録として付ける．
% 
% {
% \footnotesize
% \begin{verbatim}
% #include <stdio.h>
% int main(void)
% {
%     printf("Hello, World!\n");
%     return 0;
% }
% \end{verbatim}
% }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
