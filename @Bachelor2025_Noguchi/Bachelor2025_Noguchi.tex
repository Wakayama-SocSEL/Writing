\documentclass[11pt]{jreport}
\usepackage{wuse_thesis}
\usepackage{indentfirst}
\usepackage{url}	% \url{}コマンド用．URLを表示する際に便利
\usepackage{xcolor}
\usepackage{listings}
\usepackage{amsmath,amssymb}
\usepackage{tabularx}
\usepackage{stfloats}
\usepackage{booktabs}
\usepackage{threeparttable}
\usepackage{caption}
\usepackage[dvipdfmx]{graphicx}
\usepackage{makecell}

%\usepackage{graphicx}  % ←graphicx.styを用いてEPSを取り込む場合有効にする
			% 他のパッケージ・スタイルを使う場合には適宜追加

% コメント用
\newcommand{\todo}[1]{\colorbox{yellow}{{\bf TODO}:}{\color{red} {\textbf{[#1]}}}}
\newcommand{\memo}[1]{\colorbox{magenta!30}{{\bf MEMO}:}{\color{red!50} {\textbf{[#1]}}}}
\newcommand{\ihara}[1]{\colorbox{green}{{\bf IHARA}:}{\color{blue} {\textbf{[#1]}}}}

\newcounter{patternID}

% コード例を載せるためのあれこれ
\definecolor{lightred}{RGB}{255,230,230}
\definecolor{lightgreen}{RGB}{230,255,230}

\lstset{
    basicstyle=\small\ttfamily,
    abovecaptionskip=0pt,
    captionpos=b,
    frame=tb,
    framexleftmargin=2em,
    numbers=left,
    numberstyle={\scriptsize},
    xleftmargin=\parindent,
    escapechar=|
}

%ListingのキャプションがFigureになってしまうのをListingに直すコマンド
\usepackage{caption}
\makeatletter
\let\MYcaption\@makecaption
\makeatother
\usepackage{caption}
\makeatletter
\let\@makecaption\MYcaption
\makeatother


% 言葉の定義
% プログラム：実行することも含有
% ソースコード：プログラムを構成する文字列
% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 主に表紙を作成するための情報
%%

%%  タイトル(修論の場合は英語表記も指定)
\title{マイクロベンチマークに基づく\\
    JavaScript言語の低速コードパターンの作成と\\
    静的検出}
%\etitle{Test\\Test\\Test}

%%  著者名(修論の場合は英語表記も指定)
\author{野口 隼杜}
%\eauthor{Akinori Ihara}

%% 卒業論文・修士論文(以下のどちらかを選択)
\bachelar	% 卒業論文(4年生用)

%%  学科・クラスタ
\department{システム工}

%%  学生番号
\studentid{60276185}

%%  卒業年度
\gyear{2025}

%%  論文提出日
\date{2026年2月10日}	% 修士の場合は月(2021年2月)までとし，英語表記も指定
%\edate{February 2021}	% 修士の場合，こちら(英語表記)も有効化

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

%%
%%  概要
%%
\begin{abstract}

ソフトウェアの性能効率性はシステム全体の品質に直結する重要な要素であるが，ソースコード中の性能低下箇所の同定および修正は，依然として開発者の経験に大きく依存している．プロファイラなどの動的解析ツールを用いた性能ボトルネック検出手法は，プログラムが実行可能な段階まで実装が進んだ後でなければ検証できず，実装途中の早期段階における性能改善を検証することは困難である．

本研究では，JavaScript プログラムを対象として，静的解析により実装途中のソースコードから潜在的な性能低下箇所を早期に検出することを目的とする．具体的には，マイクロベンチマーク共有サービスに蓄積された，実行速度が評価された機能的に等価な実装対に着目し，それらを抽象構文木へ変換した上で構造的差分を解析することにより，性能低下に寄与する共通のコード構造を抽出する．複数の低速な実装に共通して観測される構造的特徴を「低速コードパターン」とし，このパターンを静的解析エンジンである CodeQL による解析に利用することで，プログラムを実行することなく低速な実装箇所を検出する．

本研究では，特に繰り返し処理を含む実装対に焦点を当て，6種類の低速コードパターンを作成した．ケーススタディとして，GitHub 上の1,000件の JavaScript リポジトリを対象に検出実験を行った結果，実プロジェクトのソースコード中から低速コードパターンを含む実装箇所を検出可能であることを示した．さらに，マイクロベンチマークにおける低速コードと検出されたコード片に対して，Code2Vec を用いた分散表現に基づく類似度評価および目視調査を行った．その結果，提案手法はコードの構造的特徴に基づく低速実装箇所の検出に有効である一方，マイクロベンチマークにおいて実行速度が遅いと評価されたコード片と，意味的に等価な検出結果であるかの検証については課題が残ることを明らかにした．

\end{abstract}

%%  目次
\tableofcontents

%%  図目次 (図目次をいれたければ以下のコメントをはずす)
%\listoffigures

%%  表目次 (表目次をいれたければ以下のコメントをはずす)
%\listoftables

\newpage
\pagenumbering{arabic}	% 以降のページ番号を算用数字に

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%%  本文はここから
%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{はじめに}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

ソフトウェア開発において，ソフトウェアの性能効率性は，JIS X 25010:2013（ISO/IEC 25010:20\\23）にシステム/ソフトウェア製品品質を図る尺度の一つとして記述され\cite{JISX25010, ISO25010}，システム全体の品質や，ユーザ体験，運用コストに直結する重要な要素である\cite{performance1, performance2, negative}．このことから，開発者は，性能効率性の向上を目的に性能が低下する箇所の同定および修正を行う．
従来，こうした性能低下の要因を特定する手法としては，プロファイラなどを用いた動的解析が広く用いられる．しかし，プロファイラはプログラムが実行可能な状態でなければ適用ができず，開発の早期段階での適用が難しいという課題が存在する．
一般に，開発が進行するほど，修正による影響範囲の拡大や，他の品質とのトレードオフによって修正コストは増大する傾向にある\cite{local2system}．そのため，開発の早期段階において性能効率性を評価する手法が求められている\cite{assessment_JMbenchmark}．

ここで，開発の早期段階において，システムやアルゴリズムの修正といった規模の大きな最適化だけでなく，既存のコード片をより効率的な実装へ書き換え，部分的な性能効率性の向上を図る「部分的な最適化」が行われる\cite{jsRefac,JITProf, DrAsync}．
部分的な最適化を実践する手段の1つとして，マイクロベンチマークが利用される\cite{performance_aware}．
マイクロベンチマークは部分的なプログラムの性能を測定する性能テストである．ある特定の処理に対して，マイクロベンチマークの結果を比較することで，様々な実装方法に対する部分的な性能効率性を定量的に評価できる．
また，マイクロベンチマークを，開発者がWeb上で作成，実行，共有することができるオンラインサービスも存在する．
世界中の開発者が投稿した効率的な実装方法についての知見が蓄積されており，開発に利用されることもある\cite{saiki}．
しかし，サービス上のマイクロベンチマークの知見を実プロジェクトの性能改善に直接転用することは難しい．これは，サービス上のプログラムは，単純な処理を評価したものが多く，測定用の補助的なコードを含んでいるためである．したがって，サービス上の知見を利用するためには，低速である要因や，自身のソースコード中の適用箇所を認識する必要がある．

% 本研究は，マイクロベンチマークを共有するサービス上に存在する知見を利用し，修正することで実行速度の向上が期待されるコード片を静的に検出する手法を提案する
本研究は，マイクロベンチマークを共有するサービス上に存在する知見を利用することで，低速な要因を含み，性能向上の余地があるコード片を静的に検出する手法を提案する．
具体的には，共有サービスに蓄積された実行速度が評価された機能的に等価な実装対に着目し，抽象構文木における構造的差分を解析する．これにより，サービス上のソースコードの測定用の補助的なコードを除外し，低速である要因をコード構造から捉え，「低速コードパターン」として抽出する．このパターンを用いて，静的解析エンジンであるCodeQL\footnote{\url{https://codeql.github.com/}}\cite{ql}により，プログラムの実行を伴わずに大規模なソースコードから低速である実装箇所を特定する．提案手法は，動的解析に依存せずに性能向上の余地がある箇所を実装初期段階でも検出できる．

続く\ref{chap:background}章では，実行速度改善における課題と関連研究を示し，本研究の立ち位置を述べる． \ref{chap:pre-analysis}章で事前分析について示し， \ref{chap:approach}章で，提案手法，および結果の分析手法について述べる．\ref{chap:case-study}章でケーススタディの結果を述べ，\ref{chap:consideration}章で考察を行う．\ref{chap:threat}章で妥当性への脅威を示し，\ref{chap:finish}章でまとめる． 


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{プログラム実行速度の改善}
\label{chap:background}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

% -----------------------------------------
\section{ソフトウェアの性能効率性と部分的な最適化}
% -----------------------------------------

ソフトウェアにおける性能効率性は，ユーザー体験の向上，運用コストの削減，およびシステム全体の品質を左右する極めて重要な指標である．
一般に，システムの性能評価では，システムレベルの大規模なテストが行われ，プロファイラといった動的解析を用いてボトルネックを特定し，性能効率性の向上が図られる\cite{systemTest_large}．しかし，動的解析を伴う手法では実行環境の構築や実行時情報の測定および分析に多大なコストを要することが課題となっている\cite{systemTest_large, systemTest_workload}．加えて，システム構築後，あるいは統合後といった開発の後期工程で，問題が発覚した場合，その影響範囲の広さから対処は困難であり多くの労力を要する\cite{local2system}．
また，性能効率性を向上するためのソースコードの変更は，可読性や保守性といった他の品質を損なうリスク（性能改善と他品質のトレードオフ）も指摘されている\cite{negative}．
このような，システムレベルのテストに基づいた，計算機能力やシステム設計の改善，アルゴリズムの抜本的な変更のような大規模な最適化に対し，既存のコード片を，より効率的な実装へ置き換える「部分的な最適化」を積み重ねることによって性能効率性の向上を実現することも多い．
% \todo{↓書くなら参考文献欲しい}
% 特に，ループ処理やデータ構造操作のように実行回数が多い箇所では，わずかな実装差が全体の実行時間に影響を与えることがある．このようなミクロな性能差を把握し，適切に改善することは，現実的な性能改善戦略の一つである．実際に，

Webアプリケーション開発では，数行のソースコード修正によって最適化した結果，プログラムの実行時間が25\%から70\%高速化している\cite{jsRefac}．
また，ソースコード中の関数やメソッドなどの最小単位が正しく動作するかを検証するユニットテストを実行することや，ユニットテストをもとにしたベンチマークから，コンポーネント単位の微小な範囲において，ソースコードの変更前後のパフォーマンスの変化を評価することが可能となる\cite{test2benchmark, performanceRegression}


% -----------------------------------------
\section{マイクロベンチマーク共有サービス}
% -----------------------------------------

%----------------------
\begin{figure}[!h]
    \centering
    \includegraphics[width=0.6\linewidth]{./fig/jsPerf_example.pdf}
    \caption{マイクロベンチマーク共有サービスの投稿例\protect\footnotemark}
    \label{fig:jsPerf}
\end{figure}

\footnotetext{\url{https://jsperf.app/qiwudo}}
%----------------------

実装段階において，特定の処理に対する複数の実装方法の性能を定量的に比較する手法として，マイクロベンチマークが活用されている．マイクロベンチマークは，複数のコード片の実行時間をそれぞれ測定し，その効率性を相対的に評価するものである．

マイクロベンチマーク共有サービスは，マイクロベンチマークを開発者がWeb上で実行・共有するプラットフォームとして機能するオンラインサービスである．例として，JavaScript言語を対象としたJsPerf\footnote{JsPerf: \url{https://jsperf.app/}}やMeasureThat.net\footnote{MeasureThat.net: \url{https://measurethat.net/}}が挙げられる．これらのサービスは，ブラウザ上での実行環境を提供するとともに，世界中の開発者が投稿したコード片とその測定結果を公開している．

図\ref{fig:jsPerf}に，JsPerf上で実際に投稿されているマイクロベンチマークの例を示す．
マイクロベンチマーク共有サービスにおける各ベンチマークは，1つのセットアッププログラムと，1つ以上のテストプログラムから構成される．図上部に示すセットアッププログラムは，検証対象のソースコードで共通して利用される変数や関数の初期化などが行われる．一方，図下部に示すテストプログラムでは，同一の機能を異なる方法で実装したコード片が複数記述され，それぞれの実行速度の計測，および比較ができる．
このようなマイクロベンチマークは，データ構造や制御構文の選択，メソッド呼び出しの方法などに多様性が見られ，実行速度の差とその要因となる実装方法を捉えることができる．

実際の開発現場においても，GitHub上のプルリクエスト等において，提案する改善案の正当性を示すエビデンスとしてこれら共有サービスのURLが引用される事例が確認されており\cite{saiki},マイクロベンチマーク共有サービスは効率的な実装パターンを示すデータベースとして機能していることが示唆される．

% 本研究では，このようなマイクロベンチマーク共有サービス上の実装対を，性能効率性，特に実行速度に影響を与える構造的特徴を分析および抽出するために利用する．


% -----------------------------------------
\section{低速箇所の検出における課題}
% -----------------------------------------

既存のソースコードにおいて性能向上の余地がある，低速な箇所の特定において，従来の性能評価手法の課題と，その解決策として期待されるマイクロベンチマーク共有サービスを利用する上での特有の課題を述べる．

従来の性能評価手法における主要な課題は，その多くがプログラムの動的実行に依存している点である．プロファイラやマイクロベンチマークを用いた手法は，実際の動作状況や実行時間を計測することでボトルネックを特定する．そのため，解析対象となるソースコードがコンパイル可能であり，かつ実行に必要な依存ライブラリやテストデータが整備された実行可能状態にあることが前提となる．
しかし，開発の初期段階やリファクタリングの検討段階において，断片的なソースコードに対して即座に実行環境を構築することは容易ではない．また，実装が進むにつれて性能改善のためのソースコードの変更は複雑化する\cite{complicate}．したがって，動的解析を利用する従来の手法では，実装の最中にリアルタイムで低速な記述を検出し，開発を支援することが困難であるという課題がある．

これに対し，マイクロベンチマーク共有サービスを活用するアプローチは，自身のプログラムが実装途中で，実行できる段階に至っていなくとも，事前に第三者によって実行速度が評価された実装方法を利用できるため，自身のプログラムに対する動的実行への依存を排除，あるいは最小化できる可能性がある．
しかし，同サービスに保存されたマイクロベンチマークを開発中のプログラムに適用するには，サービス特有の性質に起因する課題が存在する．共有サービス上のコード片は，不特定の開発者が特定の文脈で局所的な比較を目的に作成したものである．そのため，単純な処理の比較であっても
% 特定の実行環境や入力データに対してのみ有意な差が生じる「コンテキストへの依存」や，
測定用の補助的な変数宣言や処理など，実行速度の差を生み出す要因とは無関係な記述が混在している．

マイクロベンチマークという極めて小さなコード片において，実行速度の差を生み出す要因を認識し，自身のソースコードから，マイクロベンチマーク共有サービスにおける低速な実装方法を採用している箇所を特定し，改善案を適用することは容易ではない．したがって，膨大な公開データから汎用的な「低速な要因」を抽出・検出するためには，ソースコードの構造的・意味的な特徴を捉え，コード片から実行速度の差を生み出す要因を識別する解析手法が必要となる．


% -----------------------------------------
\section{関連研究}
% -----------------------------------------

\subsection{実行速度向上を目的としたリファクタリングの調査}

Selakovicら\cite{jsRefac}は，JavaScriptを利用しているプロジェクトにおいて，開発者が高速化のために行ったリファクタリングを調査している．調査の結果，開発者は10行程度の小さい範囲の修正によって高速化への対処を行なっていることを明らかにした．この結果から，マイクロベンチマークで評価される短いコード片を利用した修正が，ソフトウェア高速化につながっていることを示唆していると考えられる，また，\cite{jsRefac}では，JavaScriptプロジェクトの解析によって10件の頻出する高速化修正パターンを作成している．この改良パターンを用いた自動修正は一定の高速化の効果を示しているが，該当箇所の同定における条件などから，広範な適用には至っていない．

\subsection{静的解析と動的解析を用いた性能アンチパターンの検出}

Turcotte ら\cite{DrAsync}は，JavaScript 言語における非同期処理に注目し，ソースコードの目視調査やStack Overflow上の知見から，より効率的かつ簡潔な記述方法が存在する実装方法を性能アンチパターンとして定義し，静的解析エンジンであるCodeQL\cite{ql}と動的解析による実行頻度や呼び出し関係の監視を組み合わせて，修正可能な性能アンチパターンの検出手法を提案した．

非同期処理という特定のドメインに対する手動定義されたパターンに限定しているものの，静的解析による広範な実装形態への適用を実現している．本研究では，マイクロベンチマーク共有サービスに保存された実装対から，自動的にパターンを抽出・生成することを目指す．これにより，静的検出アプローチを継承・発展させつつ，より汎用的な性能改善支援を提供する．

% -----------------------------------------
\section{本研究の位置付け}
% -----------------------------------------

本研究では，別の方法で実装することで性能向上の余地がある箇所を，開発の早期段階で静的に検出する手法を確立することを目的とし，マイクロベンチマーク共有サービスにおいて実行速度が評価された実装対に着目し，それぞれの抽象構文木間における構造的な差分をもとに，静的な解析に利用できる汎用的な「低速コードパターン」を作成し，その検出を行う手法を提案する．
マイクロベンチマーク共有サービスで示される実装方法と動的解析の結果（実行速度の差異）から，静的なパターンへと変換することで，サービス上で示される実装方法の低速要因をコード構造として抽出する．この，コード構造として抽出したパターンを利用し，実装途中のプログラム中から，静的解析のみで性能向上の余地がある箇所を検出する．


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{事前分析：マイクロベンチマークにおける低速コードの特徴}
\label{chap:pre-analysis}
%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{概要}
\label{preanalysis_abst}

本章では，本研究における検出対象を絞り込むことを目的とした，マイクロベンチマーク実装対の傾向分析について述べる．目視により，分析対象としたマイクロベンチマーク共有サービスにおける実装対は，実装対の両方もしくは片方に繰り返し処理を含むことを確認した．実装対全てを個別に扱うことは困難であることから，繰り返し処理が多くの実装対で利用されていることを踏まえ，繰り返し構文の有無を中心に構文解析を行った．結果として，データセットに含まれる実装対の約4割に繰り返し処理が含まれており，それらに共通する典型的なパターンが存在することを確認した．この結果に基づき，本研究では繰り返し処理に焦点を当てて検出手法を構築する．


\section{データセット}

本研究では，大森ら\cite{omori}が作成したマイクロベンチマーク共有サービスに関するデータセットを分析対象とする．当該データセットは，JavaScript言語を対象としたマイクロベンチマーク共有サービスJsPerfにおいて公開されているマイクロベンチマークのうち，比較されている実装方法の実行時間に統計的な有意差が見られ，さらに外的振る舞いが等しいことが検証された29,809件の実装対である．以降，分析対象とする，マイクロベンチマークで比較されたコード片の対をマイクロベンチマーク実装対，各実装対において，実行速度が遅いコードを低速コード，実行時間が速いコードを高速コードと呼ぶ．


\section{抽象構文木に基づく実装方法の分析}

検出対象とする，低速コードの特徴を明確化するため，まずマイクロベンチマーク実装対に対し，目視調査を行った．その結果，実装対の両方もしくは片方に繰り返し処理を含むものが多く存在することを確認した．このような観察結果に基づき，本研究ではマイクロベンチマーク実装対に対して繰り返し処理に着目した特徴分析を行う．対象とする繰り返し処理は，JavaScriptにおける \texttt{for}，\texttt{for-of}，\texttt{for-in}，\texttt{while}，および \texttt{do-while}とする．マイクロベンチマーク実装対のソースコードを抽象構文木に変換し，各ソースコードに含まれる繰り返し処理に関する構文要素の有無を検証した．その結果，11,893件の実装対 (全実装対の39.9\%) において，繰り返し処理に関連する構文が含まれていることがわかった．次に，繰り返し処理を含むマイクロベンチマーク実装対11,893件について，実装対を構成する2つのソースコード間の抽象構文木における構造的な差分を抽出し，差分と元の実装対の特徴について目視で確認を行った．
次節において，繰り返し処理に関するマイクロベンチマーク実装対のもつ特徴について具体例を示す．


\section{繰り返し処理を含む低速コードの主要パターン}

%----------------------------------
\begin{lstlisting}[caption=繰り返し処理自体の実装方法が異なる実装対, label=diff-loop, captionpos=t, columns=flexible]
// slow
for (key in VAR_1) {
    if (!VAR_1.hasOwnProperty(key)) continue;
    VAR_2 = VAR_1[key];
}

// fast
for (var VAR_8 = 0; VAR_8 < VAR_1.length; ++VAR_8) {
    VAR_2 = VAR_1[VAR_8];
}
\end{lstlisting}
%----------------------------------
%----------------------------------
\begin{lstlisting}[caption=繰り返し内部で実行する処理の記述方法が異なる実装対, label=diff-inloop, captionpos=t, columns=flexible]
// slow
for (var VAR_2 = 0; VAR_2 < 5000; VAR_2++)
    VAR_1 = VAR_1.concat([\"1\", \"2\"]);

// fast
for (var VAR_2=0; VAR_2<5000; VAR_2++)
    VAR_1.push(\"1\", \"2\");
\end{lstlisting}
%----------------------------------
%----------------------------------
\begin{lstlisting}[caption=メソッド処理と代替する繰り返し処理に関する実装対, label=diff-method, captionpos=t, columns=flexible]
// slow
var VAR_5 = new Set(VAR_2);
VAR_5.forEach(VAR_6 => {});

// fast
for (let VAR_7 of VAR_2) {}
\end{lstlisting}
%----------------------------------

マイクロベンチマーク実装対において確認した，実行速度に差が生じる繰り返し処理の使用パターンとその特徴について，具体例として，Listing~\ref{diff-loop}，Listing~\ref{diff-inloop}，Listing~\ref{diff-method}に示す．

Listing~\ref{diff-loop}は，それぞれ\texttt{for-in}文を用いて配列に含まれる要素にアクセスする実装と，同様の処理を\texttt{for}文で実装したコード片である．ここで示すパターンは，実行時間の差が，繰り返し処理を行う構文そのものが異なることに起因する実装対である．


Listing~\ref{diff-inloop}は，それぞれ\texttt{for}文内で \texttt{concat}メソッド，\texttt{push}メソッドを用いている実装対である．これは，同一の繰り返し処理を行う構文において，その繰り返し内部で実行する処理の記述方法が異なることによって実行速度の差が生じている実装対である．


Listing~\ref{diff-method}は，繰り返し処理を\texttt{forEach}メソッドで実装したコード片と\texttt{for-of}文で実装したコード片である．これは，メソッドによる処理とそれに代替する繰り返し処理について比較した実装対であり，メソッド呼び出しのオーバーヘッドや内部的な最適化の有無により実行速度の差が生じていることが示唆される実装対である．


これらの結果から，マイクロベンチマーク実装対において，抽象構文木の構造的差分の中に，性能低下の要因となる特徴的なノード構成が含まれているとともに，繰り返し処理および繰り返す処理の記述内容の違いが性能差の要因の1つとして存在することを確認した．
この事前分析の結果に基づき，本研究では，繰り返し処理に焦点を当て，マイクロベンチマーク実装対の構造的差分を解析することで低速コードの特徴を抽出し，次章以降で述べる低速コードパターンの作成および静的検出に利用する．


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{構造的差分に基づく低速コードパターンの検出手法}
\label{chap:approach}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{概要}
\label{sec:approach_abst}

本章では，マイクロベンチマーク実装対を用いた低速コードパターンの作成，CodeQLを用いた静的検出，および検出結果の妥当性を検証するための分析手法について述べる．


本研究では，まず，マイクロベンチマーク実装対に対し，差分解析を用いて低速コードの特徴を抽出し，パターンを作成する．
次に，静的解析によって，ソースコード中からパターンに合致するコード片を網羅的に検出する．
最後に，検出されたコード片が実際に低速要因を含んでいるかを判断するため，分散表現を用いた類似度に基づいた目視調査による検証を行う．


\section{差分解析による低速コードパターンの作成}
\label{approach_extract}

%----------------------
\begin{figure}[ht]
    \centering
    \includegraphics[width=0.85\linewidth]{./fig/create_pattern.pdf}
    \caption{低速コードパターン作成手順の概略図}
    \label{fig:create_pattern}
\end{figure}
%----------------------

%----------------------------------
\begin{lstlisting}[caption=Characteristic Candidates for Slow Code, label=candidates, captionpos=t, columns=flexible, literate=
    {for}{{\textcolor{black}{\colorbox{lightred}{for}}}}{3}
    {key}{{\textcolor{black}{\colorbox{lightred}{key}}}}{3}
    {in }{{\textcolor{black}{\colorbox{lightred}{in}}\kern0.5em}}{3}
    {VAR\_1}{{\textcolor{black}{\colorbox{lightred}{VAR\_1}}}}{5}
    {if}{{\textcolor{black}{\colorbox{lightred}{if}}}}{2}
    {!}{{\textcolor{black}{\colorbox{lightred}{!}}}}{1}
    {hasOwnProperty}{{\textcolor{black}{\colorbox{lightred}{hasOwnProperty}}}}{15}
    {continue}{{\textcolor{black}{\colorbox{lightred}{continue}}}}{8}
    {VAR\_1\_}{{\textcolor{black}{VAR\_1}}}{6}
]
for (key in VAR_1) {
  if(! VAR_1.hasOwnProperty(key))continue;
  VAR_2 = VAR_1_[key];
}
\end{lstlisting}
%----------------------------------

図\ref{fig:create_pattern}に，低速コードパターン作成手順の概略図を示す．本研究では，各マイクロベンチマーク実装対において差分解析を行うことで，対となる高速コードに含まれない，低速コード特有の処理や構造を示す要素を低速コードの特徴として抽出する．
なお，差分解析には，GumTree\cite{gumtree}を使用する．
GumTreeは，ソースコードの抽象構文木を基にした差分解析ツールであり，変更前後のソースファイルまたは抽象構文木を受け取ると，抽象構文木におけるノード単位の編集操作とその差分要素を出力する．検出できる編集操作は，「削除」，「挿入」，「移動」，「更新」である．

本手法では，収集したマイクロベンチマーク実装対において，低速コードから高速コードへの変更を想定し，GumTreeを利用して，編集操作とその差分要素を収集する．次に，収集した要素のうち，低速コードから削除または更新された要素を抽出する．これらの要素を，低速コード特有の処理や構造を示す低速コードの特徴候補として収集する．

例として，Listing \ref{diff-loop} に示す低速コードと高速コードの実装対において，この処理を実施した結果をListing~\ref{candidates}に示す．この処理によって，Listing~\ref{candidates}における背景色のついた要素が低速コードの特徴候補として収集できる．

次に，収集した低速コードの特徴候補の中から，プログラムの振る舞いに意味的な影響を与える要素として，繰り返し処理，メソッド呼び出し，配列・オブジェクト操作を示す要素を自動抽出し，統合する．

これらの操作によって，Listing \ref{diff-loop}に示す実装対から，\texttt{for-in}文と\texttt{hasOwnProperty}チェックの組み合わせがパターンとして抽出される．



\section{CodeQLによる低速コードパターンの静的検出}
\label{approach_codeQL}

本研究では，静的解析エンジンであるCodeQL\cite{ql, codeql}を用いて，\ref{approach_extract}節における手法で作成した低速コードパターンの検出を行う．

CodeQLは，GitHub社が開発したコード解析プラットフォームであり，プログラムの構造的・意味的な探索を可能にするツールである．
CodeQLでは，ソースコードを解析し，抽象構文木，制御フロー，およびデータフローの情報を含むリレーショナルデータベースを構築する．これに対し，論理プログラミング言語であるQL言語を用いてクエリを記述することで，このデータベースから特定のパターンに合致するコード片を検索できる．
なお，抽象構文木に基づく構造情報をもとに作成した低速コードパターンの検出において，構造情報を参照して静的動作する点でCodeQLを採用した．

本手法では，\ref{approach_extract}節で抽出したパターンの構造的特徴をCodeQL用のクエリ言語（QL）に変換する．このクエリを対象となるプログラムのデータベースに対して実行することで，プログラムを実行することなく，低速な実装パターンを含むコード片をブロック単位で特定する．


\section{類似度に基づく検出結果の評価方法}
\label{approach_evaluation}

\subsection{妥当な検出結果の判定方針}

提案手法によって実際のプログラムから検出されたコード片が，低速コードパターンを実際に含んでいるか，つまり，検出結果が妥当であるかを判定する必要がある．ここで，本研究における正しい検出結果は，低速コードパターンを含む，マイクロベンチマーク共有サービスにおいて実行速度が評価された実装方法を採用している箇所である．
しかし，検出対象のプログラムにおいて，性能低下箇所があらかじめ特定されているわけではなく，また，検出数が膨大になる場合，全ての検出結果に対して目視による分析を行うことは現実的ではない．したがって，適合率や再現率といった指標で評価を行うことは困難である．

そのため，本研究では，パターンの元となった低速コードと，実際の検出結果との類似度を指標として用いる．
検出結果を類似度を用いて定量的に順位付けし，高類似度および低類似度の結果を重点的に分析することで，検出の妥当性および本手法の特性を明らかにする．


\subsection{コード片の分散表現化}

低速コードと検出したコード片の類似度を定量的に評価するため，コード片を多次元のベクトルとして表現する分散表現を用いる．
本手法では，ソースコードの抽象構文木からパスを抽出し，構造的な特徴を考慮してベクトル化が可能なCode2Vec\cite{code2vec}を採用した．具体的には，Saiki\cite{saiki}らによってJavaScript用に構築された学習済みモデルを利用し，コード片を分散表現へ変換する


\subsection{コサイン類似度による検出結果の順位づけ}
\label{subsec:sort_cosine}

次に，ある一つの検出コード片に対して取得した分散表現に対し，パターンの抽出元となった個々の低速コードとの間で類似度を算出する．ここでは，コード間の意味的な類似度を計測することを目的に，ベクトル間の類似度の測定方法から，コサイン類似度を利用する．

なお，コサイン類似度は，2つのコード片$A,B$のコードベクトルを$\overrightarrow{a},\overrightarrow{b}$とした時，内積の定義から次のように計算される．

\begin{displaymath}
	cos(\overrightarrow{a}, \overrightarrow{b}) = \frac{\overrightarrow{a} \cdot \overrightarrow{b}}{|\overrightarrow{a}||\overrightarrow{b}|}
	= \frac{\sum_{i=1}^d \overrightarrow{a}_{i} \overrightarrow{b}_{i}}{\sqrt{\sum_{i=1}^d (\overrightarrow{a}_{i})^2} \cdot \sqrt{\sum_{i=1}^d (\overrightarrow{b}_{i})^2}}
\end{displaymath}

コード片$A,B$が意味的に類似している場合，2つのベクトル$\overrightarrow{a},\overrightarrow{b}$は間の角度が0に近づき，その結果$cos(\overrightarrow{a}, \overrightarrow{b})$が1に近づく．この$cos(\overrightarrow{a}, \overrightarrow{b})$がコサイン類似度であり，ベクトル間の類似度を$[-1,1]$の範囲で測定できる．

ある一つの検出コード片と，パターンの元となった全ての低速コードに対するコサイン類似度を算出した後，それらの平均値を当該検出コード片の類似度スコアとする．この処理を全ての検出結果に対して実施し，スコアの降順で並び替えることで，元の低速コードに近い特徴を持つ順に結果を並べる．
高類似度の検出結果，および低類似度の検出結果について，目視調査を行い，検出結果の妥当性および本手法の特性を評価する．



%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{ケーススタディ}
\label{chap:case-study}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{概要}

本章では，\ref{chap:approach}章で提案した手法の有効性を検証するため，作成した低速コードパターンを示した上で，2つの実験を行った結果について述べる．まず，収集元のマイクロベンチマーク実装対のデータセットを対象に検出実験を行い，クエリの妥当性と検出コード片の構造的類似性を検証する．次に，GitHub上のOSSリポジトリを対象に検出実験を行い，実開発における低速コードパターンの混入状況を調査するとともに，検出されたコード片の類似度評価および目視による評価を行う．


\section{低速コードパターンの作成}

%----------------------¬
\begin{table}[!h]
    \centering
    \caption{低速コードパターン}
    \label{tab:slow_code_patterns}
    \setcounter{patternID}{0} % 表が始まる前にカウンタを0にリセット
    \begin{threeparttable}
        \begin{tabular}{cllr}
            \toprule
            \textbf{ID} & \textbf{パターン名} & \textbf{構造例} & \textbf{元低速コード数} \\
            \midrule
            
            \refstepcounter{patternID}\label{ptn:for-in}
            \thepatternID & 
            \texttt{for-in} & 
            \texttt{for (k in o) \{...\}} & 
            534 \\
            
            \refstepcounter{patternID}\label{ptn:forEach}
            \thepatternID &
            \texttt{forEach()} &
            \texttt{arr.forEach(item => \{...\});} &
            194 \\
            
            \refstepcounter{patternID}\label{ptn:hasOwnProperty}
            \thepatternID &
            \makecell[l]{%
              \texttt{for-in\_}\\
              \texttt{  if\_hasOwnProperty()}
            } &
            \makecell[l]{%
                \texttt{for (k in o) \{ }\\
                \texttt{  if (o.hasOwnProperty(k))\}} 
            } &
            102 \\

            \refstepcounter{patternID}\label{ptn:applymap}
            \thepatternID &
            \texttt{apply()}\textbf{\_}\texttt{map()} &
            \texttt{Array.apply(null, arr).map(...)} &
            12 \\
            
            \refstepcounter{patternID}\label{ptn:json}
            \thepatternID &
            \texttt{parse(stringify())} &
            \texttt{JSON.parse(JSON.stringify(obj))} &
            11 \\
            
            \refstepcounter{patternID}\label{ptn:push}
            \thepatternID &
            \texttt{for-of}\textbf{\_}\texttt{push()} &
            \texttt{for (i of o) \{res.push(i);\}} &
            8\\
                
            \bottomrule
        \end{tabular}
    \end{threeparttable}
\end{table}
%----------------------

本研究では，\ref{chap:pre-analysis}章における事前分析に基づき，繰り返し処理を含む11,893件のマイクロベンチマーク実装対を，パターン作成におけるデータセットとして利用する．
このマイクロベンチマーク実装対のデータセットに対し，\ref{chap:approach}章に示す差分解析および特徴抽出を行い，最終的に6種類の低速コードパターンを作成した．これらは，マイクロベンチマーク実装対において，低速コードから高速な実装コードへの変更差分として抽出された特徴候補に対し，目視による精査を経て作成したものである．なお，異なる実装対から同一の特徴が抽出される場合は1つのパターンとして集約した．

作成した6つのパターンと，それぞれの特徴，および抽出元となったマイクロベンチマーク実装対の数を表\ref{tab:slow_code_patterns}に示す．
表中の「構造例」は，CodeQLクエリによって検出対象となる低速コードの構造を示している．
また，「元低速コード数」は，そのパターンに集約された低速コードの総数（各低速コードパターンを持つ低速コードの数）を示している．
ID\ref{ptn:for-in}の「\texttt{for-in}」やID\ref{ptn:forEach}の「\texttt{.forEach()}」のように，一般的に利用頻度の高い構文が低速要因として抽出されている一方で，ID\ref{ptn:hasOwnProperty}のような特定のメソッド呼び出しを含む複合的な構造も抽出された．本実験では，これらのパターンに対応するCodeQLクエリを作成し，検出に利用する．


\section{低速コードパターンからCodeQLクエリへの変換}

%----------------------------------
\begin{lstlisting}[caption=ID\ref{ptn:hasOwnProperty}に対応するQLクエリ, label=query:ID3, captionpos=t, columns=flexible, escapechar=\@]
predicate forInWithIfhasOwnProperty(ForInStmt f) {
  exists(IfStmt ifStmt |
    // if 文が for-in 文の配下に含まれる
    f.getBody().getAChild*() = ifStmt and    
      // if 条件式内に hasOwnProperty 呼び出しが存在
      exists(CallExpr c |
        c = ifStmt.getCondition().getAChild*() and
        c.getCallee().(PropAccess).getPropertyName() = "hasOwnProperty"
      )
  )
}
\end{lstlisting}
%----------------------------------

表\ref{tab:slow_code_patterns}に示す低速コードパターンをCodeQLで検出可能な形式に変換するため，各パターンに対するQLクエリを手作業で作成する．例として，低速コードパターンID\ref{ptn:hasOwnProperty}に対応するQLクエリをListing \ref{query:ID3}に示す．
本研究では，6つの低速コードパターンから作成したクエリを，対象プロジェクトのCodeQLデータベースに対して実行することで，低速な実装方法が用いられている箇所を検出する．



\section{マイクロベンチマーク実装対データセットにおける検証}
\label{sec:toMB}

%----------------------
\begin{table}[ht]
    \centering
    \caption{マイクロベンチマーク実装対データセットに対する検出結果}
    \label{tab:result_detectToMB}
    \begin{tabular}{crrrr}
        \toprule
        \textbf{ID} & \textbf{元低速コード数} & \textbf{検出数} & \textbf{再現率} & \textbf{適合率} \\
        \midrule           
        \ref{ptn:for-in} & 534 & 1000 & 1.0 & 0.53 \\
        \ref{ptn:forEach} & 194 & 346 & 1.0 & 0.56 \\
        \ref{ptn:hasOwnProperty} & 102 & 195 & 1.0 & 0.52 \\
        \ref{ptn:applymap} & 12 & 89 & 1.0 & 0.14 \\
        \ref{ptn:json} & 11 & 18 & 1.0 & 0.61 \\
        \ref{ptn:push} & 8 & 38 & 1.0 & 0.21 \\
        \bottomrule
    \end{tabular}
\end{table}
%----------------------

作成した低速コードパターンおよびCodeQLクエリが，意図した構造を正しく検出できるかを検証するため，抽出元であるマイクロベンチマークデータセット（低速コード全11,889件）に対して検出実験を行った．


\subsection{検出精度と妥当性}
各パターンに対する検出実験の結果として，次に示す定義に基づき再現率および適合率を算出する．

\subsubsection{再現率（Recall）}
パターンの抽出元となった低速コードのうち，検出された割合．
$$\text{再現率} = \frac{\text{検出結果に含まれる元低速コード数}}{\text{元低速コード数}}$$

\subsubsection{適合率（Precision）}
クエリによって検出された全コード片のうち，パターンの抽出元となった実装対における低速コードが占める割合．
$$\text{適合率} = \frac{\text{検出結果に含まれる元低速コードの数}}{\text{総検出数}}$$


検出実験の結果を表\ref{tab:result_detectToMB}に示す．全ての低速コードパターンにおける検出結果に，パターンを抽出した元の実装対における低速コードが含まれており，再現率は全て $1.0$ となった．結果として作成したクエリが意図した低速コードパターンを検出できることを確認した．
一方で，適合率はパターンの種類により $0.14$ から $0.61$ の範囲となり，「元低速コード」以外が多く検出された．この要因を明らかにするため，次節において具体的な検出コード片について類似度の算出および目視調査を行う．


\subsection{検出コード片の類似度評価}
\label{susec:toMB_cosine}

%----------------------
\begin{figure}[ht]
    \centering
    \includegraphics[width=1.0\linewidth]{./fig/MB_cosine_box.png}
    \caption{マイクロベンチマーク実装対データセットに対する検出結果における類似度スコア}
    \label{fig:plot_mb_cosine}
\end{figure}
%----------------------
%----------------------------------
\begin{lstlisting}[caption={マイクロベンチマークにおける「偽陽性」と判定された検出例}, label=lst:fp_example, captionpos=t, columns=flexible]
//  (a) 検出されたコード（低速実装） 
VAR_3 = Array.apply(null, Array(VAR_1)).map(Number.prototype.valueOf, VAR_2);

//  (b) 対となる高速コード
var VAR_4 = [], VAR_5 = 0;
while (VAR_5 < VAR_1) VAR_4[VAR_5++] = VAR_2;
\end{lstlisting}
%----------------------------------

\ref{subsec:sort_cosine}説に基づき，検出されたコード片と元低速コードにおいて類似度スコアを算出した．
図\ref{fig:plot_mb_cosine}は，マイクロベンチマーク実装対データセットからの検出結果における類似度スコアの分布を示す．図中の白い箱ひげ図が検出したコードの類似度スコアの分布を示し，赤い箱ひげ図がパターンの元となった低速コードの類似度スコアの分布を示す．

図\ref{fig:plot_mb_cosine}に示すように，検出コード片と比較して，正解データである元低速コードの類似度スコアが高い値で分布していた．
ここで，適合率を低下させる要因となった「元低速コード以外の検出コード片（偽陽性）」に着目し，検出コード片とマイクロベンチマーク実装対において対になる高速コードについて，目視による確認を行った．
その結果，計算上は偽陽性と判定されたコード片は，実際にはクエリが意図する低速コードパターンと同一の構文構造を持っていることを確認した．
具体例として，低速コードパターンID\ref{ptn:applymap}（\texttt{apply()}\textbf{\_} \texttt{map()}）における検出事例を Listing \ref{lst:fp_example} に示す．Listing \ref{lst:fp_example} (a) は，本手法により検出されたコード片を示し，Listing \ref{lst:fp_example} (b) はマイクロベンチマーク実装対データセットにおいて検出コード片の対となる高速コードを示す．

Listing \ref{lst:fp_example} (a) は，低速コードパターンID\ref{ptn:applymap}の検出要件である apply メソッドおよび map メソッドの呼び出しを含んでおり，かつ Listing \ref{lst:fp_example} (b) のように while 文への置換による高速化が可能であることがわかる．
このように，低速コードパターンで示す構文構造を持っているにもかかわらず，偽陽性として扱われた要因として，パターン作成手法の設計における次の2点が考えられる．

まず，本手法における元低速コード（正解データ）の定義が「差分」に基づいている点である．マイクロベンチマーク実装対では，差分として現れない（変更されなかった）箇所にも同一の構文が含まれているケースが存在する．本実験のクエリはこれらを検出したことで，低速コードパターンが示す構文構造をもつものの「偽陽性」と判定されたことが考えられる．

次に，データセット構築時の特徴抽出において，今回作成した6パターン以外の形式で特徴が抽出されていた場合がある点である．本手法の特徴抽出では，差分解析によって得られた変更要素から，機械的に構文要素を抽出する．そのため，別の構文要素が主要な特徴として抽出・分類される場合がある．
Listing \ref{lst:fp_example}の事例においては，\texttt{map}メソッドの引数として \texttt{Number.prototype.valueOf}が含まれている．これによって，特徴抽出の過程で \texttt{apply} や \texttt{map} に加えて，\texttt{valueOf} メソッドの呼び出しを含む別の特徴パターンとして分類されることで，低速コードパターンID\ref{ptn:applymap}に対する元低速コードとはならなかった．

以上から，マイクロベンチマーク実装対データセットに対する検出実験においては，低い適合率はクエリの誤検出によるものではなく，パターン作成手法の設計における，元低速コード（正解データ）の定義および特徴抽出の特性に起因するものであると考えられる．
したがって，CodeQLによる構造的検出自体は，差分の有無や抽出された特徴の形式に関わらず，低速コードパターンを網羅的に検出できることが示唆される．



%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{OSSリポジトリへの適用}
\label{sec:toOSS}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

次に，提案手法の実用性を評価するため，GitHub上のOSSリポジトリを対象に低速コードパターンの検出実験を行った．実験対象として，JavaScriptを主要言語とし，かつ最終コミットが1年以内であるスター数上位1,000件のリポジトリより，2025年10月13日時点における最新スナップショットを用いた．

\subsection{検出結果}

%----------------------
\begin{table}[ht]
    \centering
    \caption{低速コードパターンによる検出結果}
    \label{tab:result_detect}
    \begin{tabular}{crrr}
        \toprule
        \textbf{ID} & \textbf{検出リポジトリ数} & \textbf{最大検出数 (件)} & \textbf{総検出数 (件)} \\
        \midrule           
        \ref{ptn:for-in} & 692 & 9,912 & 101,212 \\
        \ref{ptn:forEach} & 844 & 12,676 & 174,047 \\
        \ref{ptn:hasOwnProperty} & 308 & 1,125 & 9,516 \\
        \ref{ptn:applymap} & 49 & 12 & 139 \\
        \ref{ptn:json} & 284 & 142 & 2,823 \\
        \ref{ptn:push} & 480 & 3,351 & 32,812 \\
        \bottomrule
    \end{tabular}
\end{table}
%----------------------

表\ref{tab:result_detect}に，各低速コードパターンごとの検出結果を示す．なお，「ID」は低速コードパターンのID，「検出リポジトリ数」は1つ以上のコード片が検出されたリポジトリの数，「最大検出数」は単一リポジトリにおける最大検出数，「総検出数」は，1,000リポジトリにおける総検出数を示す．

表\ref{tab:result_detect}から，パターンによって検出数に差があるものの，$49$リポジトリから$844$リポジトリで検出結果を得た．低速コードパターンID\ref{ptn:for-in}の「\texttt{for-in}」やID\ref{ptn:forEach}の「\texttt{.forEach()}」のような，一般的に利用頻度の高い構文を示すパターンは，検出数が多く，低速コードパターンID\ref{ptn:applymap}の「\texttt{apply()} \textbf{\_} \texttt{map()}や，ID\ref{ptn:json}の「\texttt{parse(stringify())}」のような，メソッドが複合したパターンでは検索数が少ない結果となった．

%----------------------
\begin{figure}[p]
\centering
\begin{minipage}[b]{0.49\columnwidth}
    \centering
    \includegraphics[width=0.9\linewidth]{./fig/plot_Repo/plot_id1.pdf}
    \caption{低速コードパターンID1による検出数とリポジトリ規模}
    \label{fig:plot_id1}
\end{minipage}
\begin{minipage}[b]{0.49\columnwidth}
    \centering
    \includegraphics[width=0.9\linewidth]{./fig/plot_Repo/plot_id2.pdf}
    \caption{低速コードパターンID2による検出数とリポジトリ規模}
    \label{fig:plot_id2}
\end{minipage}

\centering
\begin{minipage}[b]{0.49\columnwidth}
    \centering
    \includegraphics[width=0.8\linewidth]{./fig/plot_Repo/plot_id3.pdf}
    \caption{低速コードパターンID3による検出数とリポジトリ規模}
    \label{fig:plot_id3}
\end{minipage}
\begin{minipage}[b]{0.49\columnwidth}
    \centering
    \includegraphics[width=0.8\linewidth]{./fig/plot_Repo/plot_id4.pdf}
    \caption{低速コードパターンID4による検出数とリポジトリ規模}
    \label{fig:plot_id4}
\end{minipage}

\centering
\begin{minipage}[b]{0.49\columnwidth}
    \centering
    \includegraphics[width=0.8\linewidth]{./fig/plot_Repo/plot_id5.pdf}
    \caption{低速コードパターンID5による検出数とリポジトリ規模}
    \label{fig:plot_id5}
\end{minipage}
\begin{minipage}[b]{0.49\columnwidth}
    \centering
    \includegraphics[width=0.8\linewidth]{./fig/plot_Repo/plot_id6.pdf}
    \caption{低速コードパターンID6による検出数とリポジトリ規模}
    \label{fig:plot_id6}
\end{minipage}
\end{figure}
%----------------------

次に，図\ref{fig:plot_id1}から図\ref{fig:plot_id6}にリポジトリ規模に対する検出数の関係を示す．それぞれ，低速コードパターンID\ref{ptn:for-in}からID\ref{ptn:push}について示したもので，横軸は各リポジトリに含まれるJavaScriptファイルの総行数，縦軸は検出数を示す．スピアマンの順位相関係数は$0.30$から$0.62$であり，正の相関が認められることから，全てのパターンにおいて，リポジトリ規模が大きくなるほど低速コードパターンの検出数が増加する傾向があることを確認した．
したがって，プロジェクトの規模（総行数）が増大するほど，低速コードパターンが混入する可能性が高まることが示唆された．



\subsection{類似度に基づく検出結果の特徴分析}
\label{subsec:mokusi}
%----------------------
\begin{figure}[t]
    \centering
    \includegraphics[width=1.0\linewidth]{./fig/Repo_cosine_box.png}
    \caption{OSSリポジトリに対する検出結果における類似度スコア}
    \label{fig:plot_Repo_cosine}
\end{figure}
%----------------------

リポジトリから検出されたコード片について，Code2Vecを用いた類似度評価および目視による確認を行った．図\ref{fig:plot_Repo_cosine}に，全6種類のパターンにおけるリポジトリからの検出結果に対する類似度スコアの分布を示す．なお，Code2Vecによる分散表現の取得において，構文解析に失敗する文法的に不正なコード片や，処理可能なトークン長を超える長大なコード片については，本評価の対象から除外している．したがって，図中のデータ数 $n$ は，表\ref{tab:result_detect}で示した総検出数のうち，分散表現の取得に成功したコード片の数を示している．

図\ref{fig:plot_Repo_cosine}より，各パターンの類似度スコアは，\ref{susec:toMB_cosine}項で示したマイクロベンチマーク実装対データセットに対する検出結果の類似度スコア（図\ref{fig:plot_mb_cosine}）と比較して，全体的に低い値で分布する結果となった．
OSSリポジトリに対する検出結果の妥当性および本手法の特性を評価するために，各パターンの分布における類似度スコアの上位と下位の検出コード片を抽出し，目視分析を行った．

\subsubsection{類似度スコアと検出コード片の特徴}

%----------------------------------
\begin{lstlisting}[caption=リポジトリ中の高類似度検出例, label=ID3_highcos, captionpos=t, columns=flexible]
for (let key in obj) {
  if (obj.hasOwnProperty(key)) {
    result[key] = obj[key];
  }
}
\end{lstlisting}
%----------------------------------

%----------------------------------
% 上
\begin{lstlisting}[
  caption=リポジトリ中の低類似度検出例,
  label=ID3_lowcos,
  captionpos=t,
  numbers=left,
  frame=t
]
for (var propKey in rawProps) {
  if (!rawProps.hasOwnProperty(propKey)) {
    continue;
  }
  var nextProp = rawProps[propKey];
\end{lstlisting}
% 中（番号なし）
\begin{lstlisting}[
  numbers=none,
  frame=none
]
...
\end{lstlisting}
% 下（番号再開）
\begin{lstlisting}[
  numbers=left,
  firstnumber=128,
  frame=b
]
    }
  }
}
\end{lstlisting} 
%----------------------------------
%----------------------------------
% 1行目のthis.defaultsのみ背景色をつけるために一部改変
\begin{lstlisting}[caption=意味的に等価ではない検出例, label=ID3_FP, captionpos=t, columns=flexible, literate=
{this.defaults_target}{{\textcolor{black}{\colorbox{lightred}{this.defaults}}}}{13}
{options}{{\textcolor{black}{\colorbox{lightred}{options}}}}{7}
]
for (var key in this.defaults_target) {
  if (!options.hasOwnProperty(key)) {
    attr[key] = this.defaults[key];
  }
}
\end{lstlisting}
%----------------------------------

Listing~\ref{ID3_highcos}および，Listing~\ref{ID3_lowcos}は，低速コードパターンID\ref{ptn:hasOwnProperty}の「\texttt{for-in\_if\_hasOwnProperty()}」について，それぞれ，OSSリポジトリに対する検出コードから類似度スコアの高い検出コードと類似度スコアの低い検出コードを示す．Listing~\ref{ID3_highcos}の類似度スコアは$0.41$，Listing~\ref{ID3_lowcos}の類似度スコアは$-0.37$であった．

リポジトリにおいて，検出したコードの傾向として，類似度スコアが高いコード片は，Listing~\ref{ID3_highcos}に示すように，全体的なコード長が短く，各低速コードパターンの構文構造のみで完結している処理が多く見られた．一方で，類似度スコアが低いコード片は，Listing~\ref{ID3_highcos}に示すように，全体的なコード長が長く，目的の構文構造以外の例外処理や条件分岐といった処理が多く含まれている傾向を確認した．

また，パターンごとの特徴として，低速コードパターンID\ref{ptn:for-in}の「\texttt{for-in}」やID\ref{ptn:forEach}の「\texttt{.forEach()}」といった単一の構文要素からなるパターンでは，類似度スコアの高低にかかわらず，CodeQLによって目的の構造を正確に検出していた．
一方，複数の構文要素やメソッド呼び出しが複合する，低速コードパターンID\ref{ptn:hasOwnProperty}からID\ref{ptn:push}の検出結果においては，構造的には一致しているものの，元低速コードと意味的に異なる検出例が見られた．
低速コードパターンID\ref{ptn:hasOwnProperty}における意味的に異なる検出例を，Listing~\ref{ID3_FP}に示す．
Listing~\ref{ID3_FP}は，低速コードパターンID\ref{ptn:hasOwnProperty}が示す，\texttt{for-in}文内の\texttt{hasOwnProperty}チェックという構文構造を含んでいるが，ループ対象の変数とチェック対象のオブジェクトが異なる.これは，元低速コードと，変数の依存関係における不一致である．

以上の結果から，CodeQLを用いた本手法は，コード長や変数名といった表層的な情報や周囲のノイズに影響を受けずに，定義した低速コードパターンの構造を含むコード片を静的に検出可能であることが示された．
一方で，複合的な構文要素からなるパターンでは，意味的な等価性の保証に課題があることが明らかとなった．

ここで，検出された箇所が実際に高速な実装へ変換可能であるかを追加検証を行った．単一の構文要素における低速コードパターンである，ID\ref{ptn:for-in}と，複数の構文要素やメソッド呼び出しが複合する低速コードパターンである，ID\ref{ptn:hasOwnProperty}のそれぞれの検出結果から，リポジトリにユニットテストが存在する，類似度スコアが高かった検出コードそれぞれ$3$件ずつ抽出した．これらに対し，マイクロベンチマークの低速コードと高速コードの実装対を修正前後の正解例として提示し，大規模言語モデルであるOpenai社のGPT-5.2を用いて修正を行なったところ，全て，既存のユニットテストを通過（修正成功）した．
したがって，検出結果には，マイクロベンチマーク上での知見に基づき，性能が向上する実装方法に変換できる箇所が実際に含まれていたことを確認した．


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{考察}
\label{chap:consideration}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{検出数とリポジトリおよびパターンの関係}

OSSリポジトリに対する検出結果から，OSSリポジトリの規模（総行数）と低速コードパターンの検出数に正の相関が存在した．
これは，対象としたOSSリポジトリが，スター数の多い大規模なリポジトリであり，開発期間が長いプロジェクトが多いことから，開発期間の長さに応じたレガシーコードの蓄積や，ソフトウェアの進化に伴う規模の増大が性能低下を招く\cite{emprical_perfomancebug}ことが要因として考えられる．

各パターンの検出数に着目すると，低速コードパターンID\ref{ptn:for-in}「\texttt{for-in}」やID\ref{ptn:forEach}「\texttt{.forEach()}」は他のパターンと比較して検出数が極めて多かった．
この2つのパターンが示す構文は，JavaScriptにおいて汎用的な構文であり，広く利用されているためであることが考えられる．

一方，低速コードパターンID\ref{ptn:hasOwnProperty}「\texttt{for-in\_if\_hasOwnProperty()}」，ID\ref{ptn:applymap}「\texttt{apply()}\textbf{\_}\texttt{map()}」，ID\ref{ptn:json}「\texttt{parse(stringify())}」，ID\ref{ptn:push}「\texttt{for-of}\textbf{\_}\texttt{push()} 」の検出数は，ID\ref{ptn:for-in}，ID\ref{ptn:forEach}と比較して少ない結果となった．
これらのパターンが示す構文は，モダンJavaScript（ES6以降）の普及に伴い，より簡潔で効率的な代替構文が利用可能である．
例えば，ID\ref{ptn:hasOwnProperty}のようなプロパティチェックは \texttt{Object.keys()} や\texttt{Object.entries()}，ID\ref{ptn:push}のような配列生成はスプレッド構文などへ置き換えることができる．
したがって，旧来の冗長な記述方法であるために，検出数が比較的少なくなったことが考えられる．

% 特にID4（.apply().map()）の検出数が極めて少なかった点については，可読性が低く記述が複雑であることに加え，配列の生成や変換において代替となるモダンな記法（Array.from() やスプレッド構文）が標準化されたことで，用途が限定的になっていることが主因であると考えられる．


\section{類似度スコアと目視調査に基づく検出結果の妥当性}

図\ref{fig:plot_Repo_cosine}に示すOSSリポジトリに対する検出結果の類似度スコアは，図\ref{fig:plot_mb_cosine}に示すマイクロベンチマーク実装対データセットに対する検出結果の類似度スコアと比較して，全体的に低い値に分布する傾向が確認された．
これは，両データセット間におけるソースコードの記述内容が，Code2Vecによる分散表現の取得において表層的な特徴として反映されたためであると考えられる．
特定の処理のみに特化した簡潔な構成を持つマイクロベンチマークに対し，実プロジェクトの検出コードは，多様な処理やそれに紐づく変数を含み，コード長が長く複雑になっていた．
この表層的な文字列情報の違いが結果として，コードの分散表現の差異となり，類似度スコアを低下させたことが考えられる．
その一方で，類似度スコアが低い事例であっても，本研究で作成した低速コードパターンの構造を含むコードを検出できていることを確認した．このことから，本手法がソースコードにおける文字列に関する表層的な情報に左右されず，構造的特徴に基づいて検出が可能であることが考えられる．

さらに，追加検証において，検出箇所を修正したコードが既存のテストを通過した事例が存在したことから，本研究における提案手法は，ソースコード中から，マイクロベンチマーク上で性能が向上する実装方法に変換できるような，性能向上の余地がある箇所を静的に検出することが可能であることが示唆された．



%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{妥当性の脅威}
\label{chap:threat}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{内的妥当性}

本研究では，低速コードの特徴抽出をGumTreeによる差分解析に依存している．したがって，抽出された差分が必ずしも低速コードの特徴を正確に表現していない可能性がある．本研究では，差分から得られた要素を目視により確認し，実装例と照合した上でパターンを作成しているため，その影響は小さいと考えられる．

本研究で利用したマイクロベンチマーク共有サービスであるJsPerfは2020年にサービスを終了しており，当時の高速実装が現在においても最適であるとは限らない．

本研究における類似度スコアの算出においては，コード片の分散表現の取得にCode2Vecを利用している．Code2VecはJavaおよびC\#を対象としており，本研究で対象としたJavaScriptでは，利用における精度において差異が生じる可能性がある．本研究ではJavaScript対応かつマイクロベンチマークをもとに学習された学習モデル\cite{saiki}を使用することで，この影響を抑えるよう努めた．
なお，分散表現の取得における内部処理において，学習の設定に応じて，コード片のトークン数や抽象構文木における構造における制限，分散表現化に利用する特徴のフィルタリングが発生するため，コード長の大きいコード片については，分散表現において，十分にその特徴を反映できていない可能性がある．変数名の抽象化や，学習モデルの再構築によって改善が期待されるものの，開発初期における性能ボトルネックの検出が本研究の目的であることから，本研究において，長大なコードへの対応に関する影響は小さいと考える．


\section{外的妥当性}

本研究におけるケーススタディでは，時間的制約のため，GitHub上のスター数上位のリポジトリに対象を限定して分析を行った．そのため，結果の一般性は限定的である可能性がある．
特にスター数の多いリポジトリは，既に十分に最適化・保守が行われていることが多いため，このようなリポジトリにおける検出結果は，一般的な開発段階のソフトウェアとは異なる可能性がある．

本研究では，低速コードパターンを6個作成し，ケーススタディを実施した．本研究において，パターン化できなかった，マイクロベンチマーク実装対についても，特徴抽出を可能とする手法を作成し，抽出したパターンに基づく提案手法の汎用性および有効性を検証することが今後の課題である．


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{おわりに}
\label{chap:finish}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

本研究では，JavaScript プログラムにおいて低速な要因を含み，性能向上の余地がある実装箇所を，プログラムを実行することなく静的に検出する手法について検討した．実行速度に差があることが評価された機能的に等価なマイクロベンチマーク実装対に着目し，抽象構文木に基づく差分解析によって，低速な要因を含むコード構造を「低速コードパターン」として抽出する手法を提案した．

本研究では，繰り返し処理を中心とした 6 種類の低速コードパターンを作成し，ケーススタディとして，GitHub 上の 1,000 件のリポジトリを対象に検出実験をおこなった．

結果として，提案手法により，ソースコード中から低速コードパターンを含む実装箇所が検出されることを確認した．
また，検出結果に対して，マイクロベンチマークにおける低速コードとの Code2Vec に基づく類似度評価および目視調査を行った結果，構造的に共通する特徴を持つコード片が含まれていることを確認した．
これらの結果から，マイクロベンチマーク共有サービス由来の構造的差分が，実プロジェクトのソースコードにおける処理構造を一定程度捉えていることが示された．

以上より，本手法によって，性能向上の余地があるコード片が検出可能であることが示された．これは，マイクロベンチマーク共有サービスに蓄積された知見を，実行を伴わない静的解析に適用可能であることを示唆している．
また，性能改善の可能性がある実装箇所を実装段階で把握するための一手法として，本研究のアプローチが有効である可能性を示した．


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 謝辞
%%
\begin{acknowledgements}
感謝します．
\end{acknowledgements}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 参考文献
%%
\bibliographystyle{junsrt}
\bibliography{@Bachelor2025_Noguchi/reference}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 付録
%%
% \appendix
% 
% \chapter{サンプルプログラム}
% 
% プログラムリストや実行結果など，本論を補足する上で必要と思われるものが
% あれば付録として付ける．
% 
% {
% \footnotesize
% \begin{verbatim}
% #include <stdio.h>
% int main(void)
% {
%     printf("Hello, World!\n");
%     return 0;
% }
% \end{verbatim}
% }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
