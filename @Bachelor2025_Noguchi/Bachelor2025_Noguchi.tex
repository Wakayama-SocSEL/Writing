\documentclass[11pt]{jreport}
\usepackage{wuse_thesis}
\usepackage{indentfirst}
\usepackage{url}	% \url{}コマンド用．URLを表示する際に便利
\usepackage{xcolor}
\usepackage{listings}
\usepackage{amsmath,amssymb}
\usepackage{tabularx}
\usepackage{stfloats}
\usepackage{booktabs}
\usepackage{threeparttable}
\usepackage{caption}
\usepackage[dvipdfmx]{graphicx}
\usepackage{makecell}

%\usepackage{graphicx}  % ←graphicx.styを用いてEPSを取り込む場合有効にする
			% 他のパッケージ・スタイルを使う場合には適宜追加

% コメント用
\newcommand{\todo}[1]{\colorbox{yellow}{{\bf TODO}:}{\color{red} {\textbf{[#1]}}}}
\newcommand{\memo}[1]{\colorbox{magenta!30}{{\bf MEMO}:}{\color{red!50} {\textbf{[#1]}}}}
\newcommand{\ihara}[1]{\colorbox{green}{{\bf IHARA}:}{\color{blue} {\textbf{[#1]}}}}

\newcounter{patternID}

% コード例を載せるためのあれこれ
\definecolor{lightred}{RGB}{255,230,230}
\definecolor{lightgreen}{RGB}{230,255,230}

\lstset{
    basicstyle=\small\ttfamily,
    abovecaptionskip=0pt,
    captionpos=b,
    frame=tb,
    framexleftmargin=2em,
    numbers=left,
    numberstyle={\scriptsize},
    xleftmargin=\parindent,
    escapechar=|
}

%ListingのキャプションがFigureになってしまうのをListingに直すコマンド
\usepackage{caption}
\makeatletter
\let\MYcaption\@makecaption
\makeatother
\usepackage{caption}
\makeatletter
\let\@makecaption\MYcaption
\makeatother


% 言葉の定義
% プログラム：実行することも含有
% ソースコード：プログラムを構成する文字列
% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 主に表紙を作成するための情報
%%

%%  タイトル(修論の場合は英語表記も指定)
\title{マイクロベンチマークに基づく\\
    JavaScript言語の低速コードパターンの作成と\\
    静的検出}
%\etitle{Test\\Test\\Test}

%%  著者名(修論の場合は英語表記も指定)
\author{野口 隼杜}
%\eauthor{Akinori Ihara}

%% 卒業論文・修士論文(以下のどちらかを選択)
\bachelar	% 卒業論文(4年生用)

%%  学科・クラスタ
\department{システム工}

%%  学生番号
\studentid{60276185}

%%  卒業年度
\gyear{2025}

%%  論文提出日
\date{2026年2月10日}	% 修士の場合は月(2021年2月)までとし，英語表記も指定
%\edate{February 2021}	% 修士の場合，こちら(英語表記)も有効化

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

%%
%%  概要
%%
\begin{abstract}

ソフトウェアの性能効率性はシステム全体の品質に直結する重要な要素であるが，ソースコード中の性能低下箇所の同定および修正は，依然として開発者の経験に大きく依存している．プロファイラなどの動的解析ツールを用いた性能ボトルネック検出手法は，プログラムが実行可能な段階まで実装が進んだ後でなければ検証できず，実装途中の早期段階における性能改善を検証することは困難である．

本研究では，JavaScript プログラムを対象として，静的解析により実装途中のソースコードから潜在的な性能低下箇所を早期に検出することを目的とする．具体的には，マイクロベンチマーク共有サービスに蓄積された，実行速度が評価された機能的に等価な実装対に着目し，それらを抽象構文木へ変換した上で構造的差分を解析することにより，性能低下に寄与する共通のコード構造を抽出する．複数の低速な実装に共通して観測される構造的特徴を「低速コードパターン」とし，このパターンを静的解析エンジンである CodeQL による解析に利用することで，プログラムを実行することなく低速な実装箇所を検出する．

本研究では，特に繰り返し処理を含む実装対に焦点を当て，6種類の低速コードパターンを作成した．ケーススタディとして，GitHub 上の1,000件の JavaScript リポジトリを対象に検出実験を行った結果，実プロジェクトのソースコード中から低速コードパターンを含む実装箇所を検出可能であることを示した．さらに，マイクロベンチマークにおける低速コードと検出されたコード片に対して，Code2Vec を用いた分散表現に基づく類似度評価および目視調査を行った．その結果，提案手法はコードの構造的特徴に基づく低速実装箇所の検出に有効である一方，マイクロベンチマークにおいて実行速度が遅いと評価されたコード片と，意味的に等価な検出結果であるかの検証については課題が残ることを明らかにした．

\end{abstract}

%%  目次
\tableofcontents

%%  図目次 (図目次をいれたければ以下のコメントをはずす)
%\listoffigures

%%  表目次 (表目次をいれたければ以下のコメントをはずす)
%\listoftables

\newpage
\pagenumbering{arabic}	% 以降のページ番号を算用数字に

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%%  本文はここから
%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{はじめに}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

ソフトウェア開発において，ソフトウェアの性能効率性は，JIS X 25010:2013（ISO/IEC 25010:2023）にシステム/ソフトウェア製品品質を図る尺度の一つとして記述され\cite{JISX25010}\cite{ISO25010}，システム全体の品質，さらにはユーザ体験や運用コストに直結する重要な要素である\cite{performance1, performance2, negative}．このことから，開発者は，性能効率性の向上を目的に性能が低下する箇所の同定および修正を行う．
従来，こうした性能低下の要因を特定する手法としては，プロファイラなどを用いた動的解析が広く用いられる．しかし，プロファイラはプログラムが実行可能な状態でなければ適用ができず，開発の早期段階での適用が難しいという課題が存在する．
一般に，修正による影響範囲の拡大や，他の品質特性とのトレードオフの発生によって，開発が進行するに伴って修正コストは増大する傾向にある\cite{local2system}．そのため，開発の早期段階において性能効率性を評価する手法が求められている\cite{assessment_JMbenchmark}．

ここで，開発の早期段階において，システムやアルゴリズムの修正といった規模の大きな最適化だけでなく，既存のコード片をより効率的な実装へ書き換え，部分的な性能効率性の向上を図る「部分的な最適化」が行われる．\cite{jsRefac,JITProf, DrAsync}
部分的な最適化を実践する手段の1つとして，マイクロベンチマークが利用される．\todo{引用：マイクロベンチマークを利用したパフォーマンスチューニング}
マイクロベンチマークは部分的なコード片の性能を測定する性能テストである．ある特定の処理に対して，複数の実装方法とそれぞれのマイクロベンチマークの結果を比較することで，様々な実装方法に対する部分的な性能効率性を定量的に評価できる．
また，マイクロベンチマークを，開発者がWeb上で作成・実行・共有することができるオンラインサービスも存在し，世界中の開発者が投稿した効率的な実装方法についての知見が蓄積されているとともに，開発に利用されることもある\cite{saiki}．
しかし，サービス上におけるマイクロベンチマークの知見を実プロジェクトの性能改善に直接転用することは難しい．これは，サービス上のソースコードは，測定用の補助的なコード含み，また，単純な処理を評価したものが多いためである．したがって，サービス上のソースコードから，低速である要因を認識した上で，自身のソースコード中から低速な要因を含む箇所を探す必要がある．

% 本研究は，マイクロベンチマークを共有するサービス上に存在する知見を利用し，修正することで実行速度の向上が期待されるコード片を静的に検出する手法を提案する
本研究は，マイクロベンチマークを共有するサービス上に存在する知見を利用することで，低速な要因を含み，性能向上の余地があるコード片を静的に検出する手法を提案する．
具体的には，共有サービスに蓄積された実行速度が評価された機能的に等価な実装対に着目し，抽象構文木における構造的差分を解析する．これにより，サービス上のソースコードの測定用の補助的なコードを除外し，低速である要因をコード構造から捉え，「低速コードパターン」として抽出する．このパターンを用いて，静的解析エンジンであるCodeQL\footnote{\url{https://codeql.github.com/}}\cite{ql}により，プログラムの実行を伴わずに大規模なソースコードから低速である実装箇所を特定する．提案手法は，動的解析に依存せずに性能向上の余地がある箇所を実装初期段階でも検出できる．

続く\ref{chap:background}章では，実行速度改善における課題，および関連研究を紹介し，本研究の立ち位置を述べる． \ref{chap:pre-analysis}章で事前分析について示し， \ref{chap:approach}章で，本研究の提案手法，\ref{chap:similarity}章で結果の分析手法について述べる．\ref{chap:case-study}章においてケーススタディの結果を述べ，\ref{chap:consideration}章で考察を行う．\ref{chap:threat}章で妥当性への脅威を示し，\ref{chap:finish}章でまとめる． 


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{プログラム実行速度の改善}
\label{chap:background}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

% -----------------------------------------
\section{ソフトウェアの性能効率性と部分的な最適化}
% -----------------------------------------

ソフトウェアにおける性能効率性は，ユーザー体験の向上，運用コストの削減，およびシステム全体の品質を左右する極めて重要な指標である．
一般に，システムの性能評価では，システムレベルの大規模なテストが行われ，プロファイラといった動的解析を用いてボトルネックを特定し，性能効率性の向上が図られる\cite{systemTest_large}．しかし，動的解析を伴う手法では実行環境の構築や実行時情報の測定及び分析に多大なコストを要することが課題となっている\cite{systemTest_large, systemTest_workload}．加えて，システム構築後，あるいは統合後といった開発の後期工程で，問題が発覚した場合，その影響範囲の広さから対処は困難であり多くの労力を要する\cite{local2system}．
また，性能効率性を向上するためのソースコードの変更は，可読性や保守性といった他の品質を損なうリスク（性能改善と他品質のトレードオフ）も指摘されている\cite{negative}．
このような，システムレベルのテストに基づいた，計算機能力やシステム設計の改善，アルゴリズムの抜本的な変更のような大規模な最適化に対し，既存のコード片を，より効率的な実装へ置き換える「部分的な最適化」を積み重ねることによって性能効率性の向上を実現することも多い．
% \todo{↓書くなら参考文献欲しい}
% 特に，ループ処理やデータ構造操作のように実行回数が多い箇所では，わずかな実装差が全体の実行時間に影響を与えることがある．このようなミクロな性能差を把握し，適切に改善することは，現実的な性能改善戦略の一つである．実際に，

Webアプリケーション開発では，数行のソースコード修正によって最適化した結果，プログラムの実行時間が25\%から70\%高速化している\cite{jsRefac}．
また，ソースコード中の関数やメソッドなどの最小単位が正しく動作するかを検証するユニットテストを実行することや，ユニットテストをもとにしたベンチマークから，コンポーネント単位の微小な範囲において，ソースコードの変更前後のパフォーマンスの変化を評価することが可能となる\cite{test2benchmark, performanceRegression}


% -----------------------------------------
\section{マイクロベンチマーク共有サービス}
% -----------------------------------------

実装段階において，特定の処理に対する複数の実装方法の性能を定量的に比較する手法として，マイクロベンチマークが活用されている．マイクロベンチマークは，複数のコード片の実行時間をそれぞれ測定し，その効率性を相対的に評価するものである．

マイクロベンチマーク共有サービスは，マイクロベンチマークを開発者がWeb上で実行・共有するプラットフォームとして機能するオンラインサービスである．例として，JavaScript言語を対象としたJsPerf\footnote{JsPerf: \url{https://jsperf.app/}}やMeasureThat.net\footnote{MeasureThat.net: \url{https://measurethat.net/}}が挙げられる．これらのサービスは，ブラウザ上での実行環境を提供するとともに，世界中の開発者が投稿したコード片とその測定結果を公開している．

図\ref{fig:jsPerf}に，JsPerf上で実際に投稿されているマイクロベンチマークの例を示す．
マイクロベンチマーク共有サービスにおける各ベンチマークは，1つのセットアッププログラムと，1つ以上のテストプログラムから構成される．図上部に示すセットアッププログラムは，検証対象のソースコードで共通して利用される変数や関数の初期化などが行われる．一方，図下部に示すテストプログラムでは，同一の機能を異なる方法で実装したコード片が複数記述され，それぞれの実行速度をの計測，および比較ができる．
このようなマイクロベンチマークは，データ構造や制御構文の選択，メソッド呼び出しの方法などに多様性が見られ，実行速度の差とその要因となる実装方法を捉えることができる．

実際の開発現場においても，GitHub上のプルリクエスト等において，提案する改善案の正当性を示すエビデンスとしてこれら共有サービスのURLが引用される事例が確認されており\cite{saiki},マイクロベンチマーク共有サービスは効率的な実装パターンを示すデータベースとして機能していることが示唆される．

% 本研究では，このようなマイクロベンチマーク共有サービス上の実装対を，性能効率性，特に実行速度に影響を与える構造的特徴を分析および抽出するために利用する．

%----------------------
\begin{figure}[!h]
    \centering
    \includegraphics[width=0.6\linewidth]{./fig/jsPerf_example.pdf}
    \caption{マイクロベンチマーク共有サービスの投稿例\protect\footnotemark}
    \label{fig:jsPerf}
\end{figure}

\footnotetext{\url{https://jsperf.app/qiwudo}}
%----------------------

% -----------------------------------------
\section{低速箇所の検出における課題}
% -----------------------------------------

既存のソースコードにおいて性能向上の余地がある，低速な箇所の特定において，従来の性能評価手法の課題と，その解決策として期待されるマイクロベンチマーク共有サービスを利用する上での特有の課題を述べる．

従来の性能評価手法における主要な課題は，その多くがプログラムの動的実行に依存している点である．プロファイラやマイクロベンチマークを用いた手法は，実際の動作状況や実行時間を計測することでボトルネックを特定する．そのため，解析対象となるソースコードがコンパイル可能であり，かつ実行に必要な依存ライブラリやテストデータが整備された実行可能状態にあることが前提となる．
しかし，開発の初期段階やリファクタリングの検討段階において，断片的なソースコードに対して即座に実行環境を構築することは容易ではない．また，実装が進むにつれて性能改善のためのソースコードの変更は複雑化する\cite{complicate}．したがって，動的解析を利用する従来の手法では，実装の最中にリアルタイムで低速な記述を検出し，開発を支援することが困難であるという課題がある．

これに対し，マイクロベンチマーク共有サービスを活用するアプローチは，自身のプログラムが実装途中で，実行できる段階に至っていなくとも，事前に第三者によって実行速度が評価された実装方法を利用できるため，自身のプログラムに対する動的実行への依存を排除，あるいは最小化できる可能性がある．
しかし，同サービスに保存されたマイクロベンチマークを開発中のプログラムに適用するには，サービス特有の性質に起因する課題が存在する．共有サービス上のコード片は，不特定の開発者が特定の文脈で局所的な比較を目的に作成したものである．そのため，単純な処理の比較であっても
% 特定の実行環境や入力データに対してのみ有意な差が生じる「コンテキストへの依存」や，
測定用の補助的な変数宣言や処理など，実行速度の差を生み出す要因とは無関係な記述が混在している．

マイクロベンチマークという極めて小さなコード片において，実行速度の差を生み出す要因を認識し，自身のソースコードから，マイクロベンチマーク共有サービスにおける低速な実装方法を採用している箇所を特定し，改善案を適用することは容易ではない．したがって，膨大な公開データから汎用的な「低速な要因」を抽出・検出するためには，ソースコードの構造的・意味的な特徴を捉え，コード片から実行速度の差を生み出す要因を識別する解析手法が必要となる．


% -----------------------------------------
\section{関連研究}
% -----------------------------------------

\subsection{実行速度向上を目的としたリファクタリングの調査}

Selakovicら\cite{jsRefac}は，JavaScriptを利用しているプロジェクトにおいて，開発者が高速化のために行ったリファクタリングを調査している．調査の結果，開発者は10行程度の小さい範囲の修正によって高速化への対処を行なっていることを明らかにした．この結果から，マイクロベンチマークで評価される短いコード片を利用した修正が，ソフトウェア高速化につながっていることを示唆していると考えられる，また，\cite{jsRefac}では，JavaScriptプロジェクトの解析によって10件の頻出する高速化修正パターンを作成している．この改良パターンを用いた自動修正は一定の高速化の効果を示しているが，該当箇所の同定における条件などから，広範な適用には至っていない．

\subsection{静的解析と動的解析を用いた性能アンチパターンの検出}
\todo{もっと引用}
Turcotte ら\cite{DrAsync}は，JavaScript 言語における非同期処理に注目し，ソースコードの目視調査やStack Overflow上の知見から，より効率的かつ簡潔な記述方法が存在する実装方法を性能アンチパターンとして定義し，静的解析エンジンであるCodeQL\cite{ql}と動的解析による実行頻度や呼び出し関係の監視を組み合わせて，修正可能な性能アンチパターンの検出手法の提案した．

非同期処理という特定のドメインに対する手動定義されたパターンに限定しているものの，静的解析による広範な実装形態への適用を実現している．本研究では，マイクロベンチマーク共有サービスに保存された実装対から，自動的にパターンを抽出・生成することを目指す．これにより，静的検出アプローチを継承・発展させつつ，より汎用的な性能改善支援を提供する．

% -----------------------------------------
\section{本研究の位置付け}
% -----------------------------------------

本研究では，別の方法で実装することで性能向上の余地がある箇所を，開発の早期段階で静的に検出する手法を確立することを目的とし，マイクロベンチマーク共有サービスにおいて実行速度が評価された実装対に着目し，それぞれの抽象構文木間における構造的な差分をもとに，静的な解析に利用できる汎用的な「低速コードパターン」を作成し，その検出を行う手法を提案する．
マイクロベンチマーク共有サービスで示される実装方法と動的解析の結果（実行速度の差異）から，静的なパターンへと変換することで，サービス上で示される実装方法の低速要因をコード構造として抽出する．この，コード構造として抽出したパターンを利用し，実装途中のプログラム中から，静的解析のみで性能向上の余地がある箇所を検出する．
\memo{難しさで触れた小さなコード片の検出の話をからめて，正規表現やコードクローンではなく，構造情報を検出に利用する話を埋め込みたいけどどこがいいか．．．4.3節あたりで回収する方がいい？}


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{事前分析：マイクロベンチマークにおける低速コードの特徴}
\label{chap:pre-analysis}
%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{概要}
\label{preanalysis_abst}

本章では，本研究における検出対象を絞り込むことを目的とした，マイクロベンチマーク実装対の傾向分析について述べる．目視により，分析対象としたマイクロベンチマーク共有サービスにおける実装対は，実装対の両方もしくは片方に繰り返し処理を含むことを確認した．実装対全てを個別に扱うことは困難であることから，繰り返し処理が多くの実装対で利用されていることを踏まえ，繰り返し構文の有無を中心に構文解析を行った．結果として，データセットに含まれる実装対の約4割に繰り返し処理が含まれており，それらに共通する典型的なパターンが存在することを確認した．この結果に基づき，本研究では繰り返し処理に焦点を当てて検出手法を構築する．


\section{データセット}

本研究では，大森ら\cite{omori}が作成したマイクロベンチマーク共有サービスに関するデータセットを分析対象とする．当該データセットは，JavaScript言語を対象としたマイクロベンチマーク共有サービスJsPerfにおいて公開されているマイクロベンチマークのうち，比較されている実装方法の実行時間に統計的な有意差が見られ，さらに外的振る舞いが等しいことが検証された29,809件の実装対である．以降，分析対象とする，マイクロベンチマークで比較されたコード片の対をマイクロベンチマーク実装対，各実装対において，実行速度が遅いコードを低速コード，実行時間が速いコードを高速コードと呼ぶ．


\section{抽象構文木に基づく実装方法の分析}

検出対象とする，低速コードの特徴を明確化するため，まずマイクロベンチマーク実装対に対し，目視調査を行った．その結果，実装対の両方もしくは片方に繰り返し処理を含むものが多く存在することを確認した．このような観察結果に基づき，本研究ではマイクロベンチマーク実装対に対して繰り返し処理に着目した特徴分析を行う．対象とする繰り返し処理は，JavaScriptにおける \texttt{for}，\texttt{for-of}，\texttt{for-in}，\texttt{while}，および \texttt{do-while}とする．マイクロベンチマーク実装対のソースコードを抽象構文木に変換し，各ソースコードに含まれる繰り返し処理に関する構文要素の有無を検証した．その結果，11,893件の実装対 (全実装対の39.9\%) において，繰り返し処理に関連する構文が含まれていることがわかった．次に，繰り返し処理を含むマイクロベンチマーク実装対11,893件について，実装対を構成する2つのソースコード間の抽象構文木における構造的な差分を抽出し，差分と元の実装対の特徴について目視で確認を行った．
次節において，繰り返し処理に関するマイクロベンチマーク実装対のもつ特徴について具体例を示す．


\section{繰り返し処理を含む低速コードの主要パターン}

マイクロベンチマーク実装対において確認した，実行速度に差が生じる繰り返し処理の使用パターンとその特徴について，具体例として，Listing~\ref{diff-loop}，Listing~\ref{diff-inloop}，Listing~\ref{diff-method}に示す．

Listing~\ref{diff-loop}は，それぞれ\texttt{for-in}文を用いて配列に含まれる要素にアクセスする実装と，同様の処理を\texttt{for}文で実装したコード片である．ここで示すパターンは，実行時間の差が，繰り返し処理を行う構文そのものが異なることに起因する実装対である．

%----------------------------------
\begin{lstlisting}[caption=繰り返し処理自体の実装方法が異なる実装対, label=diff-loop, captionpos=t, columns=flexible]
// slow
for (key in VAR_1) {
    if (!VAR_1.hasOwnProperty(key)) continue;
    VAR_2 = VAR_1[key];
}

// fast
for (var VAR_8 = 0; VAR_8 < VAR_1.length; ++VAR_8) {
    VAR_2 = VAR_1[VAR_8];
}
\end{lstlisting}
%----------------------------------

Listing~\ref{diff-inloop}は，それぞれ\texttt{for}文内で \texttt{concat}メソッド，\texttt{push}メソッドを用いている実装対である．これは，同一の繰り返し処理を行う構文において，その繰り返し内部で実行する処理の記述方法が異なることによって実行速度の差が生じている実装対である．

%----------------------------------
\begin{lstlisting}[caption=繰り返し内部で実行する処理の記述方法が異なる実装対, label=diff-inloop, captionpos=t, columns=flexible]
// slow
for (var VAR_2 = 0; VAR_2 < 5000; VAR_2++)
    VAR_1 = VAR_1.concat([\"1\", \"2\"]);

// fast
for (var VAR_2=0; VAR_2<5000; VAR_2++)
    VAR_1.push(\"1\", \"2\");
\end{lstlisting}
%----------------------------------

Listing~\ref{diff-method}は，繰り返し処理を\texttt{forEach}メソッドで実装したコード片と\texttt{for-of}文で実装したコード片である．これは，メソッドによる処理とそれに代替する繰り返し処理について比較した実装対であり，メソッド呼び出しのオーバーヘッドや内部的な最適化の有無により実行速度の差が生じていることが示唆される実装対である．

%----------------------------------
\begin{lstlisting}[caption=メソッド処理と代替する繰り返し処理に関する実装対, label=diff-method, captionpos=t, columns=flexible]
// slow
var VAR_5 = new Set(VAR_2);
VAR_5.forEach(VAR_6 => {});

// fast
for (let VAR_7 of VAR_2) {}
\end{lstlisting}
%----------------------------------

これらの結果から，マイクロベンチマーク実装対において，抽象構文木の構造的差分の中に，性能低下の要因となる特徴的なノード構成が含まれているとともに，繰り返し処理および繰り返す処理の記述内容の違いが性能差の要因の1つとして存在することを確認した．
この事前分析の結果に基づき，本研究では，繰り返し処理に焦点を当て，マイクロベンチマーク実装対の構造的差分を解析することで低速コードの特徴を抽出し，次章以降で述べる低速コードパターンの作成および静的検出に利用する．


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{構造的差分に基づく低速コードパターンの検出手法}\todo{全体概要図を作る}
\label{chap:approach}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{概要}
\label{sec:approach_abst}

本章では，マイクロベンチマーク実装対を用いた低速コードパターンの作成および，CodeQLを用いた静的検出手法と，検出結果の妥当性を評価する手法について述べる．図\todo{全体概要図}は，本研究で提案する手法の概略図を示す．

本研究では，マイクロベンチマーク実装対に対し，差分解析を用いて低速コードの特徴抽出および，低速コードパターンの作成を行う．次に，静的解析によって，ソースコード中から作成した低速コードパターンを含むコード片を検出する．
検出されたコード片が低速コードパターンの示す低速要因を含むかどうかについての評価には，低速コードと，検出したコード片の類似度に基づいた目視調査を行う．


\section{差分解析による低速コードパターンの作成}
\label{approach_extract}

各マイクロベンチマーク実装対において差分解析を行うことで，対となる高速コードに含まれない，低速コード特有の処理や構造を示す要素を低速コードの特徴として抽出する．差分解析には，GumTree\cite{gumtree}を使用する．
GumTreeは，ソースコードの抽象構文木を基にした差分解析ツールであり，変更前後のソースファイルまたは抽象構文木を受け取ると，抽象構文木におけるノード単位の編集操作とその差分要素を出力する．検出できる編集操作は，「削除」，「挿入」，「移動」，「更新」である．

本手法では，収集したマイクロベンチマーク実装対において，低速コードから高速コードへの変更を想定し，GumTreeを利用して，編集操作とその差分要素を収集する．次に，収集した要素のうち，低速コードから削除または更新された要素を抽出する．これらの要素を，低速コード特有の処理や構造を示す低速コードの特徴候補として収集する．

例として，Listing \ref{diff-loop} に示す低速コードと高速コードの実装対において，この処理を実施した結果をListing~\ref{candidates}に示す．この処理によって，Listing~\ref{candidates}における背景色のついた要素が低速コードの特徴候補として収集できる．

次に，収集した低速コードの特徴候補の中から，プログラムの振る舞いに意味的な影響を与える要素として，繰り返し処理，メソッド呼び出し，配列・オブジェクト操作を示す要素を自動抽出し，統合する．

これらの操作によって，Listing \ref{diff-loop}に示す実装対から，“\texttt{if}文に\texttt{.hasOwnProperty()}呼び出しを持つ\texttt{for-in}文”という低速コードパターンが作成される．

%----------------------------------
\begin{lstlisting}[caption=Characteristic Candidates for Slow Code, label=candidates, captionpos=t, columns=flexible, literate=
    {for}{{\textcolor{black}{\colorbox{lightred}{for}}}}{3}
    {key}{{\textcolor{black}{\colorbox{lightred}{key}}}}{3}
    {in }{{\textcolor{black}{\colorbox{lightred}{in}}\kern0.5em}}{3}
    {VAR\_1}{{\textcolor{black}{\colorbox{lightred}{VAR\_1}}}}{5}
    {if}{{\textcolor{black}{\colorbox{lightred}{if}}}}{2}
    {!}{{\textcolor{black}{\colorbox{lightred}{!}}}}{1}
    {hasOwnProperty}{{\textcolor{black}{\colorbox{lightred}{hasOwnProperty}}}}{15}
    {continue}{{\textcolor{black}{\colorbox{lightred}{continue}}}}{8}
    {VAR\_1\_}{{\textcolor{black}{VAR\_1}}}{6}
]
for (key in VAR_1) {
  if(! VAR_1.hasOwnProperty(key))continue;
  VAR_2 = VAR_1_[key];
}
\end{lstlisting}
%----------------------------------


\section{CodeQLによる低速コードパターンの静的検出}
\label{approach_codeQL}

本研究では，静的解析エンジンであるCodeQL\cite{ql, codeql}を用いて，\ref{approach_extract}節における手法で作成した低速コードパターンの検出を行う．

CodeQLは，GitHub社が開発したコード解析プラットフォームであり，プログラムの構造的・意味的な探索を可能にするツールである．
CodeQLでは，ソースコードを解析し，抽象構文木，制御フロー，およびデータフローの情報を含むリレーショナルデータベースを構築する．これに対し，論理プログラミング言語であるQL言語を用いてクエリを記述することで，このデータベースから特定のパターンに合致するコード片を検索できる．
なお，抽象構文木に基づく構造情報をもとに作成した低速コードパターンの検出において，構造情報を参照して静的動作する点でCodeQLを採用した．

本手法では，抽出した低速コードパターンの構造的特徴に基づいたQLクエリを作成する．検出対象の粒度はブロック単位とする．作成したクエリを，検出対象となるプログラムのCodeQLデータベースに対して実行することで，低速な実装方法が用いられている箇所を静的に検出する．


\section{類似度に基づく検出結果の評価方法}
\label{approach_evaluation}

\subsection{妥当な検出結果の判定方針}

提案手法によって実際のプログラムから検出されたコード片が，低速コードパターンを実際に含んでいるか，つまり，検出結果が妥当であるかを判定する必要がある．ここで，本研究における正しい検出結果は，低速コードパターンを含む，マイクロベンチマーク共有サービスにおいて実行速度が評価された実装方法を採用している箇所である．
しかし，検出対象のプログラム中の正解とされる箇所は自明ではなく，また，検出数が膨大になる場合，全ての検出結果に対して目視による分析を行うことは現実的ではない．したがって，適合率や再現率といった指標で評価を行うことは困難である．

そのため，本研究では，パターンの元となった低速コードと，実際の検出結果との類似度を指標として用いる．類似度の高い順に検出結果を順位づけし，高類似度の検出結果，および低類似度の検出結果の傾向を比較，分析することで，検出結果の妥当性および本手法の特性を明らかにする．

\subsection{コード片の分散表現化}

低速コードと検出したコード片の類似度を定量的に評価するため，コード片を多次元のベクトルとして表現する分散表現を用いる．
本手法では，ソースコードにおける構造的な情報に基づいて低速コードパターンの作成および検出を行っていることから，ソースコードの構造的な特徴を考慮して分散表現を取得することが可能なCode2Vec\cite{code2vec}を採用した．

Code2Vecは，ソースコードの抽象構文木から抽出されたパスに基づき，ソースコードの構造的な情報を用いて分散表現を取得する手法である．利用においては，Saikiら\cite{saiki} が作成した，JavaScript に対応したパスコンテキスト変換処理と学習モデルを利用する．


\subsection{コサイン類似度による検出結果の順位づけ}

特定の低速コードパターンについて，パターンの抽出元となった低速コードと，実プロジェクトから検出したコード片をそれぞれCode2Vecを用いて分散表現へと変換する．
次に，ある一つの検出コード片に対して，パターンの抽出元となった個々の低速コードとの間で類似度を算出する．ここでは，コード間の意味的な類似度を計測することを目的に，ベクトル間の類似度の測定方法から，コサイン類似度を利用する．

なお，コサイン類似度は，2つのコード片$A,B$のコードベクトルを$\overrightarrow{a},\overrightarrow{b}$とした時，内積の定義から次のように計算される．

\begin{displaymath}
	cos(\overrightarrow{a}, \overrightarrow{b}) = \frac{\overrightarrow{a} \cdot \overrightarrow{b}}{|\overrightarrow{a}||\overrightarrow{b}|}
	= \frac{\sum_{i=1}^d \overrightarrow{a}_{i} \overrightarrow{b}_{i}}{\sqrt{\sum_{i=1}^d (\overrightarrow{a}_{i})^2} \cdot \sqrt{\sum_{i=1}^d (\overrightarrow{b}_{i})^2}}
\end{displaymath}

コード片$A,B$が意味的に類似している場合，2つのベクトル$\overrightarrow{a},\overrightarrow{b}$は間の角度が0に近づき，その結果$cos(\overrightarrow{a}, \overrightarrow{b})$が1に近づく．この$cos(\overrightarrow{a}, \overrightarrow{b})$がコサイン類似度であり，ベクトル間の類似度を$[-1,1]$の範囲で測定できる．

ある一つの検出コードと，パターンの元となった全ての低速コードに対するコサイン類似度を算出した後，それらの平均値を当該検出コード片の類似度スコアとする．この処理を全ての検出結果に対して実施し，スコアの降順で並び替えることで，元の低速コードに近い特徴を持つ順に結果を並べる．
高類似度の検出結果，および低類似度の検出結果について，目視調査を行い，検出結果の妥当性および本手法の特性を評価する．



%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{ケーススタディ}
\label{chap:case-study}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{概要}
\todo{MB・リポジトリそれぞれで検出ー類似度ー目視の構成にする}
本章では，\ref{chap:approach}章で提案した手法の有効性を検証するため，作成した低速コードパターンを示した上で，2つの実験を行った結果について述べる．まず，収集元のマイクロベンチマーク実装対のデータセットを対象に検出実験を行い，クエリの妥当性と検出コードの構造的類似性を検証する．次に，GitHub上のOSSリポジトリを対象に検出実験を行い，実開発における低速コードパターンの混入状況を調査するとともに，検出されたコード片の類似度評価および目視による評価を行う．


%----------------------¬
\begin{table}[!h]
    \centering
    \caption{低速コードパターン}
    \label{tab:slow_code_patterns}
    \setcounter{patternID}{0} % 表が始まる前にカウンタを0にリセット
    \begin{threeparttable}
        \begin{tabular}{cllr}
            \toprule
            \textbf{ID} & \textbf{パターン名} & \textbf{構造例} & \textbf{元低速コード数} \\
            \midrule
            
            \refstepcounter{patternID}\label{ptn:for-in}
            \thepatternID & 
            \texttt{for-in} & 
            \texttt{for (k in o) \{...\}} & 
            534 \\
            
            \refstepcounter{patternID}\label{ptn:forEach}
            \thepatternID &
            \texttt{forEach()} &
            \texttt{arr.forEach(item => \{...\});} &
            194 \\
            
            \refstepcounter{patternID}\label{ptn:hasOwnProperty}
            \thepatternID &
            \makecell[l]{%
              \texttt{for-in \_}\\
              \texttt{  if \_ hasOwnProperty()}
            } &
            \makecell[l]{%
                \texttt{for (k in o) \{ }\\
                \texttt{  if (o.hasOwnProperty(k))\}} 
            } &
            102 \\

            \refstepcounter{patternID}\label{ptn:applymap}
            \thepatternID &
            \texttt{apply()} \textbf{\_} \texttt{map()} &
            \texttt{Array.apply(null, arr).map(...)} &
            12 \\
            
            \refstepcounter{patternID}\label{ptn:json}
            \thepatternID &
            \texttt{parse(stringify())} &
            \texttt{JSON.parse(JSON.stringify(obj))} &
            11 \\
            
            \refstepcounter{patternID}\label{ptn:push}
            \thepatternID &
            \texttt{for-of} \textbf{\_} \texttt{push()} &
            \texttt{for (i of o) \{res.push(i);\}} &
            8\\
                
            \bottomrule
        \end{tabular}
    \end{threeparttable}
\end{table}
%----------------------


\section{低速コードパターンの作成}

本研究では，\ref{chap:pre-analysis}章における事前分析に基づき，繰り返し処理を含む11,889件のマイクロベンチマーク実装対を，パターン作成におけるデータセットとして利用する．
このマイクロベンチマーク実装対のデータセットに対し，\ref{chap:approach}章に示す差分解析および特徴抽出を行い，最終的に6種類の低速コードパターンを作成した．これらは，マイクロベンチマーク実装対において，低速コードから高速な実装コードへの変更差分として抽出された特徴候補に対し，目視による精査を経て作成したものである．なお，異なる実装対から同一の特徴が抽出される場合は1つのパターンとして集約した．

作成した6つのパターンと，それぞれの特徴，および抽出元となったマイクロベンチマーク実装対の数を表\ref{tab:slow_code_patterns}に示す．
表中の「構造例」は，CodeQLクエリによって検出対象となる低速コードの構造を示している．
また，「元低速コード数」は，そのパターンに集約された低速コードの総数（各低速コードパターンを持つ低速コードの数）を示している．
ID\ref{ptn:for-in}の「\texttt{for-in}」やID\ref{ptn:forEach}の「\texttt{.forEach()}」のように，一般的に利用頻度の高い構文が低速要因として抽出されている一方で，ID\ref{ptn:hasOwnProperty}のような特定のメソッド呼び出しを含む複合的な構造も抽出された．本実験では，これらのパターンに対応するCodeQLクエリを作成し，検出に利用する ．


\section{低速コードパターンからCodeQLクエリへの変換}

表\ref{tab:slow_code_patterns}に示す低速コードパターンをCodeQLで検出可能な形式に変換するため，各パターンに対するQLクエリを手作業で作成する．例として，ID\ref{ptn:hasOwnProperty}に対応するQLクエリを\ref{query:ID3}に示す．
本研究では，6つの低速コードパターンから作成したクエリを，対象プロジェクトのCodeQLデータベースに対して実行することで，低速な実装方法が用いられている箇所を検出する．

%----------------------------------
\begin{lstlisting}[caption=ID\ref{ptn:hasOwnProperty}に対応するQLクエリ, label=query:ID3, captionpos=t, columns=flexible, escapechar=\@]
predicate forInWithIfhasOwnProperty(ForInStmt f) {
  exists(IfStmt ifStmt |
    // if 文が for-in 文の配下に含まれる
    f.getBody().getAChild*() = ifStmt and    
      // if 条件式内に hasOwnProperty 呼び出しが存在
      exists(CallExpr c |
        c = ifStmt.getCondition().getAChild*() and
        c.getCallee().(PropAccess).getPropertyName() = "hasOwnProperty"
      )
  )
}
\end{lstlisting}
%----------------------------------


\section{マイクロベンチマーク実装対データセットにおける検証}
\label{sec:toMB}

作成した低速コードパターンおよびCodeQLクエリが，意図した構造を正しく検出できるかを検証するため，抽出元であるマイクロベンチマークデータセット（低速コード全11,889件）に対して検出実験を行った．


\subsection{検出精度と妥当性}
各パターンに対する検出実験の結果として，以下の定義に基づき再現率および適合率を算出する．

\subsubsection{再現率（Recall）}
パターンの抽出元となった低速コードのうち，検出された割合．
$$\text{再現率} = \frac{\text{検出結果に含まれる元低速コード数}}{\text{元低速コード数}}$$

\subsubsection{適合率（Precision）}
クエリによって検出された全コード片のうち，パターンの抽出元となった実装対における低速コードが占める割合．
$$\text{適合率} = \frac{\text{検出結果に含まれる元低速コードの数}}{\text{総検出数}}$$

%----------------------
\begin{table}[t]
    \centering
    \caption{マイクロベンチマーク実装対データセットに対する検出結果}
    \label{tab:result_detectToMB}
    \begin{tabular}{crrrr}
        \toprule
        \textbf{ID} & \textbf{元低速コード数} & \textbf{検出数} & \textbf{再現率} & \textbf{適合率} \\
        \midrule           
        \ref{ptn:for-in} & 534 & 1000 & 1.0 & 0.53 \\
        \ref{ptn:forEach} & 194 & 346 & 1.0 & 0.56 \\
        \ref{ptn:hasOwnProperty} & 102 & 195 & 1.0 & 0.52 \\
        \ref{ptn:applymap} & 12 & 89 & 1.0 & 0.14 \\
        \ref{ptn:json} & 11 & 18 & 1.0 & 0.61 \\
        \ref{ptn:push} & 8 & 38 & 1.0 & 0.21 \\
        \bottomrule
    \end{tabular}
\end{table}
%----------------------

%----------------------
\begin{figure}[t]
    \centering
    \includegraphics[width=1.0\linewidth]{./fig/MB_cosine.pdf}
    \caption{マイクロベンチマーク実装対データセットに対する検出結果における類似度スコア}
    \label{fig:plot_mb_cosine}
\end{figure}
%----------------------

検出実験の結果を表\ref{tab:result_detectToMB}に示す．全ての低速コードパターンにおける検出結果に，パターンを抽出した元の実装対における低速コードが含まれており，再現率は全て 1.0 となった．結果として作成したクエリが意図した低速コードパターンを検出できることを確認した．
一方で，適合率はパターンの種類により 0.14 から 0.61 の範囲となった．これは，本手法が各マイクロベンチマーク実装対に対して，抽象構文木による「差分」に基づいて特徴を抽出していることに起因する．ある実装対で，差分として現れなかった箇所であっても，低速コードパターンの示す構文が使用されているケースがあり，これらがクエリによって検出されたためである．これらは構造的にはクエリの条件を満たしており，CodeQLによる構造的検出自体は正しく機能していると言える．


\subsection{検出コードの類似度評価}

検出されたコード片が，元の低速コードとどの程度類似しているかを定量的に評価するため，Code2Vecを用いた分散表現によるコサイン類似度を算出した．
図\ref{fig:plot_mb_cosine}に，マイクロベンチマーク実装対データセットからの検出結果における類似度スコアの分布を示す．図中の白い点が検出したコードを示し，赤点がパターンの元となった低速コードを示す．\todo{平均・中央値などを載せる？}
図\ref{fig:plot_mb_cosine}に示すように，元低速コードが，類似度スコアが高い上位の結果に多くみられた．また，他の高類似度スコアを示すコード片についても．目視により，クエリの条件を満たす構造を持っていることを確認した．この結果から，Code2Vecによる類似度が，構造的に類似するコード片に対して適切に高い値を算出できていることが示唆される．



%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{OSSプロジェクトへの適用}
\label{sec:toOSS}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

次に，提案手法の実用性を評価するため，GitHub上のOSSリポジトリを対象に低速コードパターンの検出実験を行った．実験対象として，JavaScriptを主要言語とし，かつ最終コミットが1年以内であるスター数上位1,000件のリポジトリを収集し，2025年10月13日時点における最新スナップショットのJavaScriptファイルを用いた．\todo{可能なら：図〜に，対象となるプロジェクトのjsコード行数の分布を示す}

\subsection{検出結果}

%----------------------
\begin{table}[t]
    \centering
    \caption{低速コードパターンによる検出結果}
    \label{tab:result_detect}
    \begin{tabular}{crrr}
        \toprule
        \textbf{ID} & \textbf{検出リポジトリ数} & \textbf{最大検出数 (件)} & \textbf{総検出数 (件)} \\
        \midrule           
        \ref{ptn:for-in} & 692 & 9,912 & 101,212 \\
        \ref{ptn:forEach} & 844 & 12,676 & 174,047 \\
        \ref{ptn:hasOwnProperty} & 308 & 1,125 & 9,516 \\
        \ref{ptn:applymap} & 49 & 12 & 139 \\
        \ref{ptn:json} & 284 & 142 & 2,823 \\
        \ref{ptn:push} & 480 & 3,351 & 32,812 \\
        \bottomrule
    \end{tabular}
\end{table}
%----------------------

表\ref{tab:result_detect}に，各低速コードパターンごとの検出結果を示す．なお，「ID」は低速コードパターンのID，「検出リポジトリ数」は1つ以上のコード片が検出されたリポジトリの数，「最大検出数」は単一リポジトリにおける最大検出数，「総検出数」は，1,000リポジトリにおける総検出数を示す．

表\ref{tab:result_detect}から，パターンによって検出数に差があるものの，$49$リポジトリ 〜 $844$リポジトリで検出結果を得た．\ref{tab:slow_code_patterns}に示す，ID\ref{ptn:for-in}や，ID\ref{ptn:forEach}の低速コードパターンのように，一般的に利用頻度の高い構文でありマイクロベンチマーク実装対における検索結果の数が多いパターンは，，リポジトリにおいても検出数が多かった．また，これに対し，ID\ref{ptn:push}では，マイクロベンチマーク実装対において，検索結果の数が少なかったものの，データセットにおけるリポジトリにおいては検出数が多くなった．これは，一般的に可読性が高いとされる\texttt{for-of}についての低速コードパターンであることから，実行速度以外の品質への考慮が示唆される．

%----------------------
\begin{figure}[t]
    \centering
    \includegraphics[width=0.8\linewidth]{./fig/log_ID3_spia.pdf}
    \caption{低速コードパターンID3による検出数とリポジトリ規模}
    \label{fig:plot_id3}
\end{figure}
%----------------------

\todo{他のパターンの結果を全て載せる}
図\ref{fig:plot_id3}は，低速コードパターンID\ref{ptn:hasOwnProperty}について，リポジトリ規模に対する検出数の関係を示す．横軸は各リポジトリに含まれるJavaScriptファイルの総行数，縦軸は検出数を示す．リポジトリ規模が大きくなるほど低速コードパターンの検出数が増加する傾向があり，スピアマンの順位相関係数は0.44，p値は\(5.12 \times 10^{-14} < 0.05\)より正の相関が認められる．他の低速コードパターンについても，同様の傾向が見られた．
したがって，プロジェクトの規模（総行数）が増大するほど，低速コードパターンが混入する可能性が高まることが示唆された．


\subsection{類似度に基づく検出結果の特徴分析}

\todo{他のパターンについてもやった結果をまとめて図にする}
図\ref{fig:boxplot_cosine}は，パターンID \ref{ptn:hasOwnProperty}“\texttt{if}文に\texttt{.hasOwnProperty()}呼び出しを持つ\texttt{for-in}文”の検出結果を対象としたコサイン類似度スコアを示した箱ひげ図である．左からそれぞれ，収集したマイクロベンチマークデータセットに対する検出結果についての類似度スコア，リポジトリに対する検出結果についての類似度スコアを示している．また，Listing~\ref{ID3_origin}にマイクロベンチマーク実装対におけるパターン抽出元低速コードの例，Listing~\ref{ID3_highcos}にコサイン類似度の高い検出例，Listing~\ref{ID3_lowcos}にコサイン類似度の低い検出例を示す．Listing~\ref{ID3_highcos}の類似度スコアは$0.41$，Listing~\ref{ID3_lowcos}の類似度スコアは$-0.37$である．

なお，長大，または文法的に不正なコード片は，分散表現取得における構文解析で失敗する．したがってリポジトリに対する検出結果の類似度スコアでは，検出総数9,516件中，分散表現の取得に成功した7,039件を対象としたものとなっている．

\memo{マイクロベンチマークデータセットに対する結果を載せるかは要議論}
検出結果の類似度スコアの範囲は$-0.37$ 〜 $0.41$で，平均値は0.09，中央値は0.09となった．

% 図\ref{fig:boxplot_cosine}に示すように，マイクロベンチマーク実装対における検出結果は，データセット中のリポジトリにおける検出結果と比べ，コサイン類似度が高い値で分布している.
% なお，マイクロベンチマーク実装対においては，Listing\ref{diff-loop}とListing\ref{MB_highcos}に示す通り，変数名などが同じ規則で抽象化され，コード長も同程度であることから，比較している低速コードと非常に類似するコード片となっている．

Listing~\ref{ID3_highcos}に示すような類似度スコアの高いコード片は，Listing~\ref{ID3_origin}に示すような，比較対象となるマイクロベンチマーク実装対におけるパターン抽出元低速コードと，コード長および構造が類似している．使用している変数名については，短く単純な変数名が多く見られた．
一方，Listing\ref{ID3_lowcos}に示すような類似度スコアが低いコード片では，様々な処理が含まれたコード長の大きいものや，変数名が長いコード片が多く見られた．コサイン類似度が小さいほど，検出したコード片の構造は比較する低速コードに対して複雑になっていく傾向があることを確認した．

これらの結果から，コサイン類似度は，コード長や変数名の影響を受けることが示唆されるとともに，ソースコードの構造に基づいて検索を行ったことで，コード長や変数名といった表面的な情報に影響を受けずに，低速コードパターンを含むコード片を検出できたことが示唆される．

%----------------------
\begin{figure}[t]
    \centering
    \includegraphics[width=0.7\linewidth]{./fig/boxplot_github_id3.pdf}
    \caption{低速コードパターンID \ref{ptn:hasOwnProperty}で検出されたコード片とパターン元低速コードのコサイン類似度}
    \label{fig:boxplot_cosine}
\end{figure}
%----------------------

%----------------------------------
\begin{lstlisting}[caption=パターン抽出元低速コード例, label=ID3_origin, captionpos=t, columns=flexible]
for (var VAR_4 in VAR_1) {
  if (VAR_1.hasOwnProperty(VAR_4)) {
    VAR_3 = VAR_1[VAR_4];
  }
}
\end{lstlisting}
%----------------------------------

%----------------------------------
\begin{lstlisting}[caption=リポジトリ中の高類似度検出例, label=ID3_highcos, captionpos=t, columns=flexible]
for (let key in obj) {
  if (obj.hasOwnProperty(key)) {
    result[key] = obj[key];
  }
}
\end{lstlisting}
%----------------------------------

%----------------------------------
% 上
\begin{lstlisting}[
  caption=リポジトリ中の低類似度検出例,
  label=ID3_lowcos,
  captionpos=t,
  numbers=left,
  frame=t
]
for (var propKey in rawProps) {
  if (!rawProps.hasOwnProperty(propKey)) {
    continue;
  }
  var nextProp = rawProps[propKey];
\end{lstlisting}
% 中（番号なし）
\begin{lstlisting}[
  numbers=none,
  frame=none
]
...
\end{lstlisting}
% 下（番号再開）
\begin{lstlisting}[
  numbers=left,
  firstnumber=128,
  frame=b
]
    }
  }
}
\end{lstlisting} 
%----------------------------------


\section{CodeQLを用いた静的検出の有効性}
\todo{結果のまとめとしての節タイトルは再考の余地あり}

ケーススタディの結果から，本研究において，マイクロベンチマーク共有サービスで保存された実装対を用いて定義した6つの低速コードパターンは，実際のOSSプロジェクトにおいても存在する実装方法であることを確認した．加えて，低速コードパターンの検出数は，プロジェクトの規模の大きさに伴って増加することを確認した．
また，類似度評価に基づいて，検出したコード片を目視で確認したところ，元のマイクロベンチマーク実装対と類似度が低いコード片であっても，低速コードパターンを含んでいるものも検出したことを確認した．

以上から，ソフトウェアの進化に伴う規模の増大が性能低下を招く一因となる\cite{emprical_perfomancebug}中で，本手法における，マイクロベンチマーク実装対の構造的差分に着目した低速コードパターンの作成，および，CodeQLを用いた構造的な特徴を反映させた静的解析が，潜在的な高速化修正候補の検出において有効であることが示唆される．


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{考察}
\label{chap:consideration}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{類似度評価の解釈と限界}

本研究における類似度評価結果の解釈と，本手法の限界について考察する．
実プロジェクトのソースコードに対する検出結果について，類似度スコアの高低にかかわらず，対象とする低速コードパターンの構造自体はいずれのコード片にも含まれていた．
これは，CodeQLを用いたクエリが，ソースコードのコンテキストに左右されず目的の構造を捕捉できていることを示している．

しかし，検出結果の詳細な目視調査により，類似度が高い検出事例において，構造は合致しているものの「妥当な検出結果」の定義を満たさない，すなわちパターンの元となったマイクロベンチマークの知見と意味的に等価ではない事例を確認した．

Listing~\ref{ID3_FP}に，パターンID \ref{ptn:hasOwnProperty}“\texttt{if}文に\texttt{.hasOwnProperty()}呼び出しを持つ\texttt{for-in}文”における意味的に等価ではない検出例を挙げる．
当該箇所はクエリが規定する構造を完全に満たしており，類似度スコアも $0.39$ と高値を示した．しかし，パターンの元コードである Listing~\ref{ID3_origin} と比較して，\texttt{.hasOwnProperty()} の処理対象となるオブジェクトが \texttt{for-in} 文で反復される要素とは無関係なデータであり，低速な実装を高速な実装へ置き換えるというマイクロベンチマークの知見が成立しない検出結果である．

意味的に等価ではない検出結果に対して，高い類似度スコアとなった要因として，類似度算出に用いたCode2Vecの特性が考えられる．比較元となるマイクロベンチマークのコード片は極めて短いため，分散表現の生成において識別子名（変数名）やコードの長さに影響を受けやすく，本来重要であるべき「変数間のデータフローや依存関係」といった意味的な等価性を完全には反映できていない可能性が示唆された．

以上の分析から，本研究の提案手法は，実プロジェクトの中から特定の構造を抽出する「低速コードの構造的検出」については，その妥当性を実証できたと評価できる．
しかし，前述の定義における「実装方法の合致」までを保証する「意味的な等価性の検証」については依然として課題が残る．
したがって，提案手法の精度向上のためには，構造的一致の判定に加え，処理対象となるデータの依存関係やセマンティクスを検証する枠組みの導入が必要であると考えられる．


%----------------------------------
% 1行目のthis.defaultsのみ背景色をつけるために一部改変
\begin{lstlisting}[caption=意味的に等価ではない検出例, label=ID3_FP, captionpos=t, columns=flexible, literate=
{this.defaults_target}{{\textcolor{black}{\colorbox{lightred}{this.defaults}}}}{13}
{options}{{\textcolor{black}{\colorbox{lightred}{options}}}}{7}
]
for (var key in this.defaults_target) {
  if (!options.hasOwnProperty(key)) {
    attr[key] = this.defaults[key];
  }
}
\end{lstlisting}
%----------------------------------


\section{修正適用による実行速度変化から得られる示唆}

\todo{実験頑張りましょう}
\todo{引用：Utilizing Performance Unit Tests To Increase Performance Awareness}


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{妥当性の脅威}
\label{chap:threat}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{内的妥当性}

本研究では，低速コードの特徴抽出をGumTreeによる差分解析に依存している．したがって，抽出された差分が必ずしも低速コードの特徴を正確に表現していない可能性がある．本研究では，差分から得られた要素を目視により確認し，実装例と照合した上でパターンを作成しているため，その影響は小さいと考えられる．

本研究で利用したマイクロベンチマーク共有サービスであるJsPerfは2020年にサービスを終了しており，当時の高速実装が現在においても最適であるとは限らない．この点については，関連研究\cite{omori}においても同様の指摘がなされている．

本研究における類似度計測においては，コード片のベクトル化にCode2Vecを利用している．Code2VecはJavaおよびC\#を対象としているため，それらの言語への利用における精度と差異が生じる可能性がある．本研究ではJavaScript対応かつマイクロベンチマークをもとに学習された学習モデル\cite{saiki}を使用することで，この影響を抑えるよう努めた．
なお，分散表現の取得における内部処理において，学習の設定に応じて，コード片のトークン数や抽象構文木における構造における制限，分散表現化に利用する特徴のフィルタリングが発生するため，コード長の大きいコード片については，分散表現において，十分にその特徴を反映できていない可能性がある．変数名の抽象化や，学習モデルの再構築によって改善が期待されるものの，開発初期における性能ボトルネックの検出が本研究の目的であることから，本研究において，長大なコードへの対応に関する影響は小さいと考える．


\section{外的妥当性}

本研究におけるケーススタディでは，時間的制約のため，GitHub上のスター数上位のリポジトリに対象を限定して分析を行った．そのため，結果の一般性は限定的である可能性がある．
特にスター数の多いリポジトリは，既に十分に最適化・保守が行われていることが多いため，このようなリポジトリにおける検出結果は，一般的な開発段階のソフトウェアとは異なる可能性がある．

本研究では，低速コードパターンを6個作成し，ケーススタディを実施した．また，類似度計測ではそのうち1つのパターンについての検証となっている．異なるパターンに対しては，同様の手法で実験を行う必要があり，複数パターンに基づく評価によって，提案手法の汎用性および有効性をさらに検証することが今後の課題である．


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{おわりに}
\label{chap:finish}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\todo{今後の展望をしっかりと}
本研究では，ソフトウェア中に潜在する，修正によって実行速度の向上が期待されるコード片を検出することを目的とした．そこで，繰り返し処理にターゲットを絞り，マイクロベンチマーク共有サービスで提供されるベンチマーク実装対の構造的差分から低速コードパターンを抽出し，静的解析エンジンであるCodeQLを用いて実際のソースコード中から低速コードを検出する手法を提案した．

ケーススタディとして，6件の低速コードパターンおよび，それぞれに対応するCodeQLクエリを作成し，GitHub上のリポジトリ1,000件を対象に検出する実験を行った．その結果，提案手法によって作成した低速コードパターンが実際のソースコード中から検出された．したがって，マイクロベンチマーク共有サービス由来の構造的差分が，実際のソースコードにおける処理構造を適切に捉えていることを確認した．また，低速コードパターンの検出において，CodeQLによる静的検出が有効であることを確認した．

さらに，提案手法によって検出されたコード片に対して，Code2Vecを用いて分散表現を取得し，コサイン類似度による評価および目視調査を実施した．その結果，CodeQLによって検出されたコード片はいずれも低速コードパターンを含んでおり，作成したクエリが妥当であることを確認した．一方で，コサイン類似度は構文的な類似性に加え，コードの長さや変数名などの表層的な特徴に影響される傾向が見られた．

% なお，データセット中のリポジトリにおいて検出された，コサイン類似度の高いコード片は，マイクロベンチマークのソースコードとコード長や処理構造が類似し，表層的な特徴による影響が小さいことから，マイクロベンチマークを用いた性能改善の容易性を示す指標として有用である可能性が示唆された．

今後の課題として，繰り返し処理に限らず，低速コードパターン作成における差分抽出や低速コードの特徴抽出の手法，およびクエリ作成方法の拡張を進めることが挙げられる．また，検出結果に対して，コサイン類似度や，その他の評価指標の検討を通じて，より意味的な類似性を捉えられる指標の構築を目指す．
これらを元に．高速化修正の可否および，修正の効果，影響範囲の推定を行うことで，より効果的な性能ボトルネック検出および修正候補の提示手法の構築を目指す．


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 謝辞
%%
\begin{acknowledgements}
感謝します．
\end{acknowledgements}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 参考文献
%%
\bibliographystyle{junsrt}
\bibliography{@Bachelor2025_Noguchi/reference}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 付録
%%
% \appendix
% 
% \chapter{サンプルプログラム}
% 
% プログラムリストや実行結果など，本論を補足する上で必要と思われるものが
% あれば付録として付ける．
% 
% {
% \footnotesize
% \begin{verbatim}
% #include <stdio.h>
% int main(void)
% {
%     printf("Hello, World!\n");
%     return 0;
% }
% \end{verbatim}
% }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
