\documentclass[11pt]{jreport}
\usepackage{wuse_thesis}
\usepackage{indentfirst}
\usepackage{url}	% \url{}コマンド用．URLを表示する際に便利
\usepackage{xcolor}
\usepackage{listings}
\usepackage{amsmath,amssymb}
\usepackage{tabularx}
\usepackage{stfloats}
\usepackage{booktabs}
\usepackage{threeparttable}
\usepackage{caption}
\usepackage[dvipdfmx]{graphicx}
%\usepackage{graphicx}  % ←graphicx.styを用いてEPSを取り込む場合有効にする
			% 他のパッケージ・スタイルを使う場合には適宜追加

\newcommand{\todo}[1]{\colorbox{yellow}{{\bf TODO}:}{\color{red} {\textbf{[#1]}}}}
\newcommand{\memo}[1]{\colorbox{magenta!30}{{\bf MEMO}:}{\color{red!50} {\textbf{[#1]}}}}
\newcommand{\ihara}[1]{\colorbox{green}{{\bf IHARA}:}{\color{blue} {\textbf{[#1]}}}}
\newcounter{patternID}

% コード例を載せるためのあれこれ
\definecolor{lightred}{RGB}{255,230,230}
\definecolor{lightgreen}{RGB}{230,255,230}

\lstset{
    basicstyle=\small\ttfamily,
    abovecaptionskip=0pt,
    captionpos=b,
    frame=tb,
    framexleftmargin=2em,
    numbers=left,
    numberstyle={\scriptsize},
    xleftmargin=\parindent,
    escapechar=|
}

%ListingのキャプションがFigureになってしまうのをListingに直すコマンド
\usepackage{caption}
\makeatletter
\let\MYcaption\@makecaption
\makeatother
\usepackage{caption}
\makeatletter
\let\@makecaption\MYcaption
\makeatother

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 主に表紙を作成するための情報
%%

%%  タイトル(修論の場合は英語表記も指定)
\title{修正による部分的な性能向上が期待される\\
       マイクロベンチマークにおける低速コードの検出}
%\etitle{Test\\Test\\Test}

%%  著者名(修論の場合は英語表記も指定)
\author{野口 隼杜}
%\eauthor{Akinori Ihara}

%% 卒業論文・修士論文(以下のどちらかを選択)
\bachelar	% 卒業論文(4年生用)

%%  学科・クラスタ
\department{システム工}

%%  学生番号
\studentid{60276185}

%%  卒業年度
\gyear{2025}		% 提出年が2022年なら，2021年度

%%  論文提出日
\date{2026年2月10日}	% 修士の場合は月(2021年2月)までとし，英語表記も指定
%\edate{February 2021}	% 修士の場合，こちら(英語表記)も有効化

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

%%
%%  概要
%%
\begin{abstract}
\todo{あとで作る}

「和歌山大学システム工学部卒業論文/
  大学院システム工学研究科修士論文用スタイルファイル」
は，
\begin{quote}
  \begin{description}
    \item[\tt wuse\_thesis.sty:] 卒業/修士論文用スタイルファイル
    \item[\tt thesis\_sample.tex:] スタイルファイル利用例
  \end{description}
\end{quote}
からなる．

なお，この卒業論文用スタイルファイル(p\LaTeX 版)に関する質問は，
メールにて
\begin{quote}
ihara@wakayama-u.ac.jp
\end{quote}
まで．

\end{abstract}

%%  目次
\tableofcontents

%%  図目次 (図目次をいれたければ以下のコメントをはずす)
%\listoffigures

%%  表目次 (表目次をいれたければ以下のコメントをはずす)
%\listoftables

\newpage
\pagenumbering{arabic}	% 以降のページ番号を算用数字に

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%%  本文はここから
%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{はじめに}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\todo{研究背景・研究課題・目的および本研究の貢献・論文構成を決定してから作成}



%  また，保守性や可読性など，他のプログラム品質に否定的な影響を与えることもある\cite{negative}．したがって，性能効率性を向上するソースコードへ書き換えるためには，実装が進むほどに開発者に対して広範な知識や経験を要するようになることが考えられる．そのため，ソフトウェアの性能効率性を，実装途中の早期の段階で見積もり，性能低下の原因となるボトルネックを検出することは，性能効率性の改善にかかる修正工数を小さくできる．





% % ソースコード「片」で統一
% 本研究では，ソフトウェア中に潜在する，修正することで実行速度の向上が期待されるソースコード片の検出を目的とする．具体的には，マイクロベンチマーク共有サービスでベンチマークとして比較されたソースコード片の構造的な差分から低速コードパターンを作成する．作成した低速コードパターンを利用し，静的解析エンジンであるCodeQL\footnote{\url{https://codeql.github.com/}}\cite{ql}を用いて，ソースコード中から低速なソースコード片を検出する．CodeQLは，マイクロベンチマーク共有サービスで公開されるソースコード片とは入出力が異なっていても，構造が類似するソースコードの検出が期待される．
% 提案手法は，動的解析に依存せずに潜在的な性能効率性に寄与するボトルネックを実装初期段階で検出できる．

% 続く\ref{chap:background}章では，本研究で利用するマイクロベンチマーク共有サービスにおけるマイクロベンチマークの特徴，および関連研究を紹介し，本研究の立ち位置を述べる． \ref{chap:pre-analysis}章で事前分析について示し， \ref{chap:approach}章では，本研究の提案手法を述べ，\ref{chap:evaluation}章で評価方法について述べる．\ref{chap:case-study}章においてケーススタディの結果を述べ，\ref{chap:discussion}章で考察と妥当性への脅威を示し，\ref{chap:summary}章で本研究をまとめる． 


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{プログラム実行速度の改善}
\label{chap:background}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

% -----------------------------------------
\section{ソフトウェアの性能効率性と部分的な最適化}
% -----------------------------------------

\todo{\textbf{はじめに}との棲み分けを考える}
ソフトウェアの性能効率性は，JIS X 25010:2013（ISO/IEC 25010:2011）にシステム/ソフトウェア製品品質を図る尺度の一つとして記述され，システム全体の品質，さらにはユーザ体験や運用コストに直結する重要な要素である\cite{performance1}\cite{performance2}\cite{negative}．
一般に，性能効率性の向上にはプロファイラといった動的解析を用いてボトルネックの特定が行われる．しかし、システムレベルの大規模なテストによる性能評価は，実行環境の構築や測定に多大なコストを要する\todo{引用}だけでなく，開発の後期工程で問題が発覚した場合，修正による影響範囲が広く\todo{引用}，実装が進むほどに開発者に対して広範な知識や経験を要するようになる．また，性能効率性を向上するためのプログラム変更では，可読性や保守性といった他の品質を損なうリスク（性能改善と他品質のトレードオフ）も指摘されている\cite{negative}．

これに対し，計算機能力やシステム設計の改善，アルゴリズムの抜本的な変更といった大規模な最適化だけでなく，既存のコード断片をより効率的な実装へ置き換える「部分的な最適化」を積み重ねることによって性能効率性の向上を実現することも多い．
% \todo{↓書くなら参考文献欲しい}
% 特に、ループ処理やデータ構造操作のように実行回数が多い箇所では、わずかな実装差が全体の実行時間に影響を与えることがある。このようなミクロな性能差を把握し、適切に改善することは、現実的な性能改善戦略の一つである．実際に，
Webアプリケーション開発では，数行のソースコード修正によって最適化した結果，プログラムの実行時間が25\%から70\%高速化している\cite{jsRefac}．
また，プログラムを構成する関数やメソッドなどの最小単位が正しく動作するかを検証するユニットテストを実行することや，ユニットテストをもとにしたベンチマークを作成することで、コンポーネント単位の微小な範囲でパフォーマンスの変化を早期に評価することが可能となる\todo{引用}．

% 参考文献候補リスト
% 大規模なシステムテストで性能テストやってますよ
% R. Gao, Z. M. Jiang, C. Barna, and M. Litoiu, “A framework to evaluate the effectiveness of different load testing analysis techniques,” in 2016 IEEE International Conference on Software Testing, Verification and Validation, ICST 2016, Chicago, IL, USA, April 11-15, 2016, 2016, pp.22–32.
%  H. Malik, H. Hemmati, and A. E. Hassan, “Automatic detection of performance deviations in the load testing of large scale systems,” in 35th International Conference on Software Engineering, ICSE ’13, San Francisco, CA, USA, May 18-26, 2013. IEEE Computer Society, 2013, pp. 1012–1021.
% T. H. D. Nguyen, B. Adams, Z. M. Jiang, A. E. Hassan, M. N. Nasser, and P. Flora, “Automated verification of load tests using control charts,” in 18th Asia Pacific Software Engineering Conference, APSEC 2011, Ho Chi Minh, Vietnam, December 5-8, 2011. IEEE Computer Society, 2011, pp. 282–289.
% システムテストはコストめっちゃかかりますよ
 % J. Chen, W. Shang, A. E. Hassan, Y. Wang, and J. Lin, “An experience report of generating load tests using log-recovered workloads at varying granularities of user behaviour,” in 34th IEEE/ACM International Conference on Automated Software Engineering, ASE 2019, San Diego, CA, USA, November 11-15, 2019. IEEE, 2019, pp. 669–681.
% これに対応するため，ユニットテストやマイクロベンチマークでコンポーネントレベルの小さな範囲でパフォーマンス測ってますよ（動的？ちゃんと見る）
% J. Chen and W. Shang, “An exploratory study of performance regression introducing code changes,” in 2017 IEEE International Conference on Software Maintenance and Evolution, ICSME 2017, Shanghai, China, September 17-22, 2017. IEEE Computer Society, 2017, pp. 341–352.
% Z. Ding, J. Chen, and W. Shang, “Towards the use of the readily available
% tests from the release pipeline as performance tests: are we there yet?” in ICSE ’20: 42nd International Conference on Software Engineering, Seoul, South Korea, 27 June - 19 July, 2020. ACM, 2020, pp. 1435–1446.
% V. Horky, P. Libic, L. Marek, A. Steinhauser, and P. Tuma, “Utilizing performance unit tests to increase performance awareness,” in Proceedings of the 6th ACM/SPEC International Conference on Performance Engineering, Austin, TX, USA, January 31 - February 4, 2015. ACM,2015, pp. 289–300.
% D. G. Reichelt, S. Kuhne, and W. Hasselbring, “Peass: A tool for ¨identifying performance changes at code level,” in 34th IEEE/ACM International Conference on Automated Software Engineering, ASE 2019, San Diego, CA, USA, November 11-15, 2019. IEEE, 2019, pp.1146–1149
% ↓マイクロベンチマークも使ってるやつ
% M. Jangali, Y. Tang, N. Alexandersson, P. Leitner, J. Yang, and W. Shang, “Automated generation and evaluation of jmh microbenchmark suites from unit tests,” IEEE Transactions on Software Engineering, 2022.
% C. Laaber and P. Leitner, “An evaluation of open-source software microbenchmark suites for continuous performance assessment,” in Proceedings of the 15th International Conference on Mining Software Repositories, MSR 2018, Gothenburg, Sweden, May 28-29, 2018. ACM, 2018, pp. 119–130.（ソフトウェアマイクロベンチマークスイートの評価に関してLaaberとLeitner[41]は、ほとんどのJavaプロジェクトで50%を超える（すなわち、1.5倍遅い）速度低下はしばしば確実に検出できると観察しています。）

% -----------------------------------------
\section{マイクロベンチマーク共有サービス}
% -----------------------------------------

実装段階において，特定の処理に対する複数の実装方法の性能を定量的に比較する手法として，マイクロベンチマークが活用されている．マイクロベンチマークは，機能的に等価な複数のソースコード断片に対して実行時間を測定し、その効率性を相対的に評価するものである。

マイクロベンチマーク共有サービスは，マイクロベンチマークを開発者がWeb上で実行・共有するプラットフォームとして機能するオンラインサービスである．例として，JavaScript言語を対象としたJsPerf\footnote{JsPerf: \url{https://jsperf.app/}}やMeasureThat.net\footnote{MeasureThat.net: \url{https://measurethat.net/}}が挙げられる．これらのサービスは，ブラウザ上での実行環境を提供するとともに，世界中の開発者が投稿したソースコード断片とその測定結果を公開している．

図\ref{fig:jsPerf}に，JsPerf上で実際に投稿されているマイクロベンチマークの例を示す．
マイクロベンチマーク共有サービスにおける各ベンチマークは，1つのセットアッププログラムと，1つ以上のテストプログラムから構成される．図上部に示すセットアッププログラムは，検証対象のソースコードで共通して利用される変数や関数の初期化などが行われる．一方，図下部に示すテストプログラムでは，同一の機能を異なる方法で実装したソースコード片が複数記述され，それぞれの実行速度をの計測，および比較ができる．
このようなマイクロベンチマークは，データ構造や制御構文の選択，メソッド呼び出しの方法などに多様性が見られ，実行速度の差とその要因となる実装方法を捉えることができる．

実際の開発現場においても，GitHub上のプルリクエスト等において，提案する改善案の正当性を示すエビデンスとしてこれら共有サービスのURLが引用される事例が確認されており\cite{saiki},マイクロベンチマーク共有サービスは「効率的な実装パターン」を示すデータベースとして機能していることが示唆される．

% 本研究では，このようなマイクロベンチマーク共有サービス上の実装対を，性能効率性，特に実行速度に影響を与える構造的特徴を分析および抽出するために利用する．

%----------------------
\begin{figure}[!h]
    \centering
    \includegraphics[width=0.6\linewidth]{./fig/jsPerf_example.pdf}
    \caption{マイクロベンチマーク共有サービスの投稿例\protect\footnotemark}
    \label{fig:jsPerf}
\end{figure}

\footnotetext{\url{https://jsperf.app/qiwudo}}
%----------------------

% -----------------------------------------
\section{低速箇所の検出における課題}
% -----------------------------------------

ここで，既存の実装から性能向上の余地がある低速な箇所を特定する際，従来の性能評価手法における課題と，その解決策として期待されるマイクロベンチマーク共有サービスの利用における特有の課題について述べる．

従来の性能評価手法における主要な課題は，その多くがプログラムの動的実行に依存している点である．プロファイラやマイクロベンチマークを用いた手法は，実際の動作状況や実行時間を計測することでボトルネックを特定する．そのため，解析対象となるプログラムがコンパイル可能であり，かつ実行に必要な依存ライブラリやテストデータが整備された「実行可能状態」にあることが前提となる．

しかし、開発の初期段階やリファクタリングの検討段階において，断片的なソースコードに対して即座に実行環境を構築することは容易ではない．また，実装が進むにつれて性能改善のためのプログラム変更は複雑化する傾向にあることが示されている\cite{complicate}．したがって，動的解析を利用する従来の手法では，実装の最中にリアルタイムで低速な記述を検出し，開発を支援することが困難であるという課題がある．

これに対し，マイクロベンチマーク共有サービスを活用するアプローチは，事前に第三者によって実行速度が評価された実装方法を利用できるため，自身のプログラムに対する動的実行への依存を排除，あるいは最小化できる可能性がある．

しかし，同サービスに保存されたマイクロベンチマークを実際の開発に適用するには，サービス特有の性質に起因する課題が存在する．共有サービス上のコード片は，不特定の開発者が特定の文脈で局所的な比較を目的に作成したものである．そのため，
% 特定の実行環境や入力データに対してのみ有意な差が生じる「コンテキストへの依存」や，
測定用の補助的な変数宣言や処理など，実行速度の差を生み出す要因とは無関係な記述が混在している．

マイクロベンチマークという極めて小さなコード片において，低速の本質的な要因が構造化されていないため，自身のプログラム中から類似の箇所を特定し，改善案を適応することは容易ではない．したがって，膨大な公開データから汎用的な「低速な要因」を抽出・検出するためには，ソースコードの構造的・意味的な特徴を捉え，コード片から本質的なパターンを識別する解析手法が必要となる．


% -----------------------------------------
\section{関連研究}
% -----------------------------------------

\subsection{実行速度向上を目的としたリファクタリングの調査}

Selakovicら\cite{jsRefac}は，JavaScriptを利用しているプロジェクトにおいて，開発者が高速化のために行ったリファクタリングを調査している．調査の結果，開発者は10行程度の小さい範囲の修正によって高速化への対処を行なっていることを明らかにした．この結果から，マイクロベンチマークで評価される短いソースコード片を利用した修正が，ソフトウェア高速化につながっていることを示唆していると考えられる，また，\cite{jsRefac}では，JavaScriptプロジェクトの解析によって10件の頻出する高速化修正パターンを作成している．この改良パターンを用いた自動修正は一定の高速化効果を示しているが，該当箇所の特定における制約などから，広範な適用には至っていない．

\subsection{静的解析と動的解析を用いた性能ボトルネックの検出}

Turcotte ら\cite{DrAsync}は，JavaScript 言語における非同期処理に注目し，ソースコードの目視調査やStack Overflow上の知見から，より効率的・簡潔な記述方法が存在する実装方法を性能アンチパターンとして定義し，静的解析エンジンであるCodeQL\cite{ql}と動的解析による実行頻度や呼び出し関係の監視を組み合わせて，修正可能な性能アンチパターンの検出手法の提案した．

非同期処理という特定のドメインに対する手動定義されたパターンに限定しているものの，静的解析による広範な実装形態への適用を実現している．本研究では，マイクロベンチマーク共有サービスに保存された多様な実装対から，自動的にパターンを抽出・生成することを目指す．これにより，静的検出アプローチを継承・発展させつつ，より汎用的な性能改善支援を提供する．

% -----------------------------------------
\section{本研究の位置付け}
% -----------------------------------------

本研究では，修正によって実行速度の向上が期待される箇所を，開発の早期段階で静的に検出する手法を確立することを目的とし，マイクロベンチマーク共有サービスにおいて実行速度が評価された実装対から，構文構造をデータ構造に変換した抽象構文木における構造的な差分をもとに，静的な解析に利用できる汎用的な「低速コードパターン」を作成し，その検出を行う手法を提案する．
マイクロベンチマーク共有サービスで示される多様な実装方法と動的解析の結果（実行速度の差異）から，静的なパターンへと変換することで，より多様な低速要因を抽出し，開発者がプログラムを動作させる前の実装の初期段階において、静的解析のみで潜在的な高速化修正候補を検出することが可能となる．


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{事前分析：マイクロベンチマークにおける低速コードの特徴}
\label{chap:pre-analysis}
%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{データセット}

本研究では，大森ら\cite{omori}が作成したデータセットを分析対象とする．当該データセットは，JavaScript言語を対象としたマイクロベンチマーク共有サービスJsPerfにおいて，公開されているマイクロベンチマークの中で，実行速度に有意差があり，外的振る舞いが等しいことが検証された29,809件の実装対である．以降，分析対象とする，マイクロベンチマークで比較されたソースコード片の対をマイクロベンチマーク実装対，各実装対において，実行速度が遅いコードを低速コード，実行時間が速いコードを高速コードとする．


\section{抽象構文木に基づく実装方法の分析}

低速コードパターンを抽出するための指針を獲得することを目的とし，マイクロベンチマーク実装対における構造的特徴に関する調査を行った．
具体的には，マイクロベンチマーク実装対のソースコードを抽象構文木に変換し，各コード断片に含まれる構文要素の分析を実施した．その結果，11,893件の実装対（全実装対の39.9\%）において、繰り返し処理に関連する構文（JavaScriptにおける \texttt{for}，\texttt{for-of}，\texttt{for-in}，\texttt{while}，および \texttt{do-while}）が含まれていることがわかった．\memo{パーサーの説明必要？}

この結果から，繰り返し処理を含むマイクロベンチマーク実装対11,893件について，さらに詳細な差分解析および目視調査を行った．具体的には実装対を構成する2つのコード片間の抽象構文木における構造的な差分を抽出し，差分と元の実装対の特徴について目視で確認を行った．
次節において，構造的差分および目視調査において確認したマイクロベンチマーク実装対のもつ特徴について具体例を示す．


\section{繰り返し処理を含む低速コードの主要パターン}

マイクロベンチマーク実装対において確認した，実行速度に差が生じる繰り返し処理の使用パターンとその特徴について，具体例として，Listing~\ref{diff-loop}，Listing~\ref{diff-inloop}，Listing~\ref{diff-method}に示す．

Listing~\ref{diff-loop}は，それぞれ\texttt{for-in}文を用いて配列に含まれる要素にアクセスする実装と，同様の処理を\texttt{for}文で実装したソースコード片である．ここで示すパターンは，実行時間の差が，繰り返し処理を行う構文そのものが異なることに起因する実装対である．

%----------------------------------
\begin{lstlisting}[caption=繰り返し処理自体の実装方法が異なる実装対, label=diff-loop, captionpos=t, columns=flexible]
// slow
for (key in VAR_1) {
    if (!VAR_1.hasOwnProperty(key)) continue;
    VAR_2 = VAR_1[key];
}

// fast
for (var VAR_8=0; VAR_8<VAR_1.length; ++VAR_8) {
    VAR_2 = VAR_1[VAR_8];
}
\end{lstlisting}
%----------------------------------

Listing~\ref{diff-inloop}は，それぞれ\texttt{for}文内で \texttt{concat}メソッド，\texttt{push}メソッドを用いている実装対である．これは，同一の繰り返し処理を行う構文において，その繰り返し内部で実行する処理の記述方法が異なることによって実行速度の差が生じている実装対である．

%----------------------------------
\begin{lstlisting}[caption=繰り返し内部で実行する処理の記述方法が異なる実装対, label=diff-inloop, captionpos=t, columns=flexible]
// slow
for (var VAR_2=0; VAR_2<5000; VAR_2++)
    VAR_1 = VAR_1.concat([\"1\", \"2\"]);

// fast
for (var VAR_2=0; VAR_2<5000; VAR_2++)
    VAR_1.push(\"1\", \"2\");
\end{lstlisting}
%----------------------------------

Listing~\ref{diff-method}は，繰り返し処理を\texttt{forEach}メソッドで実装したコード片と\texttt{for-of}文で実装したコード片である．これは，メソッドによる処理とそれに代替する繰り返し処理について比較した実装対であり，メソッド呼び出しのオーバーヘッドや内部的な最適化の有無により実行速度の差が生じていることが示唆される実装対である．

%----------------------------------
\begin{lstlisting}[caption=メソッド処理と代替する繰り返し処理に関する実装対, label=diff-method, captionpos=t, columns=flexible]
// slow
var VAR_5 = new Set(VAR_2);
VAR_5.forEach(VAR_6 => {});

// fast
for (let VAR_7 of VAR_2) {}
\end{lstlisting}
%----------------------------------

これらの結果から，マイクロベンチマーク実装対において，抽象構文木の構造的差分の中に，性能低下の要因となる特徴的なノード構成が含まれていることを確認したとともに，繰り返し処理および繰り返す処理の記述内容の違いが性能差の要因の1つとして存在することを確認した．
以上の事前分析の結果に基づき，本研究では，繰り返し処理に焦点を当て，マイクロベンチマーク実装対の構造的差分を解析することで低速コードの特徴を抽出し，次章以降で述べる低速コードパターンの作成および静的検出に利用する．


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{構造的差分に基づく低速コードパターンの検出手法}
\label{chap:approach}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{概要}
\todo{繰り返し処理に注目して差分とってノード取って組み合わせてパターン}
\todo{パターンをクエリに変換して検出実行}

\section{分析対象となるマイクロベンチマーク実装対の収集}

% \ref{chap:pre-analysis}章より，本研究では，従来研究\cite{omori}で対象とするマイクロベンチマークの中で，比較されるソースコードに繰り返し処理を含むマイクロベンチマーク実装対を収集する．

事前分析に基づき，本研究では，データセットにおいてコード片に繰り返し処理を含むマイクロベンチマーク実装対を対象として収集する．
\ref{chap:pre-analysis}章と同様に，29,809件のマイクロベンチマーク実装対について，各実装対のソースコードを抽象構文木へ変換した．次に，繰り返し処理である構文のノードを含んでいるかどうかを確認し，結果として 11,889件の実装対を収集した．

\section{低速コードパターンの作成}
\subsection{差分解析による低速コードの特徴抽出}\label{approach:extract}

収集したベンチマーク実装対において，低速コードから高速コードへの変更を想定し，変換に必要な操作とその構造的差分を収集する．実装対間の差分抽出には，GumTree\cite{gumtree}を使用した．
収集した要素のうち，低速コードから削除または更新された要素を抽出する．これらの要素を，低速コード特有の処理や構造を示す要素であるとして，低速コードの特徴候補として収集する．

例として，Listing \ref{diff-loop} に示す低速コードと高速コードの実装対において，この処理を実施した結果をListing~\ref{candidates}に示す．この処理によって，Listing~\ref{candidates}における背景色のついた要素が低速コードの特徴候補として収集できる．

次に，収集した低速コードの特徴候補の中から，プログラムの振る舞いに意味的な影響を与える要素として，繰り返し処理，メソッド呼び出し，配列・オブジェクト操作を抽出・統合する．

図\ref{fig:slow_pattern}は，Listing~\ref{candidates}から作成した低速コードパターンを示す．当該パターンは，if 文内で.hasOwnProperty() を呼び出す for-in 文という特徴を有することが読み取れる．

%----------------------------------
\begin{lstlisting}[caption=Characteristic Candidates for Slow Code, label=candidates, captionpos=t, columns=flexible, literate=
    {for}{{\textcolor{black}{\colorbox{lightred}{for}}}}{3}
    {key}{{\textcolor{black}{\colorbox{lightred}{key}}}}{3}
    {in }{{\textcolor{black}{\colorbox{lightred}{in}}\kern0.5em}}{3}
    {VAR\_1}{{\textcolor{black}{\colorbox{lightred}{VAR\_1}}}}{5}
    {if}{{\textcolor{black}{\colorbox{lightred}{if}}}}{2}
    {!}{{\textcolor{black}{\colorbox{lightred}{!}}}}{1}
    {hasOwnProperty}{{\textcolor{black}{\colorbox{lightred}{hasOwnProperty}}}}{15}
    {continue}{{\textcolor{black}{\colorbox{lightred}{continue}}}}{8}
    {VAR\_1\_}{{\textcolor{black}{VAR\_1}}}{6}
]
for (key in VAR_1) {
  if(! VAR_1.hasOwnProperty(key))continue;
  VAR_2 = VAR_1_[key];
}
\end{lstlisting}
%----------------------------------

\todo{後で直す}
%----------------------
\begin{figure}[!h]
    \centering
    \includegraphics[width=1.0\linewidth]{./fig/slow_pattern.pdf}
    \caption{低速コードパターン例}
    \label{fig:slow_pattern}
\end{figure}
%----------------------


\subsection{低速コードパターンの定義}

% 

\ref{approach:extract}節で述べた手法に基づき，収集したマイクロベンチマーク実装対に対して構造的差分解析を適用し，重複する特徴を集約した．次に，集約された各特徴が，元のマイクロベンチマーク実装対における低速な要因を反映しているかを確認するため，元の実装対と抽出された構造的特徴との対応関係について目視調査を行い，繰り返し処理における低速な要因を適切に表現していると判断した6種類の低速コードパターンを定義した．

表\ref{tab:slow_code_patterns}は，作成した6パターンと，各パターンを持つマイクロベンチマーク実装対の数（元実装対数）を示す．\todo{検索結果をどこに載せるか決める}


\section{CodeQLによる低速コードパターンの静的検出}
\subsection{CodeQL}
\todo{引用}
本研究では，定義した6つの低速コードパターンを実プロジェクトから検出するために静的解析エンジンであるCodeQLを用いる．CodeQLは，GitHub社が開発したコード解析プラットフォームであり，プログラムの構造的・意味的な探索を可能にするツールである．

CodeQLは，対象となるソースコードを解析し，抽象構文木，制御フロー，およびデータフローの情報を含むリレーショナルデータベースを構築する．これに対し，論理プログラミング言語であるQL言語を用いてクエリを記述することで，このデータベースから特定のパターンに合致するコード断片を検索できる．

なお，本研究においては抽象構文木に基づく構造情報をもとに作成した低速コードパターンの検出において，静的解析であり，構造情報を参照して検索できる点でCodeQLを採用した．


\subsection{低速コードパターンからCodeQLクエリへの変換}

6つの低速コードパターンをCodeQLで検出可能な形式に変換するため，各パターンの構造的特徴に基づいたQLクエリを手作業で作成した．

% 
\todo{具体例で説明}
具体的には、パターンの核となるASTノード（例：ForInStatement）をターゲットとし、その周囲のコンテキストや特定のノード構成を抽出条件として定義する。

以下に、具体的な検出パターンのクエリ構造とその適用例を示す。 （ここで説明）

このように、作成したクエリを対象プロジェクトのCodeQLデータベースに対して実行することで、低速な実装方法が用いられている箇所を自動的に特定し、開発者へ修正を促すことが可能となる。
% 


\subsection{作成したクエリの妥当性検証}

\todo{実験設計の説明}
\todo{適合率再現率の説明と算出式（そもそも載せないという選択肢）}
作成したクエリの妥当性を検証するために，全11,889件のベンチマーク実装対を対象として検出数を調査した．結果は表\ref{tab:slow_code_patterns}の「検索結果」に示す．検索結果には，各パターンの作成に使用したベンチマークが全て含まれていたため，再現率は100\%となり，作成したクエリの妥当性が確認できた．一方で，適合率は6.9\%～47.4\%に留まった．しかし，各パターンの作成に使用したベンチマーク以外にも，クエリの示すパターンを含む実装対は多数存在するため，必ずしもクエリの精度が低いことを意味するものではない．ただし，GitHub上のリポジトリを対象として同様の検索を行う場合には，対象となる低速コードパターンに対して，偽陽性となるソースコード片が一定数検出される可能性がある．

%----------------------¬
\begin{table}[!h]
    \centering
    \caption{低速コードパターン}
    \label{tab:slow_code_patterns}
    \setcounter{patternID}{0} % 表が始まる前にカウンタを0にリセット
    \begin{threeparttable}
        \begin{tabular}{clrr}
            \toprule
            \textbf{ID} & \textbf{特徴} & \textbf{元実装対数\tnote{*}} & \textbf{検索結果} \\
            \midrule
            
            \refstepcounter{patternID}\label{ptn:for-in}
            \thepatternID & \texttt{for-in}文 & 534 & 1011 \\
            
            \refstepcounter{patternID}\label{ptn:forEach}
            \thepatternID & \texttt{.forEach()}呼び出し & 194 & 364 \\
            
            \refstepcounter{patternID}\label{ptn:hasOwnProperty}
            \thepatternID & \texttt{if}文に\texttt{.hasOwnProperty()}呼び出しを持つ\texttt{for-in}文 & 102 & 195 \\

            \refstepcounter{patternID}\label{ptn:applymap}
            \thepatternID & \texttt{.apply().map()}呼び出し & 12 & 89 \\
            
            \refstepcounter{patternID}\label{ptn:json}
            \thepatternID & \texttt{.parse(.stringify())}呼び出し & 11 & 18 \\
            
            \refstepcounter{patternID}\label{ptn:push}
                \thepatternID & \texttt{.push()}呼び出しを持つ\texttt{for-of}文 & 8 & 43\\
            \bottomrule
        \end{tabular}
        
        \begin{tablenotes}
            \raggedleft
            \item[*] 各パターンを持つマイクロベンチマーク実装対の数
        \end{tablenotes}
    \end{threeparttable}
\end{table}
%----------------------


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{類似度に基づく検出結果の順位付け}
\label{chap:similarity}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{妥当な検出結果の判定}

\todo{ここでの正解は，マイクロベンチマークにおいて実行速度が評価されている実装方法と同じ実装方法（低速コードパターン）を採用している箇所}
\todo{静的検出においては，本当の正解がわからないので正解っぽいやつを優先順位上げたい}
\todo{今回は，パターンを構造的なところで絞っているので，構造的な情報を付与した値を用いたい}

\section{ソースコード片の分散表現化}

\todo{なぜベクトル化したのか＆Code2Vecの説明（才木論文引用）}

\section{コサイン類似度による検出結果の順位づけ}

\todo{コサイン類似度の算出方法}
\todo{マイクロベンチマークに対して算出した結果をここに載せるのもあり}

%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{ケーススタディ}
\label{chap:casestudy}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{概要}

\section{実験対象}
ケーススタディとして，本研究では，分散バージョン管理システムであるGitHubで公開されているリポジトリを対象に低速コードパターンの検出を行う．
対象リポジトリは，JavaScriptを主要言語とする，最終コミットが1年以内のスター数上位1,000件のリポジトリとし，2025年10月13日時点で最新のスナップショットを分析対象とした．

\section{検出結果と類似度順位づけ}
\subsection{低速コードパターンの検出結果}

表\ref{tab:result_detect}は，表\ref{tab:slow_code_patterns}に示した各低速コードパターンの検出結果を示す．表中には，パターンID，1つ以上のソースコード片が検出されたリポジトリ数，単一リポジトリにおける最大検出数，1,000リポジトリにおける総検出数を示す．

表\ref{tab:result_detect}から，パターン間で検出数に違いはあるものの，各低速コードパターンは，48リポジトリ〜842リポジトリで検出された．表\ref{tab:slow_code_patterns}におけるID\ref{ptn:for-in}や，ID\ref{ptn:forEach}の低速コードパターンのように，マイクロベンチマーク実装対における検索結果の数が多いパターンはデータセット中のリポジトリにおいても検出数が多かった．なお，これらのパターンは一般的に利用される繰り返し処理の構文であることから，検出数が多いことは妥当であると考えられる．また，これに対し，ID\ref{ptn:push}では，マイクロベンチマーク実装対において，検索結果の数が少なかったものの，データセットにおけるリポジトリにおいては検出数が多くなった．これは，一般的に可読性が高いとされる\texttt{for-of}についての低速コードパターンであることから，実行速度以外の品質への考慮が示唆される．

%----------------------
\begin{table}[!h]
    \centering
    \caption{低速コードパターンに基づく検出結果}
    \label{tab:result_detect}
    \begin{tabular}{crrr}
        \toprule
        \textbf{ID} & \textbf{検出リポジトリ数} & \textbf{最大検出数 (件)} & \textbf{総検出数 (件)} \\
        \midrule           
        \ref{ptn:for-in} & 689 & 7,378 & 90,592 \\
        \ref{ptn:forEach} & 842 & 12,675 & 161,681 \\
        \ref{ptn:hasOwnProperty} & 308 & 1,125 & 9,516 \\
        \ref{ptn:json} & 282 & 142 & 2,684 \\
        \ref{ptn:applymap} & 48 & 12 & 138 \\
        \ref{ptn:push} & 477 & 3,351 & 30,075 \\
        \bottomrule
    \end{tabular}
\end{table}
%----------------------

%----------------------
\begin{figure}[t]
    \centering
    \includegraphics[width=1.0\linewidth]{./fig/log_ID3_spia.pdf}
    \caption{低速コードパターンID3による検出数と規模}
    \label{fig:plot_id3}
\end{figure}
%----------------------

図\ref{fig:plot_id3}は，ID\ref{ptn:hasOwnProperty}について，リポジトリ規模に対する検出数の関係を示す．横軸は各リポジトリに含まれるJavaScriptファイルの総行数，縦軸は検出数を示す．リポジトリ規模が大きくなるほど低速コードパターンの検出数が増加する傾向があり，スピアマンの順位相関係数は0.44，P値は\(5.12 \times 10^{-14} < 0.05\)より正の相関が認められる．他の低速コードパターンについても，同様の傾向が見られた．\memo{他のパターンの結果を載せる？}


\subsection{類似度に基づく検出結果の特徴分析}

\memo{他のパターンについてもやった方がいい？}
パターンID \ref{ptn:hasOwnProperty}「\texttt{if}文に\texttt{.hasOwnProperty()}呼び出しを持つ\texttt{for-in}文」を対象とした実験を示す．なお，長大，または文法的に不正なソースコード片は，分散表現取得における構文解析で失敗する．したがって検出総数9,516件中，分散表現の取得に成功した7,039件を用いる．


検出したソースコード片と，表\ref{tab:slow_code_patterns}に示すID \ref{ptn:hasOwnProperty}のパターン作成に使用した低速コード群78件を対象に，それぞれコサイン類似度を計算した結果を箱ひげ図で示す．左側の箱ひげ図（ID3検出結果）中の点は，検出した各ソースコード片別に，78件の低速コード群と総当たりでコサイン類似度を算出した平均値の分布を示す．右側の箱ひげ図（マイクロベンチマーク）中の点は，マイクロベンチマーク実装対において検出したソースコード片について，パターン作成に使用したベンチマーク実装対を除き，同様に総当たりでコサイン類似度を算出した平均値の分布を示す．なお，ID \ref{ptn:hasOwnProperty}における低速コードパターンを持つ低速コードの例は，Listing~\ref{diff-loop}に示す．\todo{マイクロベンチマークの方の結果は5章にでも載せる}

%----------------------
\begin{figure}[t]
    \centering
    \includegraphics[width=0.85\linewidth]{./fig/boxplot_compare.pdf}
    \caption{低速コードパターンID \ref{ptn:hasOwnProperty}で検出されたソースコード片とパターン元低速コードのコサイン類似度}
    \label{fig:boxplot_cosine}
\end{figure}
%----------------------

ID3検出結果の平均値は0.08，中央値は0.09である一方，マイクロベンチマークでは，平均値は0.61，中央値は0.68となった．コサイン類似度の高い検出例について，リポジトリにおけるソースコード片と，マイクロベンチマーク実装対におけるソースコード片をそれぞれ，Listing\ref{ID3_highcos}とListing\ref{MB_highcos}に示す．
それぞれのコサイン類似度の平均値は0.39，0.78である．

図\ref{fig:boxplot_cosine}に示すように，マイクロベンチマーク実装対における検出結果は，データセット中のリポジトリにおける検出結果と比べ，コサイン類似度が高い値で分布している.
なお，マイクロベンチマーク実装対においては，Listing\ref{diff-loop}とListing\ref{MB_highcos}に示す通り，変数名などが同じ規則で抽象化され，コード長も同程度であることから，比較している低速コードと非常に類似するソースコード片となっている．

リポジトリにおける類似度の高いソースコード片については，Listing\ref{ID3_highcos}に示すように，マイクロベンチマーク実装対における検出結果と同様に，比較している低速コードと，コード長および構造が類似している．使用している変数名については，短く単純な変数名が多く見られた．
一方，類似度が低いソースコード片では，様々な処理が含まれたコード長の大きいものや，変数名が長いソースコード片が多く見られた．コサイン類似度が小さいほど，検出したソースコード片の構造は比較する低速コードに対して複雑になっていく傾向があることを確認した．

目的とした低速コードパターンについては，コサイン類似度の大きさに関わらず含まれていることを確認した．しかし，\todo{主張内容の統一}
% \ref{subsection:pattern}節でも述べたように，繰り返し処理の対象パターンを含んでいたとしても，パターン作成に利用した低速コードの特徴を含まないソースコード片が検出される可能性があり，特に，類似度の低いソースコード片においては，目的とする低速コードパターンとは異なる特徴をもつソースコード片が検出されていることが示唆される．


%----------------------------------
\begin{lstlisting}[caption=リポジトリ中の高類似度検出例, label=ID3_highcos, captionpos=t, columns=flexible]
for (var key in this.defaults) {
  if (!options.hasOwnProperty(key)) {
    attr[key] = this.defaults[key];
  }
}
\end{lstlisting}
%----------------------------------


%----------------------------------
\begin{lstlisting}[caption=マイクロベンチマーク中の高類似度検出例, label=MB_highcos, captionpos=t, columns=flexible]
VAR_1 = {
  KEY_1: 5,
  KEY_2: 13,
  KEY_3: 8,
};
var VAR_2 = [];
for (var VAR_3 in VAR_1) {
  if (VAR_1.hasOwnProperty(VAR_3)) {
    VAR_2.push(VAR_1[VAR_3]);
  }
}
\end{lstlisting}
%----------------------------------

\section{CodeQLを用いた静的検出の有効性}

本研究では，提案手法により作成した低速コードパターンおよび，CodeQLを利用した検出によって，実際のソースコード中から低速コードパターンを含むソースコード片を検出した．分析の結果，リポジトリ規模が大きいほど，低速コードパターンの検出数が増加していた．開発が進み，ソフトウェアが進化する中で性能低下が引き起こされる\cite{emprical_perfomancebug}ことから，規模の肥大化に伴い低速コードパターンによって検出されるソースコード片が増加することは驚く結果ではない．また，ソフトウェア全体としてのボトルネックとなっていないのであれば，必ずしも検出数が増えることが問題とは言えない．本手法は，今後の研究で，検出したソースコード片がソフトウェア全体のボトルネックとなるかを明らかにするために提案したものである．偽陽性が多い点もあるが，低速コードパターンを使った実装も検出できているため，CodeQLを利用した静的な低速コードパターンの検出方法は有効であることを示すことができた．\todo{規模の話はあまりしない方向で調整・卒論用に言い方を変える}


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{考察}
\label{chap:consideration}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{類似度評価の解釈と限界}

提案手法による低速コードパターンの検出結果に対して，コサイン類似度による評価と目視調査の結果から，CodeQLにより検出されたコード片は，低速コードパターンを含んでおり，作成したクエリが構造的に妥当であることを確認した．
検出されたソースコードに対するコサイン類似度の値について，コサイン類似度は，コード間の構造的な類似度を計測できる一方で，低速コードパターンとは無関係である，コードの長さや変数名といった表層的な特徴の影響を受ける傾向があることを確認した．したがって，長さにばらつきがあり多様な変数名や処理を含む，リポジトリにおける検出結果に対するコサイン類似度の値は，マイクロベンチマーク実装対の値と比較して小さくなるため，検出結果が正しいと判断できる類似度の値域について今後検討する．

\todo{意味的に等価ではないものの話もする}

% なお，低速コードパターンの元となった低速コードとコサイン類似度の高いソースコード片は，比較するマイクロベンチマーク実装対におけるコードと長さが同等で，変数名も短く単純なものが多かった．したがって，検出されたソースコード片について，コサイン類似度の高いものは，マイクロベンチマーク実装対における実装方法と非常に類似しており，マイクロベンチマークを参照した修正が比較的容易に適用できる箇所である可能性を示している．したがって，検出結果に対するコサイン類似度を用いた評価は，マイクロベンチマークを用いた性能改善の容易性を示す指標として有用である可能性が示唆される．


\section{修正適用による実行速度変化から得られる示唆}

\todo{実験頑張りましょう}


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{妥当性の脅威}
\label{chap:threat}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{内的妥当性}

本研究では，低速コードの特徴抽出をGumTreeによる差分解析に依存している．したがって，抽出された差分が必ずしも低速コードの特徴を正確に表現していない可能性がある．本研究では，差分から得られた要素を目視により確認し，実装例と照合した上でパターンを作成しているため，その影響は小さいと考えられる．

本研究で利用したマイクロベンチマーク共有サービスであるJsPerfは2020年にサービスを終了しており，当時の高速実装が現在においても最適であるとは限らない．この点については，関連研究\cite{omori}においても同様の指摘がなされている．

本研究における類似度計測においては，プログラム断片のベクトル化にCode2Vecを利用している．Code2VecはJavaおよびC\#を対象としているため，それらの言語への利用における精度と差異が生じる可能性がある．本研究ではJavaScript対応かつマイクロベンチマークをもとに学習された学習モデル\cite{saiki}を使用することで，この影響を抑えるよう努めた．
なお，分散表現の取得における内部処理において，学習の設定に応じて，ソースコード片のトークン数や抽象構文木における構造における制限，分散表現化に利用する特徴のフィルタリングが発生するため，コード長の大きいソースコード片については，分散表現において，十分にその特徴を反映できていない可能性がある．変数名の抽象化や，学習モデルの再構築によって改善が期待されるものの，開発初期における性能ボトルネックの検出が本研究の目的であることから，本研究において，長大なコードへの対応に関する影響は小さいと考える．


\section{外的妥当性}

本研究におけるケーススタディでは，時間的制約のため，GitHub上のスター数上位のリポジトリに対象を限定して分析を行った．そのため，結果の一般性は限定的である可能性がある．
特にスター数の多いリポジトリは，既に十分に最適化・保守が行われていることが多いため，このようなリポジトリにおける検出結果は，一般的な開発段階のソフトウェアとは異なる可能性がある．

本研究では，低速コードパターンを6個作成し，ケーススタディを実施した．また，類似度計測ではそのうち1つのパターンについての検証となっている．異なるパターンに対しては，同様の手法で実験を行う必要があり，複数パターンに基づく評価によって，提案手法の汎用性および有効性をさらに検証することが今後の課題である．


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{おわりに}
\label{chap:finish}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\todo{今後の展望をしっかりと}
本研究では，ソフトウェア中に潜在する，修正によって実行速度の向上が期待されるソースコード片を検出することを目的とした．そこで，繰り返し処理にターゲットを絞り，マイクロベンチマーク共有サービスで提供されるベンチマーク実装対の構造的差分から低速コードパターンを抽出し，静的解析エンジンであるCodeQLを用いて実際のソースコード中から低速コードを検出する手法を提案した．

ケーススタディとして，6件の低速コードパターンおよび，それぞれに対応するCodeQLクエリを作成し，GitHub上のリポジトリ1,000件を対象に検出する実験を行った．その結果，提案手法によって作成した低速コードパターンが実際のソースコード中から検出された．したがって，マイクロベンチマーク共有サービス由来の構造的差分が，実際のプログラムにおける処理構造を適切に捉えていることを確認した．また，低速コードパターンの検出において，CodeQLによる静的検出が有効であることを確認した．

さらに，提案手法によって検出されたソースコード片に対して，Code2Vecを用いて分散表現を取得し，コサイン類似度による評価および目視調査を実施した．その結果，CodeQLによって検出されたコード片はいずれも低速コードパターンを含んでおり，作成したクエリが妥当であることを確認した．一方で，コサイン類似度は構文的な類似性に加え，コードの長さや変数名などの表層的な特徴に影響される傾向が見られた．

% なお，データセット中のリポジトリにおいて検出された，コサイン類似度の高いソースコード片は，マイクロベンチマークのソースコードとコード長や処理構造が類似し，表層的な特徴による影響が小さいことから，マイクロベンチマークを用いた性能改善の容易性を示す指標として有用である可能性が示唆された．

今後の課題として，繰り返し処理に限らず，低速コードパターン作成における差分抽出や低速コードの特徴抽出の手法，およびクエリ作成方法の拡張を進めることが挙げられる．また，検出結果に対して，コサイン類似度や，その他の評価指標の検討を通じて，より意味的な類似性を捉えられる指標の構築を目指す．
これらを元に．高速化修正の可否および，修正の効果，影響範囲の推定を行うことで，より効果的な性能ボトルネック検出および修正候補の提示手法の構築を目指す．


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 謝辞
%%
%% \begin{acknowledgements}
%% 感謝します．
%% \end{acknowledgements}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 参考文献
%%
\bibliographystyle{junsrt}
\bibliography{@Bachelor2025_Noguchi/reference}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 付録
%%
% \appendix
% 
% \chapter{サンプルプログラム}
% 
% プログラムリストや実行結果など，本論を補足する上で必要と思われるものが
% あれば付録として付ける．
% 
% {
% \footnotesize
% \begin{verbatim}
% #include <stdio.h>
% int main(void)
% {
%     printf("Hello, World!\n");
%     return 0;
% }
% \end{verbatim}
% }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
