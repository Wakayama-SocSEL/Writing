\documentclass[11pt]{jreport}
\usepackage{wuse_thesis}
\usepackage{indentfirst}
\usepackage{url}	% \url{}コマンド用．URLを表示する際に便利
\usepackage{xcolor}
\usepackage{listings}
\usepackage{amsmath,amssymb}
\usepackage{tabularx}
\usepackage{stfloats}
\usepackage{booktabs}
\usepackage{threeparttable}
\usepackage{caption}
\usepackage[dvipdfmx]{graphicx}
%\usepackage{graphicx}  % ←graphicx.styを用いてEPSを取り込む場合有効にする
			% 他のパッケージ・スタイルを使う場合には適宜追加

\newcommand{\todo}[1]{\colorbox{yellow}{{\bf TODO}:}{\color{red} {\textbf{[#1]}}}}
\newcommand{\memo}[1]{\colorbox{magenta!30}{{\bf MEMO}:}{\color{red!50} {\textbf{[#1]}}}}
\newcommand{\ihara}[1]{\colorbox{green}{{\bf IHARA}:}{\color{blue} {\textbf{[#1]}}}}
\newcounter{patternID}

% コード例を載せるためのあれこれ
\definecolor{lightred}{RGB}{255,230,230}
\definecolor{lightgreen}{RGB}{230,255,230}

\lstset{
    basicstyle=\small\ttfamily,
    abovecaptionskip=0pt,
    captionpos=b,
    frame=tb,
    framexleftmargin=2em,
    numbers=left,
    numberstyle={\scriptsize},
    xleftmargin=\parindent,
    escapechar=|
}

%ListingのキャプションがFigureになってしまうのをListingに直すコマンド
\usepackage{caption}
\makeatletter
\let\MYcaption\@makecaption
\makeatother
\usepackage{caption}
\makeatletter
\let\@makecaption\MYcaption
\makeatother

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 主に表紙を作成するための情報
%%

%%  タイトル(修論の場合は英語表記も指定)
\title{修正による部分的な性能向上が期待される\\
       マイクロベンチマークにおける低速コードの検出}
%\etitle{Test\\Test\\Test}

%%  著者名(修論の場合は英語表記も指定)
\author{野口 隼杜}
%\eauthor{Akinori Ihara}

%% 卒業論文・修士論文(以下のどちらかを選択)
\bachelar	% 卒業論文(4年生用)

%%  学科・クラスタ
\department{システム工}

%%  学生番号
\studentid{60276185}

%%  卒業年度
\gyear{2025}		% 提出年が2022年なら，2021年度

%%  論文提出日
\date{2026年2月10日}	% 修士の場合は月(2021年2月)までとし，英語表記も指定
%\edate{February 2021}	% 修士の場合，こちら(英語表記)も有効化

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

%%
%%  概要
%%
\begin{abstract}
\todo{あとで作る}

「和歌山大学システム工学部卒業論文/
  大学院システム工学研究科修士論文用スタイルファイル」
は，
\begin{quote}
  \begin{description}
    \item[\tt wuse\_thesis.sty:] 卒業/修士論文用スタイルファイル
    \item[\tt thesis\_sample.tex:] スタイルファイル利用例
  \end{description}
\end{quote}
からなる．

なお，この卒業論文用スタイルファイル(p\LaTeX 版)に関する質問は，
メールにて
\begin{quote}
ihara@wakayama-u.ac.jp
\end{quote}
まで．

\end{abstract}

%%  目次
\tableofcontents

%%  図目次 (図目次をいれたければ以下のコメントをはずす)
%\listoffigures

%%  表目次 (表目次をいれたければ以下のコメントをはずす)
%\listoftables

\newpage
\pagenumbering{arabic}	% 以降のページ番号を算用数字に

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%%  本文はここから
%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{はじめに}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\memo{研究背景・研究課題・目的および本研究の貢献・論文構成}
 ソフトウェアの性能効率性は，ユーザ体験や運用コスト，さらにはシステム全体の品質に直結する重要な要素である\cite{performance1}\cite{performance2}\cite{negative}．\memo{ISO/IECの性能効率性の説明を足してもいい}
 ソフトウェアにおける性能効率性の向上は，計算機能力やシステム設計の改善だけではなく，部分的なソースコードの最適化を積み重ねることで実現することも多い．Webアプリケーション開発では，数行のソースコード修正によって最適化した結果，プログラムの実行時間が25\%から70\%高速化している\cite{jsRefac}．

 \todo{パフォーマンス向上における局所最適化の位置付けを強化}

 性能効率性を向上するためのプログラム変更は，実装が進行するにつれて複雑になりやすい\cite{complicate}．
 また，保守性や可読性など，他のプログラム品質に否定的な影響を与えることもある\cite{negative}．したがって，性能効率性を向上するソースコードへ書き換えるためには，実装が進むほどに開発者に対して広範な知識や経験を要するようになることが考えられる．そのため，ソフトウェアの性能効率性を，実装途中の早期の段階で見積もり，性能低下の原因となるボトルネックを検出することは，性能効率性の改善にかかる修正工数を小さくできる．



ソフトウェアの性能効率性を，実装途中の早期の段階で見積もり，性能低下の原因となるボトルネックを検出することは，性能効率性の改善にかかる修正工数を小さくできる．


% ソースコード「片」で統一
本研究では，ソフトウェア中に潜在する，修正することで実行速度の向上が期待されるソースコード片の検出を目的とする．具体的には，マイクロベンチマーク共有サービスでベンチマークとして比較されたソースコード片の構造的な差分から低速コードパターンを作成する．作成した低速コードパターンを利用し，静的解析エンジンであるCodeQL\footnote{\url{https://codeql.github.com/}}\cite{ql}を用いて，ソースコード中から低速なソースコード片を検出する．CodeQLは，マイクロベンチマーク共有サービスで公開されるソースコード片とは入出力が異なっていても，構造が類似するソースコードの検出が期待される．
提案手法は，動的解析に依存せずに潜在的な性能効率性に寄与するボトルネックを実装初期段階で検出できる．

続く\ref{chap:background}章では，本研究で利用するマイクロベンチマーク共有サービスにおけるマイクロベンチマークの特徴，および関連研究を紹介し，本研究の立ち位置を述べる． \ref{chap:pre-analysis}章で事前分析について示し， \ref{chap:approach}章では，本研究の提案手法を述べ，\ref{chap:evaluation}章で評価方法について述べる．\ref{chap:case-study}章においてケーススタディの結果を述べ，\ref{chap:discussion}章で考察と妥当性への脅威を示し，\ref{chap:summary}章で本研究をまとめる． 


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{プログラム実行速度の改善}\label{chap:background}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{ソフトウェアの性能効率性と部分的な最適化}
\todo{\textbf{はじめに}との棲み分けを考える}
 ソフトウェアの性能効率性は，ユーザ体験や運用コスト，さらにはシステム全体の品質に直結する重要な要素である\cite{performance1}\cite{performance2}\cite{negative}．
 部分的なソースコードの最適化を積み重ねることで実現することも多い．

 ソフトウェアの性能効率性は，限られた計算資源の下でどれだけ効率的に処理を実行できるかを示す指標である．性能改善の手法としては，アルゴリズムやシステム構成の変更といった大規模な最適化だけでなく，既存コードの一部を改善する部分的な最適化も重要な役割を果たす．\todo{参考文献 輪講から引っ張ってくる}

部分的な最適化は，プログラムの振る舞いを変更せずに特定のコード断片の実装方法を改善することで性能向上を図る点に特徴がある．

% \todo{参考文献欲しい}
% 特に、ループ処理やデータ構造操作のように実行回数が多い箇所では、わずかな実装差が全体の実行時間に影響を与えることがある。このようなミクロな性能差を把握し、適切に改善することは、現実的な性能改善戦略の一つである。

\section{マイクロベンチマーク共有サービス}

マイクロベンチマーク共有サービスは，開発者がプログラムの実行速度を比較・共有するためのオンラインサービスである．図\ref{fig:jsPerf}は，マイクロベンチマーク共有サービスの1つであるJsPerf上で実際に投稿されているマイクロベンチマークの例を示す．

マイクロベンチマーク共有サービスにおける各ベンチマークは，1つのセットアッププログラムと，1つ以上のテストプログラムから構成される．図上部に示すセットアッププログラムは，検証対象のソースコードで共通して利用される変数や関数の初期化などが行われる．一方，図下部に示すテストプログラムでは，同一の機能を異なる方法で実装したソースコード片が複数提示され，それぞれの実行速度を計測し，比較できる．
このようなマイクロベンチマークは，データ構造や制御構文の選択，メソッド呼び出しの方法などに多様性が見られることが特徴であり，実行速度の差とその要因となる実装方法を捉えることができる．

% 本研究では，このようなマイクロベンチマーク共有サービス上の実装対を，性能効率性，特に実行速度に影響を与える構造的特徴を分析および抽出するために利用する．

%----------------------
\begin{figure}[!h]
    \centering
    \includegraphics[width=0.8\linewidth]{./fig/jsPerf_example.pdf}
    \caption{マイクロベンチマーク共有サービスの投稿例\protect\footnotemark}
    \label{fig:jsPerf}
\end{figure}

\footnotetext{\url{https://jsperf.app/qiwudo}}
%----------------------



開発者はマイクロベンチマーク共有サービスを用いて複数の実装方法を比較することはもちろん，サービス上でマイクロベンチマークを証拠としてソースコードの改善案を作成している事例もある\cite{saiki}．
% しかし，マイクロベンチマーク共有サービスで公開されているベンチマークに基づいて，開発者が実装するソフトウェアの中から性能効率性が向上できる箇所を検出し，その修正を実現することは容易ではない．これは，実装するソフトウェアにおけるソースコード間の依存関係や構造に対する，開発者の知識や技量に依存するためである．


\section{低速である箇所の検出における難しさ}

\memo{動的検出では実装が進まないできないこと}
ソフトウェアの性能効率性を評価する方法として，プロファイラなどの動的解析ツールが広く用いられている．動的解析ツールは，実行時の関数呼び出しやリソース使用状況を精緻に観測し，性能低下の原因となる箇所を特定することができる．しかし，動的解析ツールによる性能効率性の評価は，評価対象の機能が実行できるまで実装が進んだ状態でなければ評価できないため，開発途中に性能効率性を評価することは難しい．

\memo{静的検出では「正解」がないこと}
\memo{マイクロベンチマーク（規模が小さい）ならではの難しさ}


\section{関連研究}

\subsection{実行速度向上を目的としたリファクタリングの調査}

Selakovicら\cite{jsRefac}は，JavaScriptを利用しているプロジェクトにおいて，開発者が高速化のために行ったリファクタリングを調査している．調査の結果，開発者は10行程度の小さい範囲の修正によって高速化への対処を行なっていることを明らかにした．この結果は，マイクロベンチマーク共有サービスで頻繁に比較される短いソースコード片の修正が，ソフトウェア高速化につながっていることを示し，本研究の動機づけとなっている．また，\cite{jsRefac}では，JavaScriptプロジェクトの解析によって10件の頻出する高速化修正パターンを作成している．この改良パターンを用いた自動修正は一定の高速化効果を示しているが，該当箇所の特定における制約などから，広範な適用には至っていない．

\subsection{静的解析と動的解析を用いた性能ボトルネックの検出}

Turcotte ら\cite{DrAsync}は，JavaScript 言語における非同期処理に注目した性能アンチパターンを定義し，静的解析エンジンであるCodeQL\cite{ql}を利用したアンチパターンの検出と，動的解析を利用したパフォーマンスの監視を組み合わせ，修正可能な性能アンチパターンの検出を行った．本研究の静的解析による低速コードパターンの検出はこれに着想を得ている．\todo{このキモ文章は直す}


\section{本研究の位置付け}

\todo{SIGSEから卒論用に表現を直す．ゴールっぽくする}
本研究では，マイクロベンチマーク共有サービスで公開される実装対における低速コードから，構造的差分に基づいて低速コードパターンを抽出し，静的解析を用いた性能ボトルネックの早期検出を行うことを目指す．本論文は，その第一歩として，ベンチマークのソースコード片のうち，繰り返し処理にターゲットを絞り，ベンチマークに基づいて修正することで実行速度の向上が期待されるソースコード片の検出を目的とする．


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{事前分析：マイクロベンチマークにおける低速コードの特徴}\label{chap:pre-analysis}
%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{データセット}

本研究では，大森ら\cite{omori}が作成したデータセットを分析対象とする．当該データセットは，マイクロベンチマーク共有サービスJsPerfで評価されたベンチマークの中で，実行速度に有意差があり，外的振る舞いが等しいことが検証された実装対29,809件を含む．以降，分析対象とするベンチマークで比較されたソースコード片の対をマイクロベンチマーク実装対，各実装対において，実行速度が遅いコードを低速コード，実行時間が速いコードを高速コードとする．


\section{抽象構文木に基づく実装方法の分析}

マイクロベンチマーク実装対を目視調査した結果，実装対の両方もしくは片方に繰り返し処理を含むものが多く存在することを確認した．特に，巨大な配列や長大な繰り返し処理を用いることで性能差が顕著になる実装対や，\texttt{for}と\texttt{for-of}のように，繰り返し処理の実装方法の違いによって実行時間に差が生じる実装対など，繰り返し処理に関する複数の特徴を確認した．
このような観察結果から，本研究ではマイクロベンチマーク実装対に対して繰り返し処理構造に着目した特徴分析を行う．対象とする繰り返し処理は，JavaScriptにおける \texttt{for}，\texttt{for-of}，\texttt{for-in}，\texttt{while}，および \texttt{do-while}の構文を対象とする．
以後，マイクロベンチマーク実装対のもつ特徴について，実施した分析内容とともに例を示す．

マイクロベンチマーク実装対の特徴分析には，各実装対のソースコードをGumTree\cite{gumtree}により抽象構文木へと変換し，実装対の抽象構文木間の差分解析を行った．差分解析の結果に対して，次の2点を確認し，繰り返し処理に関連する差分要素として収集する．\\
\noindent(1) 差分が直接繰り返し処理構造を含むか\\
\noindent(2) 差分要素の構造的な親要素に繰り返し処理を含むか\\
抽出された箇所に応じて目視で確認を行い，実装対の構造的特徴および性能差との関係を整理した．

\section{繰り返し処理を含む低速コードの主要パターン}

分析の結果，マイクロベンチマーク実装対において，実行速度に差が生じる繰り返し処理の使用パターンを複数確認した．具体例として，Listing~\ref{diff-loop}，Listing~\ref{diff-inloop}，Listing~\ref{diff-method}に，特徴となる部分について示す．

Listing~\ref{diff-loop}は，それぞれ\texttt{for-in}文を用いて配列に含まれる要素にアクセスする実装と，同様の処理を\texttt{for}文で実装したソースコード片である．ここで示すパターンは実行時間の差が，繰り返し処理の実装方法の違いに起因するパターンである．
%----------------------------------
\begin{lstlisting}[caption=繰り返し処理自体の実装方法が異なる実装対, label=diff-loop, captionpos=t, columns=flexible]
// slow
for (key in VAR_1) {
    if (!VAR_1.hasOwnProperty(key)) continue;
    VAR_2 = VAR_1[key];
}

// fast
for (var VAR_8=0; VAR_8<VAR_1.length; ++VAR_8) {
    VAR_2 = VAR_1[VAR_8];
}
\end{lstlisting}
%----------------------------------

Listing~\ref{diff-inloop}は，それぞれ\texttt{for}文内で \texttt{concat}メソッド，\texttt{push}メソッドを用いている実装対である．これは，繰り返し処理の実装方法は一致しているが，繰り返し内部で実行する処理が異なるパターンである．
%----------------------------------
\begin{lstlisting}[caption=繰り返す処理の実装方法が異なる実装対, label=diff-inloop, captionpos=t, columns=flexible]
// slow
for (var VAR_2=0; VAR_2<5000; VAR_2++)
    VAR_1 = VAR_1.concat([\"1\", \"2\"]);

// fast
for (var VAR_2=0; VAR_2<5000; VAR_2++)
    VAR_1.push(\"1\", \"2\");
\end{lstlisting}
%----------------------------------

Listing~\ref{diff-method}は，繰り返し処理を\texttt{forEach}メソッドで実装したものと\texttt{for-of}文で実装したものである．これは，メソッドによる処理とそれに代替する繰り返し処理について比較したパターンである．
%----------------------------------
\begin{lstlisting}[caption=メソッド処理と代替する繰り返し処理に関する実装対, label=diff-method, captionpos=t, columns=flexible]
// slow
var VAR_5 = new Set(VAR_2);
VAR_5.forEach(VAR_6 => {});

// fast
for (let VAR_7 of VAR_2) {}
\end{lstlisting}
%----------------------------------

これらの結果から，マイクロベンチマーク実装対には繰り返し処理の実装および繰り返し内部の操作内容の違いが性能差の要因の1つとして存在することを確認した．本研究では，このような繰り返し処理に関する構造の差分に基づいて低速コードの特徴を捉え，次章以降で述べる低速コードパターンの抽出および静的検出に利用する．


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{構造的差分に基づく低速コードパターンの検出手法}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{概要}
\memo{繰り返し処理に注目して差分とってノード取って組み合わせてパターン}
\memo{パターンをクエリに変換して検出実行}

\section{分析対象となるマイクロベンチマーク実装対の収集}

\ref{chap:pre-analysis}章で述べたように，マイクロベンチマーク共有サービスにおいて，繰り返し処理の実装の違いおよび，繰り返し内部の操作内容の違いが性能差の要因の1つであることを確認した．
本研究では，従来研究\cite{omori}で対象とするベンチマークの中で，比較されるソースコードに繰り返し処理を含むマイクロベンチマーク実装対を収集する．
\ref{chap:pre-analysis}章と同様に，29,809件のマイクロベンチマーク実装対について，各実装対のソースコードを抽象構文木へ変換し，繰り返し処理である構文のノードを含んでいるかどうかを確認し，結果として 11,889件の実装対を収集した．

\section{低速コードパターンの作成}
\subsection{差分解析による低速コードの特徴抽出}

収集した各ベンチマーク実装対において，低速コードから高速コードへ変更することを仮定し，その構造的差分を抽出する．実装対間の差分抽出には，\ref{chap:pre-analysis}章同様，GumTreeを使用し，差分要素に加え，変更操作も取得する．

次に，GumTreeによって得られた構造的差分および変更操作のうち，低速コードから削除または更新された要素を抽出する．これらの要素は，高速コードに存在しない要素であり，低速コード特有の処理や構造を示す要素であると考えられるため，低速コードの特徴候補として収集する．Listing~\ref{diff-loop}に示す実装対にこの処理を行うと，Listing~\ref{candidates}における，背景色のついた要素が低速コードの特徴候補として収集できる．

次に，収集した低速コードの特徴候補の中から，繰り返し処理およびその条件，メソッド呼び出し，配列・オブジェクト操作を，低速コード特有の実装方法を表現する有効な要素として抽出する．最後に，抽出した要素を低速コード内の開始位置，終了位置および，階層情報に基づいて統合する．この処理によって，マイクロベンチマークにおける複数の実装対に共通して出現する，低速コード特有の実装方法および構文的特徴を捉えた低速コードパターンを形成する．


\subsection{低速コードパターンの定義}

本研究では，繰り返し処理を含むマイクロベンチマークから，6件の低速コードパターンを作成した．表\ref{tab:slow_code_patterns}は，作成した6パターンと，各パターンの作成に使用したベンチマーク数（元実装対数）を示す．\todo{中の数字を新しいものに書き換え/そもそも数字はここでは載せない/あとなんか文字でかい}

%----------------------¬
\begin{table}[!h]
    \centering
    \caption{低速コードパターン}
    \label{tab:slow_code_patterns}
    \setcounter{patternID}{0} % 表が始まる前にカウンタを0にリセット
    \resizebox{1.0\linewidth}{!}{
        \begin{threeparttable}
            \begin{tabular}{clrr}
                \toprule
                \textbf{ID} & \textbf{特徴} & \textbf{元実装対数\tnote{*}} & \textbf{検索結果} \\
                \midrule
                
                \refstepcounter{patternID}\label{ptn:for-in}
                \thepatternID & \texttt{for-in}文 & 351 & 1042 \\
                
                \refstepcounter{patternID}\label{ptn:forEach}
                \thepatternID & \texttt{.forEach()}呼び出し & 328 & 692 \\
                
                \refstepcounter{patternID}\label{ptn:hasOwnProperty}
                \thepatternID & \texttt{if}文に\texttt{.hasOwnProperty()}呼び出しを持つ\texttt{for-in}文 & 78 & 201 \\
                
                \refstepcounter{patternID}\label{ptn:json}
                \thepatternID & \texttt{.parse(.stringify())}呼び出し & 27 & 72 \\
                
                \refstepcounter{patternID}\label{ptn:applymap}
                \thepatternID & \texttt{.apply().map()}呼び出し & 11 & 188 \\
                
                \refstepcounter{patternID}\label{ptn:push}
                    \thepatternID & \texttt{.push()}呼び出しを持つ\texttt{for-of}文 & 10 & 28\\
                \bottomrule
            \end{tabular}
            
            \begin{tablenotes}
                \raggedleft
                \item[*] 各パターンの作成に使用したベンチマーク実装対の数
            \end{tablenotes}
        \end{threeparttable}
    }
\end{table}
%----------------------

図\ref{fig:slow_pattern}は，Listing~\ref{diff-loop}から作成した低速コードパターンを示す．当該パターンは，\texttt{if}文内で\texttt{.hasOwnProperty()}を呼び出す\texttt{for-in}文という特徴を有することが読み取れる．

%----------------------------------
\begin{lstlisting}[caption=Characteristic Candidates for Slow Code, label=candidates, captionpos=t, columns=flexible, literate=
    {for}{{\textcolor{black}{\colorbox{lightred}{for}}}}{3}
    {key}{{\textcolor{black}{\colorbox{lightred}{key}}}}{3}
    {in }{{\textcolor{black}{\colorbox{lightred}{in}}\kern0.5em}}{3}
    {VAR\_1}{{\textcolor{black}{\colorbox{lightred}{VAR\_1}}}}{5}
    {if}{{\textcolor{black}{\colorbox{lightred}{if}}}}{2}
    {!}{{\textcolor{black}{\colorbox{lightred}{!}}}}{1}
    {hasOwnProperty}{{\textcolor{black}{\colorbox{lightred}{hasOwnProperty}}}}{15}
    {continue}{{\textcolor{black}{\colorbox{lightred}{continue}}}}{8}
    {VAR\_1\_}{{\textcolor{black}{VAR\_1}}}{6}
]
for (key in VAR_1) {
  if(! VAR_1.hasOwnProperty(key))continue;
  VAR_2 = VAR_1_[key];
}
\end{lstlisting}
%----------------------------------

%----------------------
\begin{figure}[!h]
    \centering
    \includegraphics[width=1.0\linewidth]{./fig/slow_pattern.pdf}
    \caption{低速コードパターン例}
    \label{fig:slow_pattern}
\end{figure}
%----------------------

\section{CodeQLによる低速コードパターンの静的検出}
\subsection{CodeQL}
\todo{CodeQLの説明}

\subsection{低速コードパターンからCodeQLクエリへの変換}

これら6パターンをもとにCodeQLで実行するクエリを作成した．

\subsection{作成したクエリの妥当性検証}

作成したクエリの妥当性を検証するために，全11,889件のベンチマーク実装対を対象として検出数を調査した．結果は表\ref{tab:slow_code_patterns}の「検索結果」に示す．検索結果には，各パターンの作成に使用したベンチマークが全て含まれていたため，再現率は100\%となり，作成したクエリの妥当性が確認できた．一方で，適合率は6.9\%～47.4\%に留まった．しかし，各パターンの作成に使用したベンチマーク以外にも，クエリの示すパターンを含む実装対は多数存在するため，必ずしもクエリの精度が低いことを意味するものではない．ただし，GitHub上のリポジトリを対象として同様の検索を行う場合には，対象となる低速コードパターンに対して，偽陽性となるソースコード片が一定数検出される可能性がある．


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{類似度に基づく検出結果の順位付け}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{妥当な検出結果の判定}

\section{ソースコード片の分散表現化}

\section{コサイン類似度による検出結果の順位づけ}


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{ケーススタディ}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{概要}

\section{実験対象}
ケーススタディとして，本研究では，分散バージョン管理システムであるGitHubで公開されているリポジトリを対象に低速コードパターンの検出を行う．
対象リポジトリは，JavaScriptを主要言語とする，最終コミットが1年以内のスター数上位1,000件のリポジトリとし，2025年10月13日時点で最新のスナップショットを分析対象とした．

\section{検出結果と類似度順位づけ}
\subsection{低速コードパターンの検出結果}

表\ref{tab:result_detect}は，表\ref{tab:slow_code_patterns}に示した各低速コードパターンの検出結果を示す．表中には，パターンID，1つ以上のソースコード片が検出されたリポジトリ数，単一リポジトリにおける最大検出数，1,000リポジトリにおける総検出数を示す．

表\ref{tab:result_detect}から，パターン間で検出数に違いはあるものの，各低速コードパターンは，48リポジトリ〜842リポジトリで検出された．表\ref{tab:slow_code_patterns}におけるID\ref{ptn:for-in}や，ID\ref{ptn:forEach}の低速コードパターンのように，マイクロベンチマーク実装対における検索結果の数が多いパターンはデータセット中のリポジトリにおいても検出数が多かった．なお，これらのパターンは一般的に利用される繰り返し処理の構文であることから，検出数が多いことは妥当であると考えられる．また，これに対し，ID\ref{ptn:push}では，マイクロベンチマーク実装対において，検索結果の数が少なかったものの，データセットにおけるリポジトリにおいては検出数が多くなった．これは，一般的に可読性が高いとされる\texttt{for-of}についての低速コードパターンであることから，実行速度以外の品質への考慮が示唆される．

%----------------------
\begin{table}[!h]
    \centering
    \caption{低速コードパターンに基づく検出結果}
    \label{tab:result_detect}
    \resizebox{0.9\linewidth}{!}{
        \begin{tabular}{crrr}
            \toprule
            \textbf{ID} & \textbf{検出リポジトリ数} & \textbf{最大検出数 (件)} & \textbf{総検出数 (件)} \\
            \midrule           
            \ref{ptn:for-in} & 689 & 7,378 & 90,592 \\
            \ref{ptn:forEach} & 842 & 12,675 & 161,681 \\
            \ref{ptn:hasOwnProperty} & 308 & 1,125 & 9,516 \\
            \ref{ptn:json} & 282 & 142 & 2,684 \\
            \ref{ptn:applymap} & 48 & 12 & 138 \\
            \ref{ptn:push} & 477 & 3,351 & 30,075 \\
            \bottomrule
        \end{tabular}
    }
\end{table}
%----------------------

%----------------------
\begin{figure}[t]
    \centering
    \includegraphics[width=1.0\linewidth]{./fig/log_ID3_spia.pdf}
    \caption{低速コードパターンID3による検出数と規模}
    \label{fig:plot_id3}
\end{figure}
%----------------------

図\ref{fig:plot_id3}は，ID\ref{ptn:hasOwnProperty}について，リポジトリ規模に対する検出数の関係を示す．横軸は各リポジトリに含まれるJavaScriptファイルの総行数，縦軸は検出数を示す．リポジトリ規模が大きくなるほど低速コードパターンの検出数が増加する傾向があり，スピアマンの順位相関係数は0.44，P値は\(5.12 \times 10^{-14} < 0.05\)より正の相関が認められる．他の低速コードパターンについても，同様の傾向が見られた．


\subsection{類似度に基づく検出結果の特徴分析}

\todo{他のパターンについてもやっていいかも？}
パターンID \ref{ptn:hasOwnProperty}「\texttt{if}文に\texttt{.hasOwnProperty()}呼び出しを持つ\texttt{for-in}文」を対象とした実験を示す．なお，長大，または文法的に不正なソースコード片は，分散表現取得における構文解析で失敗する．したがって検出総数9,516件中，分散表現の取得に成功した7,039件を用いる．


検出したソースコード片と，表\ref{tab:slow_code_patterns}に示すID \ref{ptn:hasOwnProperty}のパターン作成に使用した低速コード群78件を対象に，それぞれコサイン類似度を計算した結果を箱ひげ図で示す．左側の箱ひげ図（ID3検出結果）中の点は，検出した各ソースコード片別に，78件の低速コード群と総当たりでコサイン類似度を算出した平均値の分布を示す．右側の箱ひげ図（マイクロベンチマーク）中の点は，マイクロベンチマーク実装対において検出したソースコード片について，パターン作成に使用したベンチマーク実装対を除き，同様に総当たりでコサイン類似度を算出した平均値の分布を示す．なお，ID \ref{ptn:hasOwnProperty}における低速コードパターンを持つ低速コードの例は，Listing~\ref{diff-loop}に示す．\todo{マイクロベンチマークの方の結果は5章にでも載せる}

%----------------------
\begin{figure}[t]
    \centering
    \includegraphics[width=0.85\linewidth]{./fig/boxplot_compare.pdf}
    \caption{低速コードパターンID \ref{ptn:hasOwnProperty}で検出されたソースコード片とパターン元低速コードのコサイン類似度}
    \label{fig:boxplot_cosine}
\end{figure}
%----------------------

ID3検出結果の平均値は0.08，中央値は0.09である一方，マイクロベンチマークでは，平均値は0.61，中央値は0.68となった．コサイン類似度の高い検出例について，リポジトリにおけるソースコード片と，マイクロベンチマーク実装対におけるソースコード片をそれぞれ，Listing\ref{ID3_highcos}とListing\ref{MB_highcos}に示す．
それぞれのコサイン類似度の平均値は0.39，0.78である．

図\ref{fig:boxplot_cosine}に示すように，マイクロベンチマーク実装対における検出結果は，データセット中のリポジトリにおける検出結果と比べ，コサイン類似度が高い値で分布している.
なお，マイクロベンチマーク実装対においては，Listing\ref{diff-loop}とListing\ref{MB_highcos}に示す通り，変数名などが同じ規則で抽象化され，コード長も同程度であることから，比較している低速コードと非常に類似するソースコード片となっている．

リポジトリにおける類似度の高いソースコード片については，Listing\ref{ID3_highcos}に示すように，マイクロベンチマーク実装対における検出結果と同様に，比較している低速コードと，コード長および構造が類似している．使用している変数名については，短く単純な変数名が多く見られた．
一方，類似度が低いソースコード片では，様々な処理が含まれたコード長の大きいものや，変数名が長いソースコード片が多く見られた．コサイン類似度が小さいほど，検出したソースコード片の構造は比較する低速コードに対して複雑になっていく傾向があることを確認した．

目的とした低速コードパターンについては，コサイン類似度の大きさに関わらず含まれていることを確認した．しかし，\todo{主張内容の統一}
% \ref{subsection:pattern}節でも述べたように，繰り返し処理の対象パターンを含んでいたとしても，パターン作成に利用した低速コードの特徴を含まないソースコード片が検出される可能性があり，特に，類似度の低いソースコード片においては，目的とする低速コードパターンとは異なる特徴をもつソースコード片が検出されていることが示唆される．


%----------------------------------
\begin{lstlisting}[caption=リポジトリ中の高類似度検出例, label=ID3_highcos, captionpos=t, columns=flexible]
for (var key in this.defaults) {
  if (!options.hasOwnProperty(key)) {
    attr[key] = this.defaults[key];
  }
}
\end{lstlisting}
%----------------------------------


%----------------------------------
\begin{lstlisting}[caption=マイクロベンチマーク中の高類似度検出例, label=MB_highcos, captionpos=t, columns=flexible]
VAR_1 = {
  KEY_1: 5,
  KEY_2: 13,
  KEY_3: 8,
};
var VAR_2 = [];
for (var VAR_3 in VAR_1) {
  if (VAR_1.hasOwnProperty(VAR_3)) {
    VAR_2.push(VAR_1[VAR_3]);
  }
}
\end{lstlisting}
%----------------------------------

\section{CodeQLを用いた静的検出の有効性}

本研究では，提案手法により作成した低速コードパターンおよび，CodeQLを利用した検出によって，実際のソースコード中から低速コードパターンを含むソースコード片を検出した．分析の結果，リポジトリ規模が大きいほど，低速コードパターンの検出数が増加していた．開発が進み，ソフトウェアが進化する中で性能低下が引き起こされる\cite{emprical_perfomancebug}ことから，規模の肥大化に伴い低速コードパターンによって検出されるソースコード片が増加することは驚く結果ではない．また，ソフトウェア全体としてのボトルネックとなっていないのであれば，必ずしも検出数が増えることが問題とは言えない．本手法は，今後の研究で，検出したソースコード片がソフトウェア全体のボトルネックとなるかを明らかにするために提案したものである．偽陽性が多い点もあるが，低速コードパターンを使った実装も検出できているため，CodeQLを利用した静的な低速コードパターンの検出方法は有効であることを示すことができた．\todo{規模の話はあまりしない方向で調整・卒論用に言い方を変える}


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{考察}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{類似度評価の解釈と限界}

提案手法による低速コードパターンの検出結果に対して，コサイン類似度による評価と目視調査の結果から，CodeQLにより検出されたコード片は，低速コードパターンを含んでおり，作成したクエリが構造的に妥当であることを確認した．
検出されたソースコードに対するコサイン類似度の値について，コサイン類似度は，コード間の構造的な類似度を計測できる一方で，低速コードパターンとは無関係である，コードの長さや変数名といった表層的な特徴の影響を受ける傾向があることを確認した．したがって，長さにばらつきがあり多様な変数名や処理を含む，リポジトリにおける検出結果に対するコサイン類似度の値は，マイクロベンチマーク実装対の値と比較して小さくなるため，検出結果が正しいと判断できる類似度の値域について今後検討する．

\todo{意味的に等価ではないものの話もする}

% なお，低速コードパターンの元となった低速コードとコサイン類似度の高いソースコード片は，比較するマイクロベンチマーク実装対におけるコードと長さが同等で，変数名も短く単純なものが多かった．したがって，検出されたソースコード片について，コサイン類似度の高いものは，マイクロベンチマーク実装対における実装方法と非常に類似しており，マイクロベンチマークを参照した修正が比較的容易に適用できる箇所である可能性を示している．したがって，検出結果に対するコサイン類似度を用いた評価は，マイクロベンチマークを用いた性能改善の容易性を示す指標として有用である可能性が示唆される．


\section{修正適用による実行速度変化から得られる示唆}

\todo{実験頑張りましょう}


%%%%%%%%%%%%%%%%%%%%%%%%%%%
\chapter{妥当性の脅威}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{内的妥当性}

本研究では，低速コードの特徴抽出をGumTreeによる差分解析に依存している．したがって，抽出された差分が必ずしも低速コードの特徴を正確に表現していない可能性がある．本研究では，差分から得られた要素を目視により確認し，実装例と照合した上でパターンを作成しているため，その影響は小さいと考えられる．

本研究で利用したマイクロベンチマーク共有サービスであるJsPerfは2020年にサービスを終了しており，当時の高速実装が現在においても最適であるとは限らない．この点については，関連研究\cite{omori}においても同様の指摘がなされている．

本研究における類似度計測においては，プログラム断片のベクトル化にCode2Vecを利用している．Code2VecはJavaおよびC\#を対象としているため，それらの言語への利用における精度と差異が生じる可能性がある．本研究ではJavaScript対応かつマイクロベンチマークをもとに学習された学習モデル\cite{saiki}を使用することで，この影響を抑えるよう努めた．
なお，分散表現の取得における内部処理において，学習の設定に応じて，ソースコード片のトークン数や抽象構文木における構造における制限，分散表現化に利用する特徴のフィルタリングが発生するため，コード長の大きいソースコード片については，分散表現において，十分にその特徴を反映できていない可能性がある．変数名の抽象化や，学習モデルの再構築によって改善が期待されるものの，開発初期における性能ボトルネックの検出が本研究の目的であることから，本研究において，長大なコードへの対応に関する影響は小さいと考える．


\section{外的妥当性}

本研究におけるケーススタディでは，時間的制約のため，GitHub上のスター数上位のリポジトリに対象を限定して分析を行った．そのため，結果の一般性は限定的である可能性がある．
特にスター数の多いリポジトリは，既に十分に最適化・保守が行われていることが多いため，このようなリポジトリにおける検出結果は，一般的な開発段階のソフトウェアとは異なる可能性がある．

本研究では，低速コードパターンを6個作成し，ケーススタディを実施した．また，類似度計測ではそのうち1つのパターンについての検証となっている．異なるパターンに対しては，同様の手法で実験を行う必要があり，複数パターンに基づく評価によって，提案手法の汎用性および有効性をさらに検証することが今後の課題である．


\chapter{おわりに}

\todo{今後の展望をしっかりと}
本研究では，ソフトウェア中に潜在する，修正によって実行速度の向上が期待されるソースコード片を検出することを目的とした．そこで，繰り返し処理にターゲットを絞り，マイクロベンチマーク共有サービスで提供されるベンチマーク実装対の構造的差分から低速コードパターンを抽出し，静的解析エンジンであるCodeQLを用いて実際のソースコード中から低速コードを検出する手法を提案した．

ケーススタディとして，6件の低速コードパターンおよび，それぞれに対応するCodeQLクエリを作成し，GitHub上のリポジトリ1,000件を対象に検出する実験を行った．その結果，提案手法によって作成した低速コードパターンが実際のソースコード中から検出された．したがって，マイクロベンチマーク共有サービス由来の構造的差分が，実際のプログラムにおける処理構造を適切に捉えていることを確認した．また，低速コードパターンの検出において，CodeQLによる静的検出が有効であることを確認した．

さらに，提案手法によって検出されたソースコード片に対して，Code2Vecを用いて分散表現を取得し，コサイン類似度による評価および目視調査を実施した．その結果，CodeQLによって検出されたコード片はいずれも低速コードパターンを含んでおり，作成したクエリが妥当であることを確認した．一方で，コサイン類似度は構文的な類似性に加え，コードの長さや変数名などの表層的な特徴に影響される傾向が見られた．

% なお，データセット中のリポジトリにおいて検出された，コサイン類似度の高いソースコード片は，マイクロベンチマークのソースコードとコード長や処理構造が類似し，表層的な特徴による影響が小さいことから，マイクロベンチマークを用いた性能改善の容易性を示す指標として有用である可能性が示唆された．

今後の課題として，繰り返し処理に限らず，低速コードパターン作成における差分抽出や低速コードの特徴抽出の手法，およびクエリ作成方法の拡張を進めることが挙げられる．また，検出結果に対して，コサイン類似度や，その他の評価指標の検討を通じて，より意味的な類似性を捉えられる指標の構築を目指す．
これらを元に．高速化修正の可否および，修正の効果，影響範囲の推定を行うことで，より効果的な性能ボトルネック検出および修正候補の提示手法の構築を目指す．


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 謝辞
%%
%% \begin{acknowledgements}
%% 感謝します．
%% \end{acknowledgements}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 参考文献
%%
\bibliographystyle{junsrt}
\bibliography{@Bachelor2025_Noguchi/reference}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 付録
%%
% \appendix
% 
% \chapter{サンプルプログラム}
% 
% プログラムリストや実行結果など，本論を補足する上で必要と思われるものが
% あれば付録として付ける．
% 
% {
% \footnotesize
% \begin{verbatim}
% #include <stdio.h>
% int main(void)
% {
%     printf("Hello, World!\n");
%     return 0;
% }
% \end{verbatim}
% }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
