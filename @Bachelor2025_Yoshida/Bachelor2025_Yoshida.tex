\documentclass[11pt]{jreport}
\usepackage{wuse_thesis}
\usepackage{indentfirst}
\usepackage{url}	% \url{}コマンド用．URLを表示する際に便利
\usepackage[dvipdfmx]{graphicx,xcolor}
\usepackage{listings}
\lstset{
  basicstyle={\ttfamily},
  identifierstyle={\small},
  commentstyle={\smallitshape},
  keywordstyle={\small\bfseries},
  ndkeywordstyle={\small},
  stringstyle={\small\ttfamily},
  frame={tb},
  breaklines=true,
  columns=[l]{fullflexible},
  numbers=left,
  xrightmargin=0zw,
  xleftmargin=3zw,
  numberstyle={\scriptsize},
  stepnumber=1,
  numbersep=1zw,
  lineskip=-0.5ex
}
\usepackage{siunitx}
\sisetup{group-separator={,}} % 3桁ごとにコンマを入れる設定
%\usepackage{graphicx}  % ←graphicx.styを用いてEPSを取り込む場合有効にする
			% 他のパッケージ・スタイルを使う場合には適宜追加
\newcommand{\todo}[1]{\colorbox{yellow}{{\bf TODO}:}{\color{red} {\textbf{[#1]}}}}
\newcommand{\memo}[1]{\colorbox{magenta}{\textbf{MEMO}}{\color{red}\textbf{[#1]}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 主に表紙を作成するための情報
%%

%%  タイトル(修論の場合は英語表記も指定)
\title{\todo{仮}Pythonプロジェクトにおける削除メソッドの実証的研究}
%\etitle{Test\\Test\\Test}

%%  著者名(修論の場合は英語表記も指定)
\author{吉田 将衛}
%\eauthor{Akinori Ihara}

%% 卒業論文・修士論文(以下のどちらかを選択)
\bachelar	% 卒業論文(4年生用)
%\master  	% 修士論文(M2用)

%%  学科・クラスタ
\department{システム工}
%\department{デザイン情報}
%\department{デザイン科学}

%%  学生番号
\studentid{60276296}

%%  卒業年度
\gyear{2025}		% 提出年が2022年なら，2021年度

%%  論文提出日
\date{2026年2月10日}	% 修士の場合は月(2021年2月)までとし，英語表記も指定
%\edate{February 2021}	% 修士の場合，こちら(英語表記)も有効化

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

%%
%%  概要
%%
\begin{abstract}
\todo{概要を考える}

\end{abstract}

%%  目次
\tableofcontents

%%  図目次 (図目次をいれたければ以下のコメントをはずす)
%\listoffigures

%%  表目次 (表目次をいれたければ以下のコメントをはずす)
%\listoftables

\newpage
\pagenumbering{arabic}	% 以降のページ番号を算用数字に

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%%  本文はここから
%%

\chapter{はじめに}

現代のソフトウェア開発はライブラリが提供するソフトウェア部品の組み合わせで行われる\todo{引用}．ライブラリの利用によって，ソフトウェア開発者はソフトウェアの開発工程を大幅に削減することができる\todo{引用}．ライブラリ開発者は，さらに上流のライブラリを使用することもあり，ソフトウェアエコシステム\todo{引用}を形成する．\todo{生成AIの話もするかも}

一方で，ライブラリを利用してソフトウェア開発を行うことのデメリットも存在する．ライブラリ自体も機能追加やバグ修正を行いながら成長するため，破壊的変更を引き起こす可能性がある．「ライブラリが外部へ公開しているAPIの名称変更」や「引数の変更」など，様々な要因\todo{引用}によって，破壊的変更が引き起こされる．中でも，ライブラリAPIの削除はクライアントに甚大な影響を及ぼす．ライブラリAPIが削除されると，クライアントは，代替APIへ切り替える必要がある．しかし，代替APIが存在しない場合は自前で実装するか，機能自体を廃止するかの選択を迫られる．

APIの削除という大きな変更に関しては，急に行うと，ソフトウェアエコシステム全体に負荷がかかる．したがって，多くのライブラリでは，セマンティックバージョニングという戦略を採用している．セマンティックバージョニング\todo{引用}にしたがっているライブラリは一般的にメジャーバージョンのリリース時のみで破壊的変更を加える．この仕組みによって，クライアントはメジャーバージョンのアップデート時には，破壊的変更の対策を取ることができる．また，APIの削除は急に行われるわけではなく，削除よりも一定期間前から非推奨という警告を出し，クライアントが十分に対策を行える猶予を作った上で，削除を行うという仕組みが備わっている．

一般に，ソフトウェアには，不要と考えられるソースコードが蓄積されている．一方，開発者が全ての不要コードを全て見つけ出すことは難しい．なぜなら不要コードには，様々な種類があるからである．

一つ目は，ソースコード中から不要コードを見つけ出す手法である．例えば，プログラム中で到達することができないプログラムはデッドコードと呼ばれ，不要コードと考えられる．デッドコードに関しては，静的解析と動的解析を組み合わせることで検出ができる．静的解析では，動的な依存関係を取得することが難しいため，見逃しが発生してしまう．また，動的解析では，エッジケースの入力や年に1回だけ実行されるようなケースを誤って陽性と判断してしまう．このように，デッドコードの検出は，まだまだ課題が残っている．

二つ目は，ソースコードの変更履歴における削除に着目する方法である．変更履歴において，削除されたコードは不要であると考える．変更履歴から削除されたコードを収集し，共通する特徴を抽出するという方法である．しかし，この分析方法では，ノイズが多く混ざってしまう．例えば，リファクタリングの一環としてコードを移動した場合，履歴上では，削除と追加という変更として記録されてしまう．したがって，本質的な削除のみを抽出する手法が必要である．
そこで，リファクタリングマイナー\todo{引用}のようなリファクタリング検出手法によりノイズを減らす工夫がされている．しかし，リファクタリングマイナーは全ての変更コミットを探索するため，大規模なOSSで適用するには非常に計算コストがかかってしまう．また，リファクタリングが複数コミットに渡る場合，リファクタリングマイナーでも検出ができなくなる．

そこで，本研究では，バージョンごとにソフトウェア中に存在するメソッドを全て抽出し，バージョン間で同じシグネチャのメソッドが存在せず，かつ，類似するメソッドが存在しなかった場合に削除されたメソッドであると判定する．バージョンごとのコミットだけに着目することで計算コストを削減し，類似メソッドで削除を判定することで，複数コミットにわたるリファクタリングも検出できるようになる．さらに，一時的に追加されたコードクローンが削除されるケースも発生するため，コードクローンに関連するケースについても検出する．


% \todo{技術的負債と不要コードの蓄積}

% \todo{不要コードの蓄積による問題}
% 不要コードがシステムに蓄積することで様々な問題を引き起こす．

% \todo{既存の解決策：デッドコード，コードクローン}\todo{完全には特定できない．}

% \todo{事前分析で類似メソッドの削除タイミングにズレが発生}

% \todo{削除判断の難しさ}

% \todo{メソッド単体ではなく，グループに着目}

% \todo{目的：削除候補を事前に検出する}

\todo{論文の構成}\ref{chap:deletecode}章では，\todo{一言要約}．3章では，\todo{一言要約}．4章では，\todo{一言要約}．5章では，\todo{一言要約}．6章では，\todo{一言要約}．7章では，\todo{一言要約}．8章では，\todo{一言要約}．

\chapter{不要コードの削除}
\label{chap:deletecode}

\section{不要コードの定義}
ソフトウェアにとっての不要コードは様々であり，一概には言えない．

\textbf{デッドコード}：プログラム中で到達不可能なコードのことを指す．\\
\textbf{未実行コード}：観測期間において，実行されないコードのことを指す．\\
\textbf{冗長コード}：同じ役割を果たすコードのことを指す．\\
\textbf{削除コード}：ソースコードの履歴上で削除されたコードのことを指す．\\

\section{不要コードが引き起こす問題}
不要コードがコードベースに蓄積することは様々な問題を引き起こす．\todo{X}\cite{increase-maintainability}らの研究では，不要コードは保守コストの増加を引き起こすと言われている．コードの修正時に，未使用のコードも同時に修正する必要があり，無駄なコストを作り出してしまう．また，\todo{X}\cite{decrease-readability}らの研究では，コードベースを理解する際に，不要コードを読んでしまうことで，コード理解の有効性や効率を下げてしまうと言われている．
したがって，不要コードは検出し，削除することで，コードベースから取り除く必要がある．

\section{関連研究}

\subsection{不要コードの検出}

観測期間において，実行されていないコードを検出し，自動で削除する研究が行われている．\cite{dynamic-analysis}\todo{実行されていないコードの検出方法}しかし，コードの使用状況に基づく不要コードの検出では，偽陽性が発生する．例えば，エラー処理のコードや復旧用のコード，移行コードは観測期間において，実行されないため，不要であると検出される．上記のコードは実行されていなくとも，他からの依存関係があるので，削除してはいけない．したがって，実行状況の監視と共に依存関係の取得も必要である．

そこで，依存関係に着目し，他との依存関係を持たないデッドコードを静的に検出する手法が提案されている．\cite{}\todo{デッドコードの検出手法の説明}しかし，リフレクションのように動的に依存関係が決まる場合，偽陽性を発生させてしまう．そして，デッドコードの検出については，静的には全ての依存関係を取得することが不可能であるという結論も出ている．\cite{}

したがって，動的解析と静的解析を組み合わせ，依存関係を取得し，依存関係を持たないコードに関して，実行状況を監視することで不要コードが特定できると考えられる．しかし，動的解析には非常に時間がかかってしまう．そこで，静的に不要コードを検出する手法が求められる．コードのシステム内での重要度に着目し，不要コードを静的に検出する手法が提案されている．\cite{static-analysis}動的ではなく，静的に検出するため，迅速なフィードバックが可能である一方，偽陽性も発生させる．

このように，不要コードを検出する手法は様々提案されている．一方，本研究は，削除コードに焦点を当てている点で異なる．


\subsection{削除コードの特徴分析}
削除履歴から，削除ファイルの特徴を分析した研究では，「最近変更されておらず，依存の中心にいない」特徴を持つファイルが生存するファイルに比べて，有意に差があるということを発見した\cite{static-analysis}．本研究では，ファイル粒度ではなく，メソッド粒度に着目しているという点で異なる．

\section{本研究の位置付け}
既存研究は，\todo{X}．一方で，削除されたコードの特徴については対象（プロダクトコード，テスト，依存，フラグ）や粒度（ファイル，関数，コード断片）ごとに知見が分散しており，削除の動機（意図的削除，副次的削除）や削除前に観測できる兆候を統一的に比較する枠組みわ十分に整理されていない．

そこで，本研究では，Pythonにおける関数を対象に，バージョン間での差分に着目し，削除されたメソッドを分類することを目的とする．


\chapter{事前分析：削除されたコードの特徴}

\section{概要}
\todo{概要は後で書く}

\section{分析手法}

\section{データセット}
GitHub上でソースコードが公開されているpandasプロジェクトを使用した．プロジェクトの選定方法は以下である．
Pythonのプロジェクトであること．大規模なライブラリであり，ユーザが多数存在すること．開発年数が長期であること．メジャーリリースが2つ以上存在すること．

\section{分析結果}



\section{事前分析から得られた示唆と研究課題}


\chapter{RQ1：類似機能メソッド群の生存と削除にはどのような特徴があるか}

\section{概要}
\todo{概要を考える}

\section{分析手法}
\subsection{類似機能メソッドの検出}
対象とするOSSのGitHubのリポジトリをクローンする．
クローンしたリポジトリ内で，タグを含むコミットを全て取得する．タグを含むコミットからセマンティックバージョニングを使用しているコミットのみをフィルタリングする．
さらに，セマンティックバージョニングの末尾に「rc」や「dev」といった\todo{〇〇}が含まれるタグについては，正規表現で排除する．\todo{排除する理由}
また，パッチバージョンについては，0のみを使用する．
これらの操作によって，マイナーバージョンのタグとそのコミットのみを全て抽出できる．例えば，「v1.2.0」のようなタグとコミットを取得できる．

次に，取得したマイナーバージョンのコミットハッシュを利用して，最も古いバージョンにチェックアウトする．
そして，チェックアウトしたバージョン内の全ての「.py」ファイルを対象に抽象構文木（Abstract Syntacs Tree）へパースする．（以降，ASTとする．）このASTからクラスの定義とメソッドの定義を取得し，一意のメソッド名を構築する（「クラス名.メソッド名」という形式）．
同時にメソッドのソースコードもASTから取得しておき，N-gramでハッシュ化する．\todo{なぜASTを使用するのか}

メソッド間の類似度をN-gramから算出する．算出方法は最長共通部分文字列（以降，LCSとする）を使用する．
しかし，LCSは計算に時間がかかるため，まず，N-gramの単純な類似度でフィルタリングし，閾値0.7を超えた時点で無条件にコードクローンであると判定する．
N-gramの類似度で閾値0.7未満であったメソッドに対して，LCSを適用し，類似度を算出し，0.7を超えていれば，コードクローンであると判定する．
このコードクローンの判定には，コードクローン検出における既存研究のツールNILを使用する．\cite{NIL}\todo{なぜNILを使用するのか}\todo{コードクローンの偽陽性，偽陰性の話}

コードクローンは二つのメソッドのペアとして算出される．\todo{ペアではダメな理由}
したがって，コードクローンのペアの推移的関係を用いて，クローンペアを集約することで2つ以上のコードクローンメソッドのグループを作成する．

これらの操作を全てのバージョンコミットにチェックアウトし，繰り返す．

\subsection{削除メソッドと生存メソッドの抽出}
Gitの履歴で削除されたメソッドを抽出すると，メソッドの移動といったノイズに影響を受けてしまう．したがって，バージョン間でのメソッドのシグネチャや類似度を測定することで同一メソッドを追跡する．

バージョン間で同じファイルパスを持ち，かつ，同じメソッド名を持つメソッドが存在すれば，それらを同じメソッドであるとし，メソッドに対し，同じIDを割り当てる．
上記の方法で同じメソッドと判定されなかった残りのメソッドについては，バージョン間の全メソッドと総当たりで類似度を算出し，閾値0.7以上であれば，同じIDを割り当てる．
このようにすることによって，メソッドが削除され，別のファイルに同じメソッドが生成されたとしても，追跡ができる．なお，ここでの類似度の計算では，コードクローン検出のNILと同じアルゴリズムを使用する．

バージョン間でのメソッドのIDを比較することで，追加メソッド，生存メソッド，削除メソッドを分類する．前のバージョンになく，現在のバージョンで初めて出現したメソッドIDが存在すれば，追加メソッドとする．前のバージョンと現在のバージョンの両方でIDが存在するメソッドは生存メソッドとする．前のバージョンでIDが存在し，現在のバージョンでIDが存在しないメソッドは削除メソッドとする．
\todo{メソッド追跡の限界：誤追跡}

\subsection{メソッドの変遷パターンの分類}
追加メソッド，生存メソッド，削除メソッドのそれぞれについて，コードクローンの有無で，さらに，詳細に分類する．

メソッドが生存したバージョンでは，クローングループに所属せず，生存すると「単独での生存」とし，クローングループに所属しつつ，生存すると「グループでの生存」とする．

メソッドが削除されたバージョンで，クローングループも解体された場合は「全削除」とし，クローングループが存続しており，別のメソッドがクローングループに残っている場合は，削除されたメソッドを「部分削除」とし，生存したメソッドを「部分生存」とする．


\subsection{メソッドの変遷パターン間での生存期間の違いの取得}
4.2.3で分類したメソッドごとに生存期間を算出し，違いがあるかを分析する．

\section{分析結果}
\subsection{類似機能メソッドの生存実態}
\todo{表の書き方}
\todo{表の読み方}

\begin{table}[]
    \centering
    \caption{メソッドの変遷パターン}
    \begin{tabular}{l|SSSSSSS} \hline
& & \multicolumn{3}{c}{削除} & \\ \cline{3-5}
    バージョン & 追加 & グループの全削除 & グループの一部削除 & 単独削除 & 生存 \\ \hline \hline
    v0.4.0 & 1303 & 0 & 0 & 0 & 0 \\
    v0.5.0 & 281 & 7 & 0 & 18 & 1272 \\
    v0.6.0 & 169 & 4 & 0 & 12 & 1529 \\
    v0.7.0 & 606 & 71 & 0 & 167 & 1457 \\
    v0.8.0 & 908 & 100 & 0 & 145 & 1809 \\
    v0.9.0 & 288 & 20 & 0 & 9 & 2670 \\
    v0.10.0 & 428 & 51 & 0 & 138 & 2750 \\
    v0.11.0 & 376 & 59 & 6 & 144 & 2949 \\
    v0.12.0 & 414 & 12 & 0 & 17 & 3269 \\
    v0.13.0 & 2380 & 63 & 0 & 57 & 3542 \\
    v0.14.0 & 806 & 51 & 5 & 113 & 5706 \\
    v0.15.0 & 909 & 71 & 1 & 67 & 6325 \\
    v0.16.0 & 455 & 36 & 5 & 32 & 7113 \\
    v0.17.0 & 1217 & 49 & 4 & 57 & 7410 \\
    v0.18.0 & 743 & 68 & 4 & 79 & 8434 \\
    v0.19.0 & 1476 & 168 & 3 & 206 & 8766 \\
    v0.20.0 & 1276 & 503 & 11 & 542 & 9150 \\
    v0.21.0 & 670 & 56 & 4 & 67 & 10255 \\
    v0.22.0 & 129 & 1 & 1 & 1 & 10876 \\
    v0.23.0 & 1725 & 478 & 14 & 430 & 10044 \\
    v0.24.0 & 2593 & 504 & 12 & 601 & 10612 \\
    v0.25.0 & 1111 & 326 & 6 & 473 & 12372 \\ \hline
    v1.0.0 & 1284 & 496 & 10 & 522 & 12430 \\
    v1.1.0 & 1407 & 196 & 12 & 280 & 13198 \\
    v1.2.0 & 1544 & 279 & 7 & 217 & 14064 \\
    v1.3.0 & 2067 & 294 & 12 & 285 & 14984 \\
    v1.4.0 & 1477 & 260 & 15 & 170 & 16568 \\
    v1.5.0 & 1423 & 104 & 7 & 87 & 17788 \\ \hline
    v2.0.0 & 1376 & 345 & 17 & 416 & 18270 \\
    v2.1.0 & 1398 & 197 & 11 & 147 & 19153 \\
    v2.2.0 & 1105 & 128 & 6 & 166 & 20123 \\
    v2.3.0 & 319 & 16 & 3 & 15 & 21045 \\ \hline
    合計 & 34968 & 5313 & 184 & 5304 & 275734 \\ \hline
    \end{tabular}
    \label{tab:placeholder}
\end{table}


% \subsection{メソッドの生存期間}
% \begin{figure*}[t]
%     \centering
% \includegraphics[width=1.0\textwidth]{./Yoshida_fig/state_plot.pdf}
%     \caption{メソッドの生存期間}
%     \label{fig:result}
% \end{figure*}
% メソッドごとの生存期間は図4.1に示す．\todo{この図は差し替える}

\subsection{クローンメソッド群の一部が削除}


pandasプロジェクトにおいて，v0.19.0がリリースされた時点でのメソッドの例を以下に示す．これら二つのメソッドはコードクローン検出器によると類似度\todo{〇〇\%}となっており，コードクローンタイプ3である．どちらもPanelオブジェクトを生成しているという点では類似している．

%----------------------------------
\vspace{10pt}
\begin{lstlisting}[caption=非推奨な記述方法を含むメソッド, label=include-deprecated-API, captionpos=t, columns=flexible]
def test_backwards_compat_without_term_object(self):
    with ensure_clean_store(self.path) as store:

        wp = Panel(np.random.randn(2, 5, 4), items=['Item1', 'Item2'],
                   major_axis=date_range('1/1/2000', periods=5),
                   minor_axis=['A', 'B', 'C', 'D'])
        store.append('wp', wp)
        with assert_produces_warning(expected_warning=FutureWarning,
                                     check_stacklevel=False):
            result = store.select('wp', [('major_axis>20000102'),
                                         ('minor_axis', '=', ['A', 'B'])])
        expected = wp.loc[:,
                          wp.major_axis > Timestamp('20000102'),
                          ['A', 'B']]
        assert_panel_equal(result, expected)
\end{lstlisting}
\vspace{10pt}
%----------------------------------
Listing~\ref{include-deprecated-API}は，古い形式のクエリの書き方が後方互換性を維持して正しく動作するかを検証するメソッドである．
コード内で\texttt{wp = Panel(...)}とある．ここでは，条件を\texttt{('カラム名','演算子','値')}というタプルのリストで渡している．そして，\texttt{with assert\textunderscore produces\textunderscore warning(FutureWarning)}を使って，「この記述方法が将来的に消える」という警告が出ることをテストしている．


%----------------------------------
\vspace{10pt}
\begin{lstlisting}[caption=推奨APIを含むメソッド, label=include-inplace-API, captionpos=t, columns=flexible]
def test_panel_assignment(self):
    # GH3777
    wp = Panel(
        randn(2, 5, 4), items=['Item1', 'Item2'],
        major_axis=date_range('1/1/2000', periods=5),
        minor_axis=['A', 'B', 'C', 'D'])
    wp2 = Panel(
        randn(2, 5, 4), items=['Item1', 'Item2'],
        major_axis=date_range('1/1/2000', periods=5),
        minor_axis=['A', 'B', 'C', 'D'])

    # TODO: unused?
    # expected = wp.loc[['Item1', 'Item2'], :, ['A', 'B']]

    def f():
        wp.loc[['Item1', 'Item2'], :, ['A', 'B']] = wp2.loc[
            ['Item1', 'Item2'], :, ['A', 'B']]

    self.assertRaises(NotImplementedError, f)
\end{lstlisting}
\vspace{10pt}
%----------------------------------

Listing~\ref{include-inplace-API}は，まだ実装されていない操作に対して，適切にエラーを発生させているかを検証するテストメソッドである．
実行したい処理を内部関数\texttt{f()}の中で，\texttt{wp.loc[...] = wp2.loc[...]}という代入処理を記述している．そして，\texttt{self.assertRaises(NotImplementedError, f)}により関数\texttt{f()}を実行した際に，未実装のエラーが発生することをテストしている．

Listing~\ref{include-deprecated-API}における\texttt{test\textunderscore backwards\textunderscore compat\textunderscore without\textunderscore term\textunderscore object}メソッドは，v0.20.0リリース時には削除された．つまり，v0.19.0の時点では必要であったメソッドがv0.20.0の時点では不要であったため，削除されたと言える．
一方，Listing~\ref{include-inplace-API}における\texttt{test\textunderscore panel\textunderscore assignment}メソッドはv0.20.0の時点でも削除されずに生存していたため，v0.20.0の時点では不要ではなく，必要なメソッドであると考えられる．その後，メジャーバージョンであるv1.0.0リリース直前のv0.25.0において不要となり，削除された．

この結果から，v0.20.0では，\texttt{store.select}メソッドの古い形式の記述方法のサポートが終了したため，それを利用している側のコードが削除されたと考えられる．さらに，v0.25.0においては，\texttt{Panel}オブジェクトが削除されたため，それを呼び出しているメソッドも削除されたと考えられる．


\subsection{クローンメソッド群の全てが削除}
v0.18.0がリリースされた時点において，クローンメソッド群の全てが削除されたメソッドの例を以下に示す．

\vspace{10pt}
\begin{lstlisting}[caption=v0.18.0におけるクローンメソッド, label=all-deleted-method-1, captionpos=t, columns=flexible]
@network
def test_get_options_data(self):
    # regression test GH6105
    self.assertRaises(ValueError, self.aapl.get_options_data, month=3)
    self.assertRaises(ValueError, self.aapl.get_options_data, year=1992)

    try:
        options = self.aapl.get_options_data(expiry=self.expiry)
    except RemoteDataError as e:
        raise nose.SkipTest(e)
    self.assertTrue(len(options) > 1)
    
\end{lstlisting}
\vspace{10pt}

Listing~\ref{all-deleted-method-1}はオプション取引データの取得機能が正しく動作するかを検証するためのメソッドである．まず，\texttt{self.assertRaises(ValueError, ...)}によって，\texttt{self.aapl.get\textunderscore options\textunderscore data}メソッドに不正な引数を指定した場合に，正しくエラーが発生することを確認している．さらに，その後の\texttt{try ... except ...}句内で実際にデータを取得し，\texttt{self.assertTrue}によって，取得したデータが1以上であることを確認している．

\vspace{10pt}
\begin{lstlisting}[caption=v0.18.0におけるクローンメソッド, label=all-deleted-method-2, captionpos=t, columns=flexible]
@network
def test_get_data_with_list(self):
    try:
        data = self.aapl.get_call_data(expiry=self.aapl.expiry_dates)
    except RemoteDataError as e:
        raise nose.SkipTest(e)
    self.assertTrue(len(data) > 1)
    
\end{lstlisting}
\vspace{10pt}

Listing~\ref{all-deleted-method-2}は，複数のリストをまとめて指定し，データを一括取得できるかを検証するテストコードである．\texttt{self.appl.get\textunderscore call\textunderscore data\textunderscore (expiry=self.aapl.expiry\textunderscore dates)}によって，データのリストを引数にいれ，データを取得する．そして，\texttt{try ... except ...}句内で実際にデータを取得し，\texttt{self.assertTrue}によって，取得したデータが1以上であることを確認している．

Listing~\ref{all-deleted-method-1}とListing~\ref{all-deleted-method-2}は互いに，クローンと判定されたメソッドである．これらは，v0.19.0で削除された．これらのメソッドのパスは\texttt{/pandas/io/tests/test\textunderscore data.py}に存在している．このパスに注目すると，v0.18.0においては，存在しているが，v0.19.0においては存在していなかった．つまり，これらのクローンメソッド群はファイル自体が削除されたことによって，同時にクローングループごと削除されたと判定されたことがわかる．

\vspace{10pt}
\begin{lstlisting}[caption=v0.6.0におけるクローンメソッド, label=all-deleted-method-3, captionpos=t, columns=flexible]
def median(self, axis='major', skipna=True):
    def f(arr):
        mask = common.notnull(arr)
        if skipna:
            return _tseries.median(arr[mask])
        else:
            if not mask.all():
                return np.nan
            return _tseries.median(arr)
    return self.apply(f, axis=axis)
    
\end{lstlisting}
\vspace{10pt}

Listing~\ref{all-deleted-method-3}は，内部に関数を定義し，それを\texttt{apply}メソッドで指定した軸に適用している．

\vspace{10pt}
\begin{lstlisting}[caption=v0.6.0におけるクローンメソッド, label=all-deleted-method-4, captionpos=t, columns=flexible]
def f(arr):
    mask = common.notnull(arr)
    if skipna:
        return _tseries.median(arr[mask])
    else:
        if not mask.all():
            return np.nan
        return _tseries.median(arr)
    
\end{lstlisting}
\vspace{10pt}

Listing~\ref{all-deleted-method-4}は，Listing~\ref{all-deleted-method-3}の内部で定義されている関数である．つまり，関数の内部で関数が定義されている場合，それらの構造は類似しているとコードクローン検出器では，判定される．したがって，上位の関数が削除された場合，下位の関数も同時に削除される．

これらの結果より，クローンと判定されたメソッド群が同時に削除される事例は上位概念の削除による副次的作用であることがわかる．


\section{まとめ}

コードクローンタイプ3の片方が削除されるパターンには，一定の特徴があると考えられる．
まず，クローンを持つメソッドはクローンを持たないメソッドに比べ，僅かに寿命が短い．これは，コードクローンと判定されるメソッドは，一時的であるということを示唆している．この結果は\todo{引用}らの研究による結果と一致する．

クローングループの一部が削除されるという事例から，機能の移行期間では，一時的に類似機能を作成し，完全な移行が完了した時点で古いメソッドを削除するというパターンがあることがわかった．

クローングループが同時に削除されるという事例から，削除パターンの一つとして，上位概念の削除による副次的削除が含まれることがわかる．

\chapter{RQ2：単独削除されたメソッドは細分化できるか}
\label{chap:RQ2}

\section{概要}
RQ1で得られた単独削除メソッドに着目する．メソッドは削除された後に，別のメソッドと統合されるか，複数メソッドが分割されるか，ソフトウェア中から完全に排除されるかの3パターンに分類する．

\section{削除メソッドの細分化}
RQ1の単独削除メソッドから，削除される一つ前のバージョンにおけるソースコードを取得する．さらに，削除時のバージョンにおける追加，生存メソッドについてもソースコードを取得する．

削除メソッドが次のバージョンで別の場所で作成されているかどうかを確認する．まず，削除メソッドをハッシュ化し，次のバージョンでの追加メソッドと生存メソッドの全てもハッシュ化する．そして，削除メソッドのハッシュが次のバージョンの追加メソッドや生存メソッドに部分的に一致するかどうかを検証する．この操作で部分一致が確認された場合，削除メソッドは次のバージョンで別のメソッドの一部になったと考えられる．

逆に，削除メソッドが分割されて，複数のメソッドに分かれる場合も検出する．これは先ほどと逆の検出を行う．つまり，追加メソッドと生存メソッドのハッシュの一部が削除メソッドのハッシュに含まれるかどうかを調べる．これによって，削除メソッドが分割されたかどうかを判定できる．

最後に，この検出手法によって，閾値に達しなかったメソッドについては，統合や分割が行われていなので，コードベースから完全に排除されたメソッドであると判断できる．


\section{結果}

\begin{table}[]
    \centering
    \caption{単独削除メソッドの細分化}
    \begin{tabular}{|c|c|c|c|c|c|}
    \hline
         & \multicolumn{2}{c|}{\textbf{delete}} & \textbf{label} & \textbf{survive} & \textbf{add} \\
         & \textbf{single\_deleted} & \textbf{all\_deleted} &  &  & \ \\
        \hline
        \hline
        \textbf{v0.3.0} & 20 & 14 & deleted in survive or add & 10 & 10 \\
        \textbf{v0.3.0} & 40 & 24 & survived or add in deleted & 10 & 30 \\
        \textbf{v0.3.0} & 40 & 33 & other & 20 & 20 \\
        \hline
        \textbf{v0.4.0} & 20 & 14 & deleted in survive or add & 10 & 10 \\
        \textbf{v0.4.0} & 40 & 24 & survived or add in deleted & 10 & 30 \\
        \textbf{v0.4.0} & 40 & 33 & other & 20 & 20 \\
        \hline
    \end{tabular}
    \label{tab:placeholder}
\end{table}

\section{考察}

\section{まとめ}


\chapter{考察}

\section{生存するのに削除されると予測されたのはなぜか}

\section{\todo{偽陰性の考察もするか}}

\chapter{妥当性の脅威}

\section{内的妥当性}
\todo{削除と判定したコードが本当に削除されたコードであるかはわからない．リファクタリングや移動であってもgit上では，削除と判定してしまうため．}

\section{外的妥当性}
本研究はPythonのpandasプロジェクトのみを対象としているため，他のプロジェクトや他の言語のプロジェクトにおいても同様の結果が得られるとは限らない．

\chapter{おわりに}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 謝辞
%%
%% \begin{acknowledgements}
%% 感謝します．
%% \end{acknowledgements}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 参考文献
%%
\bibliographystyle{junsrt}
\bibliography{@Bachelor2025_Yoshida/references}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 付録
%%
% \appendix
% 
% \chapter{サンプルプログラム}
% 
% プログラムリストや実行結果など，本論を補足する上で必要と思われるものが
% あれば付録として付ける．
% 
% {
% \footnotesize
% \begin{verbatim}
% #include <stdio.h>
% int main(void)
% {
%     printf("Hello, World!\n");
%     return 0;
% }
% \end{verbatim}
% }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
