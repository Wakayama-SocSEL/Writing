\documentclass[11pt]{jreport}
\usepackage{wuse_thesis}
\usepackage{indentfirst}
\usepackage{url}	% \url{}コマンド用．URLを表示する際に便利
\usepackage[dvipdfmx]{graphicx,xcolor}
%\usepackage{graphicx}  % ←graphicx.styを用いてEPSを取り込む場合有効にする
			% 他のパッケージ・スタイルを使う場合には適宜追加
\newcommand{\todo}[1]{\colorbox{yellow}{{\bf TODO}:}{\color{red} {\textbf{[#1]}}}}
\newcommand{\memo}[1]{\colorbox{magenta}{\textbf{MEMO}}{\color{red}\textbf{[#1]}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 主に表紙を作成するための情報
%%

%%  タイトル(修論の場合は英語表記も指定)
\title{\todo{仮}類似機能メソッドの削除実態調査と削除候補メソッドの検出手法の提案}
%\etitle{Test\\Test\\Test}

%%  著者名(修論の場合は英語表記も指定)
\author{吉田 将衛}
%\eauthor{Akinori Ihara}

%% 卒業論文・修士論文(以下のどちらかを選択)
\bachelar	% 卒業論文(4年生用)
%\master  	% 修士論文(M2用)

%%  学科・クラスタ
\department{システム工}
%\department{デザイン情報}
%\department{デザイン科学}

%%  学生番号
\studentid{60276296}

%%  卒業年度
\gyear{2025}		% 提出年が2022年なら，2021年度

%%  論文提出日
\date{2026年2月10日}	% 修士の場合は月(2021年2月)までとし，英語表記も指定
%\edate{February 2021}	% 修士の場合，こちら(英語表記)も有効化

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

%%
%%  概要
%%
\begin{abstract}
\todo{概要を考える}

\end{abstract}

%%  目次
\tableofcontents

%%  図目次 (図目次をいれたければ以下のコメントをはずす)
%\listoffigures

%%  表目次 (表目次をいれたければ以下のコメントをはずす)
%\listoftables

\newpage
\pagenumbering{arabic}	% 以降のページ番号を算用数字に

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%%  本文はここから
%%

\chapter{はじめに}

\todo{}
\memo{aaa}

\chapter{不要コードの削除}

\section{不要コードの定義}

\todo{3種類ありますよっていうことを述べる．従来研究より引用}

\subsection{デッドコード（Dead Code）}
\todo{コールグラフ上において，到達できないコード}

\memo{コード例入れるかも}

\subsection{未実行コード（Unused Code）}
\todo{特定の期間において，本番環境で実行されなかったコード}

\memo{コード例入れるかも}

\subsection{不要コード（Unnecessary Code）}
\todo{ステークホルダが関心を失ったコード←従来研究の定義}

\todo{本研究で対象とする不要コードの定義}
\begin{itemize}
    \item 過去の履歴上，削除されたコード
    \begin{itemize}
        \item 移動などにより，削除/追加されたコードはノイズ
    \end{itemize}
    \item 類似機能メソッドが存在しており，片方に代替されたメソッド
\end{itemize}

\memo{コード例入れるかも}

\section{不要コードが引き起こす問題}
\todo{リソースの浪費}

\todo{コードベースの理解阻害}

したがって，不要コードは検出し，削除することで，コードベースから取り除く必要がある．

\section{関連研究}

\subsection{デッドコードの検出}
\todo{静的解析によるデッドコードの検出}

\todo{静的解析ツールの限界}
動的依存関係の取得が困難\cite{static-analysis}


\subsection{未実行コードの検出}

\todo{ランタイム使用状況から検出}\cite{dynamic-analysis}

\todo{ランタイム使用状況取得における課題}
\begin{itemize}
    \item 長期間を要する
    \item 少なくとも一回実行されたコードは全体の2割ほどしかない
    \item 使用されていないからといって削除しても良いとは限らない
    \begin{itemize}
        \item エラー処理コード
        \item 復旧コード
        \item 移行コード
    \end{itemize}
\end{itemize}


\subsection{不要コードの検出}
\todo{静的メトリクスを用いた検出手法}

\todo{課題}


\subsection{類似機能メソッドの検出}
\todo{意味的に同じ機能を持つメソッド群の検出}

\todo{課題}
\begin{itemize}
    \item 一時的なクローンか，削除されるクローンかの識別ができない
\end{itemize}

\subsection{削除メソッドの特徴分析}
\todo{生存分析}

\section{本研究の位置付け}

\todo{既存研究の共通課題}
\begin{itemize}
    \item 削除されたメソッドの特徴を使用していない
    \item 検出した不要コードが削除されるとは限らない
\end{itemize}

\todo{既存研究との違い}
\begin{itemize}
    \item 削除されたメソッドの特徴からパターンを作成する
    \item 単体のコードではなく，類似機能メソッド群の中での役割の違いに着目
\end{itemize}


\chapter{事前分析：削除されたコードの特徴}

\section{概要}

\section{分析手法}

\section{データセット}

\section{分析結果}
\todo{依存ライブラリのバージョン更新などが原因で仕様変更が行われ，古いAPIが新しいAPIに置き換えられる時に削除が発生する．}

\section{\memo{キーアイデアとして，独立させる必要もないかも}キーアイデア}
\todo{事前分析の結果からRQに繋げる．}

\chapter{RQ1：類似機能メソッド群の生存と削除にはどのような特徴があるか}

\section{概要}

\section{分析手法}
\subsection{類似機能メソッドの検出}
対象とするOSSのGitHubのリポジトリをクローンする．
クローンしたリポジトリ内で，タグを含むコミットを全て取得する．タグを含むコミットからセマンティックバージョニングを使用しているコミットのみをフィルタリングする．
さらに，セマンティックバージョニングの末尾に「rc」や「dev」といった\todo{〇〇}が含まれるタグについては，正規表現で排除する．\todo{排除する理由}
また，パッチバージョンについては，0のみを使用する．
これらの操作によって，マイナーバージョンのタグとそのコミットのみを全て抽出できる．例えば，「v1.2.0」のようなタグとコミットを取得できる．

次に，取得したマイナーバージョンのコミットハッシュを利用して，最も古いバージョンにチェックアウトする．
そして，チェックアウトしたバージョン内の全ての「.py」ファイルを対象に抽象構文木（Abstract Syntacs Tree）へパースする．（以降，ASTとする．）このASTからクラスの定義とメソッドの定義を取得し，一意のメソッド名を構築する（「クラス名.メソッド名」という形式）．
同時にメソッドのソースコードもASTから取得しておき，N-gramでハッシュ化する．\todo{なぜASTを使用するのか}

メソッド間の類似度をN-gramから算出する．算出方法は最長共通部分文字列（以降，LCSとする）を使用する．
しかし，LCSは計算に時間がかかるため，まず，N-gramの単純な類似度でフィルタリングし，閾値0.7を超えた時点で無条件にコードクローンであると判定する．
N-gramの類似度で閾値0.7未満であったメソッドに対して，LCSを適用し，類似度を算出し，0.7を超えていれば，コードクローンであると判定する．
このコードクローンの判定には，コードクローン検出における既存研究のツールNILを使用する．\cite{NIL}\todo{なぜNILを使用するのか}\todo{コードクローンの偽陽性，偽陰性の話}

コードクローンは二つのメソッドのペアとして算出される．\todo{ペアではダメな理由}
したがって，コードクローンのペアの推移的関係を用いて，クローンペアを集約することで2つ以上のコードクローンメソッドのグループを作成する．

これらの操作を全てのバージョンコミットにチェックアウトし，繰り返す．

\subsection{削除メソッドと生存メソッドの抽出}
Gitの履歴で削除されたメソッドを抽出すると，メソッドの移動といったノイズに影響を受けてしまう．したがって，バージョン間でのメソッドのシグネチャや類似度を測定することで同一メソッドを追跡する．

バージョン間で同じファイルパスを持ち，かつ，同じメソッド名を持つメソッドが存在すれば，それらを同じメソッドであるとし，メソッドに対し，同じIDを割り当てる．
上記の方法で同じメソッドと判定されなかった残りのメソッドについては，バージョン間の全メソッドと総当たりで類似度を算出し，閾値0.7以上であれば，同じIDを割り当てる．
このようにすることによって，メソッドが削除され，別のファイルに同じメソッドが生成されたとしても，追跡ができる．なお，ここでの類似度の計算では，コードクローン検出のNILと同じアルゴリズムを使用する．

バージョン間でのメソッドのIDを比較することで，追加メソッド，生存メソッド，削除メソッドを分類する．前のバージョンになく，現在のバージョンで初めて出現したメソッドIDが存在すれば，追加メソッドとする．前のバージョンと現在のバージョンの両方でIDが存在するメソッドは生存メソッドとする．前のバージョンでIDが存在し，現在のバージョンでIDが存在しないメソッドは削除メソッドとする．
\todo{メソッド追跡の限界：誤追跡}

\subsection{メソッドの変遷パターンの分類}
追加メソッド，生存メソッド，削除メソッドのそれぞれについて，コードクローンの有無で，さらに，詳細に分類する．

メソッドが生存したバージョンでは，クローングループに所属せず，生存すると「単独での生存」とし，クローングループに所属しつつ，生存すると「グループでの生存」とする．

メソッドが削除されたバージョンで，クローングループも解体された場合は「全削除」とし，クローングループが存続しており，別のメソッドがクローングループに残っている場合は，削除されたメソッドを「部分削除」とし，生存したメソッドを「部分生存」とする．


\subsection{メソッドの変遷パターン間での生存期間の違いの取得}
4.2.3で分類したメソッドごとに生存期間を算出し，違いがあるかを分析する．

\section{分析結果}
\subsection{類似機能メソッドの生存実態}
\todo{表の書き方}
\todo{表の読み方}

\begin{table}[]
    \centering
    \caption{メソッドの変遷パターン}
    \begin{tabular}{l|rrrrrrr} \hline
       revision & added & alldeleted & partialdeleted & partialsurvived & singledeleted & siglesurvived & survived \\ \hline \hline
        v0.4.0 & 1303 & 0 & 0 & 0 & 0 & 0 & 0 \\
        v0.5.0 & 281 & 7 & 0 & 0 & 18 & 862 & 410 \\
        v0.6.0 & 169 & 4 & 0 & 0 & 12 & 1016 & 513 \\
        v0.7.0 & 606 & 71 & 0 & 0 & 167 & 943 & 514 \\
        v0.8.0 & 908 & 100 & 0 & 0 & 145 & 1176 & 633 \\
        v0.9.0 & 288 & 20 & 0 & 0 & 9 & 1706 & 964 \\
        v0.10.0 & 428 & 51 & 0 & 9 & 138 & 1750 & 991 \\
        v0.11.0 & 376 & 59 & 6 & 8 & 144 & 1838 & 1103 \\
        v0.12.0 & 414 & 12 & 0 & 0 & 17 & 2014 & 1255 \\
        v0.13.0 & 2380 & 63 & 0 & 10 & 57 & 2123 & 1409 \\
        v0.14.0 & 806 & 51 & 5 & 23 & 113 & 3455 & 2228 \\
        v0.15.0 & 909 & 71 & 1 & 35 & 67 & 3808 & 2482 \\
        v0.16.0 & 455 & 36 & 5 & 48 & 32 & 4191 & 2874 \\
        v0.17.0 & 1217 & 49 & 4 & 30 & 57 & 4351 & 3029 \\
        v0.18.0 & 743 & 68 & 4 & 15 & 79 & 4755 & 3664 \\
        v0.19.0 & 1476 & 168 & 3 & 48 & 206 & 4936 & 3782 \\
        v0.20.0 & 1276 & 503 & 11 & 79 & 542 & 5062 & 4009 \\
        v0.21.0 & 670 & 56 & 4 & 39 & 67 & 5742 & 4474 \\
        v0.22.0 & 129 & 1 & 1 & 34 & 1 & 6089 & 4753 \\
        v0.23.0 & 1725 & 478 & 14 & 51 & 430 & 5743 & 4250 \\
        v0.24.0 & 2593 & 504 & 12 & 35 & 601 & 6053 & 4524 \\
        v0.25.0 & 1111 & 326 & 6 & 38 & 473 & 6891 & 5443 \\
        v1.0.0 & 1284 & 496 & 10 & 61 & 522 & 6945 & 5424 \\
        v1.1.0 & 1407 & 196 & 12 & 65 & 280 & 7368 & 5765 \\
        v1.2.0 & 1544 & 279 & 7 & 53 & 217 & 7900 & 6111 \\
        v1.3.0 & 2067 & 294 & 12 & 68 & 285 & 8475 & 6441 \\
        v1.4.0 & 1477 & 260 & 15 & 56 & 170 & 9483 & 7029 \\
        v1.5.0 & 1423 & 104 & 7 & 70 & 87 & 10218 & 7500 \\
        v2.0.0 & 1376 & 345 & 17 & 1398 & 416 & 10307 & 6565 \\
        v2.1.0 & 1398 & 197 & 11 & 1577 & 147 & 10646 & 6930 \\
        v2.2.0 & 1105 & 128 & 6 & 2033 & 166 & 10886 & 7204 \\
        v2.3.0 & 319 & 16 & 3 & 2098 & 15 & 11300 & 7647 \\ \hline
    \end{tabular}
    \label{tab:placeholder}
\end{table}


\subsection{メソッドの生存期間}
\begin{figure*}[t]
    \centering
\includegraphics[width=1.0\textwidth]{./Yoshida_fig/survival.pdf}
    \caption{メソッドの生存期間}
    \label{fig:result}
\end{figure*}
メソッドごとの生存期間は図4.1に示す．\todo{この図は差し替える}

\subsection{削除されたメソッドの特徴}

\todo{クローンメソッドの片方が削除の特徴}
\begin{itemize}
    \item 非推奨APIと代替APIの両方を含むテストコードがあり，非推奨APIを含むテストコードが削除された．
\end{itemize}

\todo{結果の解釈}
同じ機能を持つメソッドのうち，生存させるメソッドと削除するメソッドがあったということは，ここに，開発者の意図が隠れている可能性がある．

\todo{クローンメソッドの両方が削除の特徴}
\begin{itemize}
    \item ファイルごと削除
    \item メソッドの中で定義されたメソッドが削除
\end{itemize}

\todo{結果の解釈}
メソッド自体が悪くなったから削除されたみたいな感じじゃなくて，プロジェクトとして，方針が変わったからファイルごと削除されたという意味付けができそう．

\todo{クローンメソッドがリファクタリングにより改善したメソッドの特徴}


\section{まとめ}

\chapter{RQ2：削除されたメソッドの特徴はルール化できるか}

\section{概要}

\section{検出ルールの作成}
\todo{RQ1で得られた，メソッドのパターンごとに検出ルールを作成}

\section{評価方法}

\section{評価結果}
\subsection{全体の検出精度}
\subsection{ルール別の検出精度}

\section{まとめ}


\chapter{考察}

\section{生存するのに削除されると予測されたのはなぜか}

\section{\todo{偽陰性の考察もするか}}

\chapter{妥当性の脅威}

\section{内的妥当性}
\todo{削除と判定したコードが本当に削除されたコードであるかはわからない．リファクタリングや移動であってもgit上では，削除と判定してしまうため．}

\section{外的妥当性}

\chapter{おわりに}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 謝辞
%%
%% \begin{acknowledgements}
%% 感謝します．
%% \end{acknowledgements}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 参考文献
%%
\bibliographystyle{junsrt}
\bibliography{@Bachelor2025_Yoshida/references}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 付録
%%
% \appendix
% 
% \chapter{サンプルプログラム}
% 
% プログラムリストや実行結果など，本論を補足する上で必要と思われるものが
% あれば付録として付ける．
% 
% {
% \footnotesize
% \begin{verbatim}
% #include <stdio.h>
% int main(void)
% {
%     printf("Hello, World!\n");
%     return 0;
% }
% \end{verbatim}
% }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
