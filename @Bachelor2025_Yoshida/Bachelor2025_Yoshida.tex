\documentclass[11pt]{jreport}
\usepackage{wuse_thesis}
\usepackage{indentfirst}
\usepackage{url}	% \url{}コマンド用．URLを表示する際に便利
\usepackage[dvipdfmx]{graphicx,xcolor}
%\usepackage{graphicx}  % ←graphicx.styを用いてEPSを取り込む場合有効にする
			% 他のパッケージ・スタイルを使う場合には適宜追加
\newcommand{\todo}[1]{\colorbox{yellow}{{\bf TODO}:}{\color{red} {\textbf{[#1]}}}}
\newcommand{\memo}[1]{\colorbox{magenta}{\textbf{MEMO}}{\color{red}\textbf{[#1]}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 主に表紙を作成するための情報
%%

%%  タイトル(修論の場合は英語表記も指定)
\title{\todo{仮}類似機能メソッドの削除実態調査と削除候補メソッドの検出手法の提案}
%\etitle{Test\\Test\\Test}

%%  著者名(修論の場合は英語表記も指定)
\author{吉田 将衛}
%\eauthor{Akinori Ihara}

%% 卒業論文・修士論文(以下のどちらかを選択)
\bachelar	% 卒業論文(4年生用)
%\master  	% 修士論文(M2用)

%%  学科・クラスタ
\department{システム工}
%\department{デザイン情報}
%\department{デザイン科学}

%%  学生番号
\studentid{60276296}

%%  卒業年度
\gyear{2025}		% 提出年が2022年なら，2021年度

%%  論文提出日
\date{2026年2月10日}	% 修士の場合は月(2021年2月)までとし，英語表記も指定
%\edate{February 2021}	% 修士の場合，こちら(英語表記)も有効化

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

%%
%%  概要
%%
\begin{abstract}
\todo{概要を考える}

\end{abstract}

%%  目次
\tableofcontents

%%  図目次 (図目次をいれたければ以下のコメントをはずす)
%\listoffigures

%%  表目次 (表目次をいれたければ以下のコメントをはずす)
%\listoftables

\newpage
\pagenumbering{arabic}	% 以降のページ番号を算用数字に

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%%  本文はここから
%%

\chapter{はじめに}

\todo{}
\memo{aaa}

\chapter{不要コードの削除}

\section{不要コードの定義}

\todo{3種類ありますよっていうことを述べる．従来研究より引用}

\subsection{デッドコード（Dead Code）}
\todo{コールグラフ上において，到達できないコード}

\memo{コード例入れるかも}

\subsection{未実行コード（Unused Code）}
\todo{特定の期間において，本番環境で実行されなかったコード}

\memo{コード例入れるかも}

\subsection{不要コード（Unnecessary Code）}
\todo{ステークホルダが関心を失ったコード←従来研究の定義}

\todo{本研究で対象とする不要コードの定義}
\begin{itemize}
    \item 過去の履歴上，削除されたコード
    \begin{itemize}
        \item 移動などにより，削除/追加されたコードはノイズ
    \end{itemize}
    \item 類似機能メソッドが存在しており，片方に代替されたメソッド
\end{itemize}

\memo{コード例入れるかも}

\section{不要コードが引き起こす問題}
\todo{リソースの浪費}

\todo{コードベースの理解阻害}

したがって，不要コードは検出し，削除することで，コードベースから取り除く必要がある．

\section{関連研究}

\subsection{デッドコードの検出}
\todo{静的解析によるデッドコードの検出}

\todo{静的解析ツールの限界}
動的依存関係の取得が困難\cite{static-analysis}


\subsection{未実行コードの検出}

\todo{ランタイム使用状況から検出}\cite{dynamic-analysis}

\todo{ランタイム使用状況取得における課題}
\begin{itemize}
    \item 長期間を要する
    \item 少なくとも一回実行されたコードは全体の2割ほどしかない
    \item 使用されていないからといって削除しても良いとは限らない
    \begin{itemize}
        \item エラー処理コード
        \item 復旧コード
        \item 移行コード
    \end{itemize}
\end{itemize}


\subsection{不要コードの検出}
\todo{静的メトリクスを用いた検出手法}

\todo{課題}


\subsection{類似機能メソッドの検出}
\todo{意味的に同じ機能を持つメソッド群の検出}

\todo{課題}
\begin{itemize}
    \item 一時的なクローンか，削除されるクローンかの識別ができない
\end{itemize}

\subsection{削除メソッドの特徴分析}
\todo{生存分析}

\section{本研究の位置付け}

\todo{既存研究の共通課題}
\begin{itemize}
    \item 削除されたメソッドの特徴を使用していない
    \item 検出した不要コードが削除されるとは限らない
\end{itemize}

\todo{既存研究との違い}
\begin{itemize}
    \item 削除されたメソッドの特徴からパターンを作成する
    \item 単体のコードではなく，類似機能メソッド群の中での役割の違いに着目
\end{itemize}


\chapter{事前分析：削除されたコードの特徴}

\section{概要}

\section{分析手法}

\section{データセット}

\section{分析結果}
\todo{依存ライブラリのバージョン更新などが原因で仕様変更が行われ，古いAPIが新しいAPIに置き換えられる時に削除が発生する．}

\section{\memo{キーアイデアとして，独立させる必要もないかも}キーアイデア}
\todo{事前分析の結果からRQに繋げる．}

\chapter{RQ1：類似機能メソッド群の生存と削除にはどのような特徴があるか}

\section{概要}

\section{分析手法}
\subsection{類似機能メソッドの検出}
対象とするOSSのGitHubのリポジトリをクローンする．
クローンしたリポジトリ内で，タグを含むコミットを全て取得する．タグを含むコミットからセマンティックバージョニングを使用しているコミットのみをフィルタリングする．
さらに，セマンティックバージョニングの末尾に「rc」や「dev」といった\todo{〇〇}が含まれるタグについては，正規表現で排除する．\todo{排除する理由}
また，パッチバージョンについては，0のみを使用する．
これらの操作によって，マイナーバージョンのタグとそのコミットのみを全て抽出できる．例えば，「v1.2.0」のようなタグとコミットを取得できる．

次に，取得したマイナーバージョンのコミットハッシュを利用して，最も古いバージョンにチェックアウトする．
そして，チェックアウトしたバージョン内の全ての「.py」ファイルを対象に抽象構文木（Abstract Syntacs Tree）へパースする．（以降，ASTとする．）このASTからクラスの定義とメソッドの定義を取得し，一意のメソッド名を構築する（「クラス名.メソッド名」という形式）．
同時にメソッドのソースコードもASTから取得しておき，N-gramでハッシュ化する．\todo{なぜASTを使用するのか}

メソッド間の類似度をN-gramから算出する．算出方法は最長共通部分文字列（以降，LCSとする）を使用する．
しかし，LCSは計算に時間がかかるため，まず，N-gramの単純な類似度でフィルタリングし，閾値0.7を超えた時点で無条件にコードクローンであると判定する．
N-gramの類似度で閾値0.7未満であったメソッドに対して，LCSを適用し，類似度を算出し，0.7を超えていれば，コードクローンであると判定する．
このコードクローンの判定には，コードクローン検出における既存研究のツールNILを使用する．\cite{NIL}\todo{なぜNILを使用するのか}\todo{コードクローンの偽陽性，偽陰性の話}

コードクローンは二つのメソッドのペアとして算出される．\todo{ペアではダメな理由}
したがって，コードクローンのペアの推移的関係を用いて，クローンペアを集約することで2つ以上のコードクローンメソッドのグループを作成する．

\subsection{削除メソッドと生存メソッドの抽出}
\todo{メソッドの追跡}リビジョン間で同じファイルパスを持ち，同じメソッド名を持つメソッドが存在すれば，それらを同じメソッドであるとする．
上記の方法で同じメソッドが存在しなかったメソッドについて，類似度で，次のリビジョンの全メソッドと総当たりで類似度を算出し，同じメソッドを追跡する．
なお，ここでの類似度の計算では，最長共通部分列（LCS）を使用している．メソッドをn-gramで表現し，ハッシュ化する．それについて，n-gramの一致度を計算し，閾値以上であれば，無条件で類似メソッドと判定し，判定されたメソッドの中から最大の類似度をもつメソッドが選出される．
また，n-gramの類似度で閾値以下であったもののみ，LCSの計算が行われ，最大の類似度を持つメソッドが閾値を超えていれば，類似するメソッドであると判定される．

\todo{メソッド追跡の限界：誤追跡}

\todo{生存メソッド：リビジョン間で類似するメソッドが存在する}

\todo{削除メソッド：リビジョン間で類似するメソッドが存在しない}

\subsection{メソッドの変遷パターンの分類}
\todo{類似しなくなったメソッドに着目}クローングループ
\begin{itemize}
    \item メソッド全体の集合を，クローンを持つメソッドと持たないメソッドに分割
    \item クローンを持たないメソッド
    \begin{itemize}
        \item 単独で削除
        \item 単独で追加
        \item 単独で生存
    \end{itemize}
    \item クローンを持つメソッド
    \begin{itemize}
        \item クローングループ内の一部のメソッドが削除
        \item クローングループ内の全てのメソッドが削除
        \item クローングループ内の一部のメソッドが生存
        \item クローングループ内の全部のメソッドが生存
    \end{itemize}
\end{itemize}


\subsection{\memo{メソッドのパターン間で差があるか}}

\section{分析結果}
\subsection{類似機能メソッドの生存実態}
\todo{メソッドの生存履歴を以下の3パターンに分類し，それぞれの頻度がどのくらいであるか}
\begin{itemize}
    \item クローンメソッドの片方が削除が非常に少ない
    \item クローンメソッドの両方が削除は少なめ
    \item クローンメソッドがリファクタリングによりクローン解消が非常に多い
\end{itemize}

\subsection{クローンの生存期間}
\begin{itemize}
    \item 0から2,000日程度で削除されるメソッドが多い
    \item 3,000日以上生存するメソッドは稀
\end{itemize}

\subsection{削除されたメソッドの特徴}

\todo{クローンメソッドの片方が削除の特徴}
\begin{itemize}
    \item 非推奨APIと代替APIの両方を含むテストコードがあり，非推奨APIを含むテストコードが削除された．
\end{itemize}

\todo{結果の解釈}
同じ機能を持つメソッドのうち，生存させるメソッドと削除するメソッドがあったということは，ここに，開発者の意図が隠れている可能性がある．

\todo{クローンメソッドの両方が削除の特徴}
\begin{itemize}
    \item ファイルごと削除
    \item メソッドの中で定義されたメソッドが削除
\end{itemize}

\todo{結果の解釈}
メソッド自体が悪くなったから削除されたみたいな感じじゃなくて，プロジェクトとして，方針が変わったからファイルごと削除されたという意味付けができそう．

\todo{クローンメソッドがリファクタリングにより改善したメソッドの特徴}


\section{まとめ}

\chapter{RQ2：削除されたメソッドの特徴はルール化できるか}

\section{概要}

\section{検出ルールの作成}
\todo{RQ1で得られた，メソッドのパターンごとに検出ルールを作成}

\section{評価方法}

\section{評価結果}
\subsection{全体の検出精度}
\subsection{ルール別の検出精度}

\section{まとめ}


\chapter{考察}

\section{生存するのに削除されると予測されたのはなぜか}

\section{\todo{偽陰性の考察もするか}}

\chapter{妥当性の脅威}

\section{内的妥当性}
\todo{削除と判定したコードが本当に削除されたコードであるかはわからない．リファクタリングや移動であってもgit上では，削除と判定してしまうため．}

\section{外的妥当性}

\chapter{おわりに}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 謝辞
%%
%% \begin{acknowledgements}
%% 感謝します．
%% \end{acknowledgements}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 参考文献
%%
\bibliographystyle{junsrt}
\bibliography{@Bachelor2025_Yoshida/references}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%
%% 付録
%%
% \appendix
% 
% \chapter{サンプルプログラム}
% 
% プログラムリストや実行結果など，本論を補足する上で必要と思われるものが
% あれば付録として付ける．
% 
% {
% \footnotesize
% \begin{verbatim}
% #include <stdio.h>
% int main(void)
% {
%     printf("Hello, World!\n");
%     return 0;
% }
% \end{verbatim}
% }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\end{document}
