
\documentclass[submit,techrep,noauthor]{ipsj}



\usepackage[dvips]{graphicx}
\usepackage{latexsym}

\newcommand{\todo}[1]{\colorbox{yellow}{{\bf TODO}:}{\color{red} {\textbf{[#1]}}}}
\newcommand{\ihara}[1]{\colorbox{green}{{\bf IHARA}:}{\color{blue} {\textbf{[#1]}}}}

\def\Underline{\setbox0\hbox\bgroup\let\\\endUnderline}
\def\endUnderline{\vphantom{y}\egroup\smash{\underline{\box0}}\\}
\def\|{\verb|}

\begin{document}


\title{CodeQLを用いた繰り返し処理を含む
\\
低速コードパターン検出手法
}

\affiliate{IPSJ}{和歌山大学\\
Wakayama University}

\author{野口 隼杜}{Noguchi Hayato}{IPSJ}[s276185@wakayama-u.ac.jp]
\author{野口 朋弥}{Noguchi Tomoya}{IPSJ}[s266227@wakayama-u.ac.jp]
\author{伊原 彰紀}{Ihara Akinori}{IPSJ}[ihara@wakayama-u.ac.jp]

\begin{abstract}
ソフトウェアの性能効率化は品質に直結する重要な課題であるが，ソースコード中に複数検出される性能ボトルネックの中から修正箇所を選定することは，開発者の経験に大きく依存している．また，プロファイラなどの動的解析ツールは，プログラムがある程度実装された後にしか適用できず，開発早期での性能改善作業を困難にしている．本研究では，この課題に対し，CodeQLによる静的解析を活用した繰り返し処理を含む低速コードパターンの早期検出手法を提案する．まず，プログラムの実行速度を比較するマイクロベンチマークを利用し，実行速度に差のある実装対から低速の原因となるコードパターンを作成する．次に，このコードパターンを基に，静的解析エンジンであるCodeQLのためのカスタムクエリを作成し，ソースコード中から該当する低速パターンを開発の早期段階で検出する．さらに，検出された箇所の依存関係を解析することで，修正が全体に与える影響や修正の優先度を推定する可能性についても言及し、より効果的な高速化修正候補の特定を目指す．ケーススタディを通じて，作成するコードパターンによる検出精度を評価するとともに，マイクロベンチマークを起点とする早期の性能改善アプローチの有用性について考察する．
\end{abstract}


\maketitle

%1
\section{はじめに}

 ソフトウェアの性能効率性は，ユーザ体験や運用コスト，さらにはシステム全体の品質に直結する重要な要素である．ここで，性能効率性の向上には，計算機能力やシステム設計の改善だけではなく，部分的なソースコードの最適化を積み重ねることで実現される場合も多い．例として，Webアプリケーション開発では，数行のコード修正による最適化を行っており，結果としてプログラムの実行時間が25％から70％高速化している(performance issues and optimization in javascript) ．

性能効率性向上のためのプログラム変更については，実装が進行するにつれて，複雑になりやすいことが定量的に明らかにされている\todo{参考文献}．また，このプログラム変更においては，保守性や可読性など，他のプログラム品質に否定的な影響を与えることもあり（A Large Scale Emprical Study of Real-Life...），プログラムが表現できる多様な実装方法の中から代替する最適な実装を選択するために，開発者に広範な知識や技量を求める．そのため，ソフトウェアの性能効率性を，実装途中の早期の段階で見積もり，性能低下の原因箇所を検出することで，性能効率性の改善におけるコストや否定的な影響を小さくできることが考えられる． 

一般的に，ソフトウェアの性能効率性を評価する方法として，プロファイラなどの動的解析ツールが広く用いられている．これらのツールは，実行時の関数呼び出しやリソース使用状況を精緻に観測し，性能低下の発見，および原因箇所の特定を可能にしている．しかし，動的解析ツールによる性能効率性の評価は，最低限の機能が実行できるまで実装が進んだ状態でなければ適用することができないため，開発初期段階において，性能効率性の評価を行うことは難しい．

ここで，実装途中においても，部分的な性能を定量的に評価する手法として，マイクロベンチマークが用いられている．マイクロベンチマークは特定のコード片に対して実行時間を測定することで局所的な性能差を把握できる．JavaScriptでは，マイクロベンチマーク共有サービスとして JsPerf*1やMeasureThat.net*2がある．これらのサービスでは，ブラウザ上でマイクロベンチマークの実行環境を提供しており，比較したいJavaScriptプログラムの対を作成し，それらを実行することで，実行速度の測定および比較ができる．また，作成したプログラム対は保存され，すべてのユーザに公開されることで，プログラム対とその結果を共有することができる．開発者はこれらのサービスやプログラムセットを活用して最適な実装方法を検討することができる．\todo{例載せる？}

しかし，マイクロベンチマークをどう設計するか，マイクロベンチマークの結果をどう解釈するかは，性能効率性向上のためのプログラム変更と同様に，開発者の技量に依るところが大きい．さらに，どの箇所を対象にマイクロベンチマークの結果を適用すべきかを判断するには，事前に潜在的な低速箇所を特定する必要がある．複数の性能問題が存在する場合には，これらに加えて，どの箇所を優先的に修正すべきかの判断も必要となるが，プログラム全体の依存関係や構造が大きく影響するため，効率的な性能改善作業を体系的に行うことは容易ではなく，マイクロベンチマークの利用における課題となっている．

これらの課題を踏まえると，性能効率性の向上を効率よく行うためには，マイクロベンチマークによって得られる局所的な性能知見を，ソースコード全体に適用可能な形で活用し，開発初期から性能上のリスクを検出することが重要である．本研究では，マイクロベンチマーク共有サービスで提供されるマイクロベンチマークを利用し，プログラム実装対の構造から低速コードパターンを抽出する．これを利用し，静的解析エンジンであるCodeQL*3を用いて，ソースコード中の類似パターンを早期に検出する手法を提案する．加えて，検出された箇所に対して依存関係を解析することで，修正がプログラム全体に与える影響や修正の優先度を推定する可能性についても検討する．これにより，動的解析に依存せずに潜在的な性能ボトルネックを実装初期段階から特定し，修正効果の高い箇所を効率的に見出すことを目指す．

続く\ref{sec2:format}章では，本研究で利用するマイクロベンチマーク共有サービスにおけるマイクロベンチマークの特徴に触れ，キーアイデアを示す．\ref{sec3:format}章 では，本研究の提案手法を述べ， \ref{sec4:format}章において，ケーススタディの結果について述べる． \ref{sec5:format}章で考察を行い，\ref{sec6:format}章で本研究における妥当性の脅威を述べた上で，\ref{sec7:format}章で総括する． 


%2
\section{マイクロベンチマークに基づく性能ボトルネック検出}
\label{sec2:format}

%2.1
\subsection{マイクロベンチマーク共有サービスにおける実装対}

本研究では，大森ら\todo{参考文献}が作成した，マイクロベンチマーク共有サービスjsPerfにおける，実行速度に有意差があり，外的振る舞いが等しいことが検証された実装対29,809件を利用する．以降，これらの実装対をマイクロベンチマーク実装対とする．

マイクロベンチマーク実装対には多様な実装方法が含まれるが，\todo{図1で示すように} 繰り返し処理を含む実装対が全体の約43％（12,948対）存在する．マイクロベンチマーク実装対を目視調査した結果，効果的に実行速度の差を測定するために巨大な配列や長大な繰り返し処理を用いている実装対が含まれる一方，繰り返し処理自体の違いによって実行速度に差が生まれる実装対が混在していることがわかった．したがって，本研究では，マイクロベンチマーク実装対に対し，繰り返し処理に注目し，その特徴を分析する．具体的には，抽象構文木によるプログラム構造から実装対における共有部分と，それぞれの実装の固有部分をわけ，低速コードと高速コードの構造的差分によって繰り返し処理がどのように扱われているかを判定する．マイクロベンチマーク実装対にこの処理を行った結果，Listing1，Listing2，Listing3 に示すような実装対が含まれていることを確認した．\todo{Liting1}では繰り返し処理における操作の違いを比べており，効果的に実行速度の差を測定するために繰り返し処理を利用している実装対である．\todo{Listing2}では繰り返し処理の違いが実行速度の差になっている実装対であり，\todo{Listing3}では繰り返し処理に代替する手段についての実装対である．\todo{差分で分析した話（手元のデータの説明）をどこまで入れるか}


%2.2
\subsection{関連研究}

\todo{関連研究とその内容}
案

・高速化リファクタリングが小さな単位で行われている話→マイクロベンチマークの利用可能性

・低速パターンを組んだ話→より広範なプログラムを対象としたい

・動的解析による修正パターン作成→静的解析でやる

・LLMによるセマンティックコードサーチ→文字列的等価と意味的等価性の絶妙なところをつきたいけどまだLLMには難しい，性能効率性に注目してる

本研究では，繰り返し処理に注目し，マイクロベンチマーク実装対における低速コードから構造的差分に基づいて低速コードパターンを抽出し，静的解析を用いて，性能ボトルネックの早期検出を行う．


%3
\section{CodeQLを用いた低速コードパターン検索手法}
\label{sec3:format}

\todo{図2}に，本研究で提案する手法の概略図を示す．本研究では，マイクロベンチマーク実装対より，低速コードの特徴を，実装対の構造的差分から抽出し，パターンを作成，静的解析エンジンCodeQLを用いて，ソースコード中の低速コード＝潜在的な性能ボトルネックを静的に検出する手法を提案する．以降でその詳細を述べる．

%3.1
\subsection{低速コードパターンの抽出}

2章1節で示すように，マイクロベンチマーク実装対には多様な実装方法が存在し，繰り返し処理の意味も実装対によって異なる．本研究では，低速コードの特徴としてパターンを抽出するために，抽象構文木による構造的差分に注目してパターンの抽出を行う．GumTree\todo{参考文献}を用いて，低速コードから高速コードへの変更差分とその操作を取得し，変更差分に繰り返し処理を含む実装対について，削除および更新操作であると判定された変更差分を低速コードの特徴として扱う．本研究で利用する低速コードパターンを\todo{表1}に示す．

%3.2
\subsection{低速コードパターンの検出}

%3.3
\subsection{依存関係に基づく優先順位づけ}

%4
\section{ケーススタディ}
\label{sec4:format}


%4.1
\subsection{データセット}

ケーススタディとして，プログラムバージョン管理システムであるGitHubで公開されている，主要言語がJavaScript，\todo{要検討}スター数が100以上，最終コミットが1年以内，\todo{要検討}クエリによる検出結果がn件以上のxプロジェクトを選定した．\todo{表}の左から1列目にプロジェクト一覧を示し，各プロジェクトの特徴量？統計量？を示す．

%4.2
\subsection{低速コードパターンの検出}

%4.2.1
\subsubsection{マイクロベンチマークへの適用}

この章は必要ないかも（自前でやって様子見る感じ？）

%4.2.2
\subsubsection{実プロジェクトへの適用}
\label{sec4.2.2:Item}

ともやさん頑張って


%4.3
\subsection{依存関係に基づく修正の優先度}
\label{sec:Item}

\ref{sec4.2.2:Item}で真陽性と判定した修正候補を含む関数を対象に依存関係を構築し，優先度をつける

%4.3.1
\subsubsection{依存関係による重みづけ}

呼び出している回数および呼び出されている回数の和を修正優先度とする

%4.3.2
\subsubsection{修正と実行時間差}

テストの実行時間で比較


%5
\section{考察}
\label{sec5:format}

論文の内容について，
論文誌ジャーナル編集委員会で作成した「べからず集」を以下に示す．
投稿前のチェックリストとして利用頂きたい．
これ以外にも，査読者用，
メタ査読者用の「べからず集」\cite{webpage2}も公開しているので，
参照されたい．
また，作文技術に関する \cite{book1, book2, book3, book4}のような書籍も参考になる．



%5.1
\subsection{検出結果}

低速コードパターンの抽出とクエリへのマッピングの流れ
なぜその結果か
何が言えるか

%5.2
\subsection{依存関係に基づく修正}

なぜその結果か
依存関係を見ることは意味があるか・他の指標は何か

%6
\section{妥当性の脅威}
\label{sec6:format}

%6.1
\subsection{内的妥当性}


%6.2
\subsection{外的妥当性}


%7
\section{おわりに}
\label{sec7:format}


\begin{acknowledgment}
ありがとうございました．
\end{acknowledgment}



\bibliographystyle{ipsjunsrt}
\bibliography{bibsample}

\end{document}
