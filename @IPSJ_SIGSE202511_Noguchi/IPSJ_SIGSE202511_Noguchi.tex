
\documentclass[submit,techrep,noauthor]{ipsj}



\usepackage[dvips]{graphicx}
\usepackage{latexsym}
\usepackage{url}

\newcommand{\todo}[1]{\colorbox{yellow}{{\bf TODO}:}{\color{red} {\textbf{[#1]}}}}
\newcommand{\ihara}[1]{\colorbox{green}{{\bf IHARA}:}{\color{blue} {\textbf{[#1]}}}}

\def\Underline{\setbox0\hbox\bgroup\let\\\endUnderline}
\def\endUnderline{\vphantom{y}\egroup\smash{\underline{\box0}}\\}
\def\|{\verb|}

\begin{document}


\title{CodeQLを用いた繰り返し処理を含む
\\
低速コードパターン検出手法
}

\affiliate{IPSJ}{和歌山大学\\
Wakayama University}

\author{野口 隼杜}{Noguchi Hayato}{IPSJ}[s276185@wakayama-u.ac.jp]
\author{野口 朋弥}{Noguchi Tomoya}{IPSJ}[s266227@wakayama-u.ac.jp]
\author{伊原 彰紀}{Ihara Akinori}{IPSJ}[ihara@wakayama-u.ac.jp]

\begin{abstract}
ソフトウェアの性能効率化は品質に直結する重要な課題であるが，ソースコード中に複数検出される性能ボトルネックの中から修正箇所を選定することは，開発者の経験に大きく依存している．また，プロファイラなどの動的解析ツールは，プログラムがある程度実装された後にしか適用できず，開発早期での性能改善作業を困難にしている．本研究では，この課題に対し，CodeQLによる静的解析を活用した繰り返し処理を含む低速コードパターンの早期検出手法を提案する．まず，プログラムの実行速度を比較するマイクロベンチマークを利用し，実行速度に差のある実装対から低速の原因となるコードパターンを作成する．次に，このコードパターンを基に，静的解析エンジンであるCodeQLのためのカスタムクエリを作成し，ソースコード中から該当する低速パターンを開発の早期段階で検出する．さらに，検出された箇所の依存関係を解析することで，修正が全体に与える影響や修正の優先度を推定する可能性についても言及し、より効果的な高速化修正候補の特定を目指す．ケーススタディを通じて，作成するコードパターンによる検出精度を評価するとともに，マイクロベンチマークを起点とする早期の性能改善アプローチの有用性について考察する．
\end{abstract}


\maketitle

%1
\section{はじめに}

 ソフトウェアの性能効率性は，ユーザ体験や運用コスト，さらにはシステム全体の品質に直結する重要な要素である．ここで，性能効率性の向上には，計算機能力やシステム設計の改善だけではなく，部分的なソースコードの最適化を積み重ねることで実現される場合も多い．例として，Webアプリケーション開発では，数行のコード修正による最適化を行っており，結果としてプログラムの実行時間が25％から70％高速化している\cite{jsRefac}

性能効率性向上のためのプログラム変更については，実装が進行するにつれて，複雑になりやすいことが定量的に明らかにされている\cite{complicate}．また，このプログラム変更においては，保守性や可読性など，他のプログラム品質に否定的な影響を与えることもあり\cite{negative}，プログラムが表現できる多様な実装方法の中から代替する最適な実装を選択するために，開発者に広範な知識や技量を求める．そのため，ソフトウェアの性能効率性を，実装途中の早期の段階で見積もり，性能低下の原因箇所を検出することで，性能効率性の改善におけるコストや否定的な影響を小さくできることが考えられる． 

一般的に，ソフトウェアの性能効率性を評価する方法として，プロファイラなどの動的解析ツールが広く用いられている．これらのツールは，実行時の関数呼び出しやリソース使用状況を精緻に観測し，性能低下の発見，および原因箇所の特定を可能にしている．しかし，動的解析ツールによる性能効率性の評価は，最低限の機能が実行できるまで実装が進んだ状態でなければ適用することができないため，開発初期段階において，性能効率性の評価を行うことは難しい．

ここで，実装途中においても，部分的な性能を定量的に評価する手法として，マイクロベンチマークが用いられている．マイクロベンチマークは特定のコード片に対して実行時間を測定することで局所的な性能差を把握できる．JavaScriptでは，マイクロベンチマーク共有サービスとして JsPerf\footnote{\url{https://jsperf.app/}}やMeasureThat.net\footnote{\url{https://measurethat.net/}}がある．これらのサービスでは，ブラウザ上でマイクロベンチマークの実行環境を提供しており，比較したいJavaScriptプログラムの対を作成し，それらを実行することで，実行速度の測定および比較ができる．また，作成したプログラム対は保存され，すべてのユーザに公開されることで，プログラム対とその結果を共有することができる．開発者はこれらのサービスやプログラムセットを活用して最適な実装方法を検討することができる．

しかし，マイクロベンチマークをどう設計するか，マイクロベンチマークの結果をどう解釈するかは，性能効率性向上のためのプログラム変更と同様に，開発者の技量に依るところが大きい．さらに，どの箇所を対象にマイクロベンチマークの結果を適用すべきかを判断するには，事前に潜在的な低速箇所を特定する必要がある．複数の性能問題が存在する場合には，これらに加えて，どの箇所を優先的に修正すべきかの判断も必要となるが，プログラム全体の依存関係や構造が大きく影響するため，効率的な性能改善作業を体系的に行うことは容易ではなく，マイクロベンチマークの利用における課題となっている．

これらの課題を踏まえると，性能効率性の向上を効率よく行うためには，マイクロベンチマークによって得られる局所的な性能知見を，ソースコード全体に適用可能な形で活用し，開発初期から性能上のリスクを検出することが重要である．本研究では，マイクロベンチマーク共有サービスで提供されるマイクロベンチマークを利用し，プログラム実装対の構造から低速コードパターンを抽出する．これを利用し，静的解析エンジンであるCodeQL*3を用いて，ソースコード中の類似パターンを早期に検出する手法を提案する．加えて，検出された箇所に対して依存関係を解析することで，修正がプログラム全体に与える影響や修正の優先度を推定する可能性についても検討する．これにより，動的解析に依存せずに潜在的な性能ボトルネックを実装初期段階から特定し，修正効果の高い箇所を効率的に見出すことを目指す．

続く\ref{sec2:format}章では，本研究で利用するマイクロベンチマーク共有サービスにおけるマイクロベンチマークの特徴に触れ，キーアイデアを示す．\ref{sec3:format}章 では，本研究の提案手法を述べ， \ref{sec4:format}章において，ケーススタディの結果について述べる． \ref{sec5:format}章で考察を行い，\ref{sec6:format}章で本研究における妥当性の脅威を述べた上で，\ref{sec7:format}章で総括する． 


%2
\section{マイクロベンチマークに基づく性能ボトルネック検出}
\label{sec2:format}


%2.1
\subsection{マイクロベンチマーク共有サービスにおける実装対}

本研究では，大森ら\cite{omori}が作成した，マイクロベンチマーク共有サービスjsPerfにおける，実行速度に有意差があり，外的振る舞いが等しいことが検証された実装対29,809件を利用する．以降，これらの実装対をマイクロベンチマーク実装対とし，各実装対において実行時間が長いコードを低速コード，実行時間が短いコードを高速コードとする．
マイクロベンチマーク実装対は，同一の機能を異なる方法で実装した非常に短いコードの対によって構成されており，データ構造や制御構文，使用するメソッドの選択などに多様性が見られる．これらの実装対を目視調査した結果，実装対の両方もしくは片方に繰り返し処理を含むものが多く存在することが確認された．特に，巨大な配列や長大な繰り返し処理を用いて性能差を強調する実装対や，繰り返し処理自体の違いによって実行時間に差が生まれる実装対など，複数の傾向が確認された．


%2.2
\subsection{繰り返し処理を含むマイクロベンチマーク実装対}

このような観察結果から，本研究ではマイクロベンチマーク実装対に対して繰り返し処理構造に着目した特徴分析を行うこととした．対象とする繰り返し処理は，JavaScriptにおける for，for-of，for-in，while，および do-while 構文である．

% \todo{図1で示すように} 繰り返し処理を含む実装対が全体の約43％（12,948対）存在する．

分析にあたっては，各実装対のソースコードを GumTree \cite{gumtree}により抽象構文木へと変換し，実装対の抽象構文木間の差分解析を行った．差分解析の結果に対して，(1) 差分が直接繰り返し処理構造を含むか，および (2) 差分ノードの構造的な親要素に繰り返し処理が含まれるかを確認事項とし，反復処理に関連する差分要素として収集した．抽出された箇所に応じて目視で確認を行い，実装対の構造的特徴および性能差との関係を整理した．
この分析の結果，マイクロベンチマーク実装対には繰り返し処理について，Listing1，Listing2，Listing3に示すようなパターンが存在することが明らかとなった．Listing 1は，それぞれfor文内でpush メソッドを用いた実装とconcat メソッドを用いた実装である．これは，繰り返し処理の構造は一致しているが，繰り返し内部で実行する処理が異なるパターンである．Listing 2は，それぞれ，for-in文を用いて配列の全要素にアクセスする実装と，同様の処理をfor文で実装したものである．ここで示すパターンは実行時間の差が，繰り返し処理自体の違いに起因するパターンである．Listing 3は，繰り替え処理をforEachメソッドで実装したものとfor-of文で実装したものである．これは，繰り返し処理をメソッドなどの代替手段と比較したパターンである．\todo{それぞれの図}

これらの結果から，マイクロベンチマーク実装対には繰り返し処理の構造および繰り返し内部の操作内容の違いが性能差の主な要因として存在することが確認された．本研究では，このような繰り返し処理に関する差分構造を低速コードの特徴として抽出し，次章で述べる低速コードパターンの抽出および静的検出に利用する．


%2.3
\subsection{関連研究}

Selakovic ら\cite{jsRefac}は，JavaScript プロジェクトにおいて，開発者が高速化のために行ったリファクタリングを調査した．その結果，開発者は10行程度の小さい範囲の修正によって高速化への対処を行なっていることを明らかにした．この結果は，マイクロベンチマーク実装対に見られる，短いコードの高速化への利用可能性を示すものとして，本研究の動機づけとなっている．また，\cite{jsRefac}は，JavaScript プロジェクトの解析によって 10 件の頻出する高速化改良パターンを作成している．この改良パターンを用いた自動修正は一定の高速化効果を示しているが，システム上で効果的な修正箇所はどこかについては議論していない．

Turcotte ら\cite{DrAsync}は，JavaScript 言語における非同期処理に注目した性能アンチパターンを定義し，静的解析エンジンであるCodeQLを利用したアンチパターンの検出と，動的解析を利用したパフォーマンスの監視を組み合わせ，修正可能な性能アンチパターンの検出を行った．本研究の静的解析による低速コードパターンの検出はこれに着想を得ている．

大森ら\cite{omori}は，マイクロベンチマーク共有サービスで公開される実行速度が向上するプログラムを収集し，これをデータセットとして大規模な言語学習モデルをファインチューニングすることで，実行を高速化するプログラムに自動リファクタリングするモデルを作成した．この結果，マイクロベンチマーク共有サービス上のプログラムに対しては，ChatGPT-4o より約3倍のリファクタリングに成功している．しかし，\cite{jsRefac}と同様，効果的な修正箇所についての議論はない．
 
本研究では，繰り返し処理に注目し，マイクロベンチマーク実装対における低速コードから構造的差分に基づいて低速コードパターンを抽出し，静的解析を用いて，性能ボトルネックの早期検出を行うとともに，プログラム上の依存関係を用いた，効果的な修正箇所の推定について議論する．


%3
\section{CodeQLを用いた低速コードパターン検索手法}
\label{sec3:format}

\todo{図2}に，本研究で提案する手法の概略図を示す．本研究では，マイクロベンチマーク実装対より，低速コードの特徴を実装対の構造的差分から抽出し，低速コードパターンを作成する．作成したパターンをもとに静的解析エンジンCodeQLを用いて，ソースコード中の低速コードを静的に検出する手法を提案する．以降でその詳細を述べる．


%3.1
\subsection{低速コードパターンの抽出}

2章1,2節で示すように，マイクロベンチマーク実装対には多様な実装方法が存在し，繰り返し処理の意味も実装対によって異なる．本研究では，低速コードの特徴としてパターンを抽出するために，抽象構文木による構造的差分に注目してパターンの抽出を行う．GumTree\todo{参考文献}を用いて，低速コードから高速コードへの変更差分とその操作を取得し，変更差分に繰り返し処理を含む実装対について，削除および更新操作であると判定された変更差分を低速コードの特徴として扱う．本研究で利用する低速コードパターンを\todo{表1}に示す．


%3.2
\subsection{低速コードパターンの検出}


%3.3
\subsection{依存関係に基づく優先順位づけ}


%4
\section{ケーススタディ}
\label{sec4:format}


%4.1
\subsection{データセット}

ケーススタディとして，プログラムバージョン管理システムであるGitHubで公開されている，主要言語がJavaScript，\todo{要検討}スター数が100以上，最終コミットが1年以内，\todo{要検討}クエリによる検出結果がn件以上のxプロジェクトを選定した．\todo{表}の左から1列目にプロジェクト一覧を示し，各プロジェクトの特徴量？統計量？を示す．

%4.2
\subsection{低速コードパターンの検出}

%4.2.1
\subsubsection{マイクロベンチマークへの適用}

この章は必要ないかも（自前でやって様子見る感じ？）

%4.2.2
\subsubsection{実プロジェクトへの適用}
\label{sec4.2.2:Item}

ともやさん頑張って


%4.3
\subsection{依存関係に基づく修正の優先度}
\label{sec:Item}

\ref{sec4.2.2:Item}で真陽性と判定した修正候補を含む関数を対象に依存関係を構築し，優先度をつける

%4.3.1
\subsubsection{依存関係による重みづけ}

呼び出している回数および呼び出されている回数の和を修正優先度とする

%4.3.2
\subsubsection{修正と実行時間差}

テストの実行時間で比較


%5
\section{考察}
\label{sec5:format}

論文の内容について，
論文誌ジャーナル編集委員会で作成した「べからず集」を以下に示す．
投稿前のチェックリストとして利用頂きたい．
これ以外にも，査読者用，
メタ査読者用の「べからず集」\cite{webpage2}も公開しているので，
参照されたい．
また，作文技術に関する \cite{book1, book2, book3, book4}のような書籍も参考になる．



%5.1
\subsection{検出結果}

低速コードパターンの抽出とクエリへのマッピングの流れ
なぜその結果か
何が言えるか

%5.2
\subsection{依存関係に基づく修正}

なぜその結果か
依存関係を見ることは意味があるか・他の指標は何か

%6
\section{妥当性の脅威}
\label{sec6:format}

%6.1
\subsection{内的妥当性}


%6.2
\subsection{外的妥当性}


%7
\section{おわりに}
\label{sec7:format}


\begin{acknowledgment}
ありがとうございました．
\end{acknowledgment}



\bibliographystyle{ipsjunsrt}
\bibliography{bibnoguchi}

\end{document}
