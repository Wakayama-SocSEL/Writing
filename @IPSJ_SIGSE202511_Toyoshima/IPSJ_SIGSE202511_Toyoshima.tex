\documentclass[submit,techrep,noauthor]{ipsj}


\usepackage[dvipdfmx]{graphicx}
\usepackage{latexsym}
\usepackage{url}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{amsmath,amssymb}
\usepackage{tabularx}
\usepackage{stfloats}
\usepackage{booktabs}
\usepackage{threeparttable}
\usepackage{caption}

\newcounter{patternID}

% コード例を載せるためのあれこれ
\definecolor{lightred}{RGB}{255,230,230}
\definecolor{lightgreen}{RGB}{230,255,230}

\lstset{
    basicstyle=\small\ttfamily,
    abovecaptionskip=0pt,
    captionpos=b,
    frame=tb,
    framexleftmargin=2em,
    numbers=left,
    numberstyle={\scriptsize},
    xleftmargin=\parindent,
    escapechar=|
}

%ListingのキャプションがFigureになってしまうのをListingに直すコマンド
\usepackage{caption}
\makeatletter
\let\MYcaption\@makecaption
\makeatother
\usepackage{caption}
\makeatletter
\let\@makecaption\MYcaption
\makeatother

\newcommand{\todo}[1]{\colorbox{yellow}{{\bf TODO}:}{\color{red} {\textbf{[#1]}}}}
\newcommand{\memo}[1]{\colorbox{magenta!30}{{\bf MEMO}:}{\color{red!50} {\textbf{[#1]}}}}
\newcommand{\ihara}[1]{\colorbox{green}{{\bf IHARA}:}{\color{blue} {\textbf{[#1]}}}}

\def\Underline{\setbox0\hbox\bgroup\let\\\endUnderline}
\def\endUnderline{\vphantom{y}\egroup\smash{\underline{\box0}}\\}
\def\|{\verb|}
%

\def\Underline{\setbox0\hbox\bgroup\let\\\endUnderline}
\def\endUnderline{\vphantom{y}\egroup\smash{\underline{\box0}}\\}
\def\|{\verb|}

\begin{document}


\title{大規模言語モデルによるコード生成のための反復的な要件統合と最適化プロセス\\}

\affiliate{IPSJ}{情報処理学会\\
IPSJ, Chiyoda, Tokyo 101--0062, Japan}


\paffiliate{JU}{情報処理大学\\
Johoshori Uniersity}

\author{豊嶋 浩基}{Toyoshima Hiroki}{WU}[s276157@wakayama-u.ac.jp]
\author{伊原 彰紀}{Ihara Akinori}{WU}[ihara@wakayama-u.ac.jp]
\author{田井 聖凪}{Tai Sena}{WU}[s2310137@wakayama-u.ac.jp]

\begin{abstract}
大規模言語モデル (LLM) はソフトウェア開発自動化に大きく貢献するが，複雑な要件を持つソフトウェア開発の実現には課題が多い．
本研究は，自然言語からソースコードを自動生成するマルチエージェント型フレームワークChatDevを拡張し，few-shotを用いた要件の細分化と各ステップの開発を行うLLMに要件の全体概要の学習によるコード自動生成並びに，生成ステップ毎の差分行数に基づく要件の統合及び，統合結果を分割例と再分割を組み合わせた反復的に進める開発プロセスを提案する．
ケーススタディとして，競技プログラミングサイトであるAtCoderの問題を題材に，この提案手法を実施した結果，few-shotと全体概要の共有の組み合わせによりテスト通過率が向上し，統合に基づく要件の再分割により生成されたコードはさらに性能を向上させうることを明らかにした．

% と段階的開発を実施した．これにより，入出力テストに基づいた性能の向上が確認できた一方で，局所的な最適化に留まり，システム全体の品質に課題を残す．
% そのため本研究では，分割された要件の統合と反復的改善の概念を組み合わせた新たな開発プロセスを提案する．具体的には，分割・生成されたコード群を対象に，全体の整合性を評価し，再統合と洗練を行うイテレーションを導入する．この反復的な最適化プロセスは，複雑なソフトウェア要件に対するコード生成品質を一段階引き上げるための，新たな開発指針となることを目指す．
\end{abstract}

\maketitle

%%%%%%%%%%%%%%%%%%%%%%%%%%%
%1
\section{はじめに}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

大規模言語モデル (LLM) 技術の急速な発展に伴い\cite{Growing_LLM}，LLMはこれまで人間が時間や労力をかけていたタスクの自動化を実現し，幅広い分野の作業を効率化する技術として関心を集めている．
ソフトウェア開発においても，コードレビュー，リファクタリング，テストケース生成など，様々な場面において飛躍的に生産性を向上することが確認されている\cite{LLM_CodeReview}\cite{LLM_Refactoring}\cite{LLM_Gene_Test}．
その中でも，開発者の意図や要件をプロンプトとして提示し，ソースコードの自動生成には期待が大きい\cite{LLM_CodeGeneration}.

LLMは，自然言語で記述された要求文に基づきソースコードの自動生成を実現し，昨今では複雑で，大規模なソフトウェア開発の自動化に向けた研究が進められている\cite{LLM_CodeGeneration}．
一部の要求は実現できる一方で，複数のソフトウェア要件が内包し，それぞれが相互に依存し合う大規模なソフトウェア要件を満たすソースコード生成には課題が多い
従来研究ではソフトウェア要件が複雑になると，LLMが十分に推論せずに，短絡的なソースコードを生成する．
例えば，仕様の一部が欠損している場合や，要件の文脈を正しく理解できていない場合には，ロジック誤りが生じることがある．
これは，要件文から要求を抽出し，それらを基にコードを生成する，という流れをLLMが実施するが，複雑な要件からコードを生成する場合，LLMは追加の情報無しに正しく要求を抽出する事が困難であることが原因の1つであると考えられる．

LLMの理解や推論を補助するプロンプト技術として，思考の過程を明示的に示すChain of Thought (CoT) や，要求を満たす例を少数提示するfew-shot学習が用いられているが，\cite{LLM_fewshot} これらは局所的な推論の補完や思考パターンの学習には有効である一方で，プログラミング言語のように記述方法や実装方法によって同一の要件に対して多様な解が存在する領域では，これらの手法のみでは十分な性能を発揮しにくい．

これに対して先行研究では，全体の流れをfew-shot学習を用いて要件を抽出するフェーズと，それらを基にコードを生成するフェーズの2つに分割する手法が取り入れられており\cite{tosem}．
前者では，大量のデータ収集やそれに対するラベリング，再学習などを要するファインチューニングと比較して，追加学習をようさずにLLM挙動を制御できることからfew-shot学習が採用されている．
同研究では，複数の機能を個別に生成し，生成されたコード断片を最終的に結合する構造では，各断片における前提が共有されず，関数やファイル単位での依存関係や，グローバル変数の扱いや，エラーハンドリングなど，ソースコード単位での整合性が破綻してしまう可能性についても示唆されている．


以上のことから，本研究では要求抽出の不安定さや，段階的開発におけるコードの断片化対して，複雑な要件の細分化および，細分化した要件ごとの開発における全体整合を実施することでソースコード自動生成を実現する．
さらに，細分化した要件をベースとして生成したソースコードを評価し，要件の統合と再分割によるソースコード自動生成を複数回繰り返すことでプロンプト作成の最適化を目指す開発プロセスを提案する．
本手法により，各工程下でLLMに対して全体概要を明示的に提示や，分割した要件の統合と再分割を繰り返すことで，マルチエージェント型コード自動生成の品質を向上を期待する．


論文構成は以下の通りである．\ref{sec:related}章で本研究で使用するフレームワークやキーアイディアのベースとなる関連研究について，\ref{sec:method}章ではそれらに基づいたアプローチを述べ，\ref{sec:evaluation}章でそのアプローチに関する実験設定やRQを列挙し，\ref{sec:result}章でそれに対する結果を提示する．\ref{sec:discussion}章で考察と妥当性の脅威について議論した上で，\ref{sec:conclusion}章で結論を述べる．


%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2
\section{関連研究}
\label{sec:related}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

%2.1
\subsection{ChatDev: マルチエージェントによる段階的開発フレームワーク}
LLMを活用したソフトウェア開発を自動化を目的としたシステムとして，MetaGPT，AutoDevなどの開発が盛んに進められている\cite{metagpt} \cite{autodev}．
本システムは，ソフトウェア開発プロセスにおける各工程（要求定義，設計，実装，テスト，保守）を自然言語理解と生成能力により自動化する仕組みである．
本研究では，各工程の役割を担うLLMエージェントがそれぞれ要件定義から実装までを実現するChatDev\cite{qian-etal-2024-chatdev}を用いる．

ChatDevは，要件定義，設計，実装をウォーターフォールモデルに則って開発を進める過程で，各工程においてプログラマやプロダクトマネージャといった役割を与えられた2つのLLMエージェントが対話しながら開発を行うプラットフォームである．
各工程では，開発を担当するエージェントが，プロンプトで与えられた要件文，または前工程で生成された成果物（ソースコードやそこに含まれるコメントなど）に基づき，新たな成果物を生成する．生成した成果物は別の検証を担当するエージェントと共有される．
共有を受けたエージェントは，成果物を検証し，開発と検証を担当するエージェント間で合意形成を図って，成果物を完成する．

ChatDevの枠組みは，各工程のタスクが明確である点や，フレームワークがオープンソースとして公開されており，自体の構造の確認，書き換えが可能であるため，拡張性に優れている．
一方で，各工程で開発を担当するLLMに対して，同一の要件（プロンプト）が与えられるため，多数の機能を内包するような複雑・大規模な要件の場合，各フェーズでのタスクの粒度が大きくなり，不完全なコードが生成されやすくなってしまう．


%2.2
\subsection{LLMによるソフトウェア開発自動化の課題}
Shojaeeら\cite{IllusionApple}は，複雑度の制御が可能かつ，解法が明確な数学的パズル問題を用いて，LLMの最終的な解とそこに至るまでの推論過程を調査した．
その結果，難易度が上昇するにつれて正答率は緩やかに低下すると同時に，複雑度が一定の閾値を超えるまでは推論過程でのテキスト長が増加するのに対して，閾値を超えた場合には急激に低下し，LLMの推論精度が低下する
加えて，推論過程の調査により，複雑度が低い場合に正解には早く到達するが，その後も不要に探索を続けてしまう過剰な推論ステップを踏んでしまう事が確認されており，このようなLLMの挙動は，高い推論能力を要する自然言語からのコード自動生成においても同様に再現されうるものである．
複数の要求を内包する複雑な要件文からは，依存関係の見落としや，断片化したコードの生成により，全体整合性の破綻が発生しやすい．

Jiangら\cite{tosem}は，few-shotによりLLMを用いて要件文から小さな実装単位の小要件へ分割を行う「計画フェーズ」と，分割後の要件を基に開発を行なっていく実装フェーズを組み合わせた手法を提案している．

計画フェーズにおいて分割例をfew-shotで提示する事で分割を実施することで，要件1つあたりをShojaeeらが報告する最適な粒度への均一化する事を目指している．
以上により，本研究が提案する分割後要件の粒度の最適化を図る「要件の細分化」と「細分化後要件の統合と再分割」は，LLMの推論の最適化プロセスの1つとして重要である．

実装フェーズにおいて分割した小要件から各々で断片的に開発を実施するのではなく，分割した要件を実装のガイドとして扱い，コード生成は一度に生成する構造がもっとも高性能であると報告している．
これは，要件からコード断片を複数生成し，最終的に結合を行う方式は，コンテキストの欠如により，インタフェースやデータ構造の不整合が発生しやすいことが主な原因であると言及している．本研究では，プロンプトとその時点で作成された成果物から開発を実施する構造をとるChatDevを用いる事で，段階的開発を実施しながらも，断片化を回避する手法について調査する．


\ihara{ここまで確認済み}

%%%%%%%%%%%%%%%%%%%%%%%%%%%
%3
\section{要件分割と要件統合に基づく段階的ソースコード生成}
\label{sec:method}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

%--------------------
\begin{figure*}[t]
    \centering
    \includegraphics[width=1.0\linewidth]{./Toyoshima_fig/approach_abst_v3.pdf}
    \caption{アプローチの概要図}
    \label{approach_abst}
\end{figure*}
%--------------------

\subsection{概要}
従来のChatDev\cite{qian-etal-2024-chatdev} は，単一のプロンプトから設計→コーディング→レビュー→テストとウォーターフォールモデルの流れに基づいて一括で実施し，ソースコードを生成する構造をとており，分割した要件に沿って段階的に開発を進める仕組みを持たない．
それに対して本研究では，分割された要件文からそれに対応する開発が実施できるように構造を拡張し，ソフトウェアの生成精度の向上を目指す．
この時，ウォーターフォールモデルの流れを各要件に対応する開発においても実施するものとする．

具体的には，本手法は要求分を要件に細分化する「計画フェーズ」と，細分化された要件を基にコードの生成を行う「実装フェーズ」,実装フェーズで生成されたコードを基に要件を統合と再分割を実施する「再計画フェーズ」の3フェーズで構成する．図\ref{approach_abst}は，本手法の概略図を示す．

計画フェーズでは，ソフトウェアの要求文をLLMに対してfew-shot学習を実施することで，要求文を要件に細分化する．

実装フェーズでは，細分化された要件を段階的に順に実装を進める各ステップでLLMには3種類のデータを入力する．
(1) 実装する要件文，(2) 分割前の要求文，(3) 2つ目以降の要件の実装時には，それまでに開発された成果物．
これらのデータに基づき，各要件をLLMにより実装する．

再計画フェーズでは，分割されたコードの結果を基に要件の統合を実施し，統合した要件をLLMに学習させる事により要求から要件への再分割を実施する．

これらにより，入出力テストの通過率向上を目指す．

% 分割済みの要件から段階的に開発を進める各ステップにおいて，LLMには開発を担当する分割後の小要件とそれまでに開発された成果物(設計・コード・テストなど)に加えて，分割前の要件を全体概要が提示され，それを基に開発が進められる．ここでいう全体概要とは，細分化した要件を論理順に統合したものを指す．このような全体概要を開発を担当する全てのLLMに与える事により，2.3節で議論されていた開発の断片化を防ぎ，全体整合性の担保を目指す．

% 本論文におけるアプローチでは，2.3節の方針に基づいて，自然言語の要件文をLLMを用いて細分化を行う「計画フェーズ」と，2.1節で示したChatDevの機能を拡張し，段階的に開発を実施する「実装フェーズ」の2フェーズをベースとする．

% また，2フェーズにより生成されたコードに基づいて，計画フェーズで細分化した要件の統合及び，細分化を実施する．統合により分割粒度の最適化を図り，再分割により依存関係や，要求の補正を狙いとする．具体的な分割規則や，拡張設計及び統合・再分割の指標は後続の節で説明する．

% 図\ref{approach_abst}で示す〜〜．\todo{どこかに入れる}


% %3.1
% \subsection{全体概要に基づく段階的開発}
% 本研究では，分割済みの要件から段階的に開発を進める各ステップにおいて，LLMには開発を担当する分割後の小要件とそれまでに開発された成果物(設計・コード・テストなど)に加えて，分割前の要件を全体概要が提示され，それを基に開発が進められる．ここでいう全体概要とは，細分化した要件を論理順に統合したものを指す．このような全体概要を開発を担当する全てのLLMに与える事により，2.3節で議論されていた開発の断片化を防ぎ，全体整合性の担保を目指す．

%3.2
\subsection{計画フェーズ}
要求文の分割は，異なる開発者が行うと分割粒度が異なることも少なくない\cite{split_size}．LLMも同様に，共通した粒度で要求文を要件に分割することは容易でない．
本手法では，評価対象とは別のソフトウェア開発における要求文を手動で要件に分割した結果をfew-shot学習を行ったLLMモデルを用いて，要求文の分割を実施する．
Listing~\ref{sample_split}は，要求文を分割するプロンプトの一部を抜粋したものである．
few-shot学習に用いるソフトウェア開発データは，分割後の要件に基づきLLMで生成したコードが入出力テストを全て通過しているものとする．
また，分割時に「重要な機能であればあるほど前方に配置する」の命令を与え，ソースコードの主要処理から実装するように実装する順番もLLMが決定する．
実装する順に要件には，$r_1$，$r_2$，$r_3$，\dots,$r_n$のようにラベルを付与する．

\todo{分割のための具体的なプロンプトをここに書いておいた方が良い}
%----------------------------------
\begin{lstlisting}[caption=要求分割のためのプロンプト（一部抜粋）, label=sample_split, captionpos=t, columns=fullflexible, breaklines=true]
# Role
You are an expert in software requirements elicitation.

# Objective
From an AtCoder problem statement and its constraints, extract the requirements and split them into 10 or fewer subtasks.

# Requirements
- Identify the input format and state how it will be handled in the first requirement.
- Decide which function to pass the given arguments to, and name functions/variables wherever possible.
- Mention the output format in the last requirement.
- Think of this as converting a story-like text into a list of implementable events.
- Return only the subtask list (no extra commentary).
\end{lstlisting}
%----------------------------------

% few-shotによる要件細分化の安定性を図るため，本研究では著者が要件文を手動で小要件群に分割し，その分割に基づいてLLMにコードを生成する．そのコードが用意した入出力テストを全て通過した場合に，その手動で行った分割は「正しい分割」である，と定義しする．その後に，分割前の文章と分割後の文章をペアとして，few-shotの例としてLLMへ提示する．2.3節の方針に基づき，ここで与える分割例の数は8件と固定する．その後，few-shot学習を実施したLLMに対して未分割の要件を与え，分割を実施する．この際，分割数の最大数は，分割のコストを考慮し，最大数を10個に制限する．また，分割例と共「重要な機能であればあるほど前方に配置する」という命令を与え，コア機能から開発を実施し，段階的に機能を拡張する，と言た構造とする．

%3.3
\subsection{実装フェーズ}

実装フェーズは，各要件を満たすソースコードをLLMを用いて生成する．
Jiangらは，分割した要件のみに基づき，各要件を実現するソースコードを並行して生成する場合，要求間の断片化が発生し，全体整合性が崩壊するという課題が発生している\cite{tosem}
本研究は，要件$r_1$に加え，要求文をLLMに入力し，ソースコードを生成する．
Listing~\ref{programmer_sample}は，開発を担当するLLMへ与えるプロンプトの一部を抜粋したものである．
ここで生成されたソースコード一式をスナップショット1 ($S_1$) とする．次の要件要件$r_2$は，要求文と前の要件$r_1$で生成したスナップショット1$S_1$を入力とし，ソースコードを生成する．
ここで生成されたソースコード一式をスナップショット2 ($S_2$) とする．
このように，本研究では従来研究のような要件のみでソースコードを生成するのとは異なり，要求文と前の要件で生成したスナップショットも入力として用いる．

%----------------------------------
\begin{lstlisting}[caption=実装を行うLLMへ与えるプロンプト例, label=programmer_sample, captionpos=t, columns=fullflexible, breaklines=true]
"Programmer_2": [
    "You are Programmer_1 at ChatDev. Focus subtask: {subtask2}.",
    "The overall outline of the project is as follows: {overall_task}",  
    "Strictly follow the current phase's Output rules.",
    "Constraints: single file `main.py`; STDIN/STDOUT only; stdlib only; no extra logs.",
    "Respect any required region markers (e.g., '# [SUBTASK 2 START]' / '# [SUBTASK 2 END]'); do NOT add `__main__` unless asked.",
    "Output EXACTLY ONE file in the requested format: start with 'FILENAME: main.py' then a single code block."
]
\end{lstlisting}
%----------------------------------

%3.4
\subsection{再計画フェーズ}
再計画フェーズでは，スナップショットの追加行数に基づく要件の統合と，統合した結果を用いた再分割を実施する．

2.2節で示したように，要件に対する実装量が過度に小さい場合，LLMの注意資源や推論能力を必要以上に消費し，意図しない要件を実装する可能性が存在する\cite{tosem}．
本研究では，各要件に対して生成されたソースコード規模が小さい場合，ソースコード生成後に要件の分割粒度を再検討し，要件を統合して再生成する．
本研究では，各要件の重要度をその要件$r_i$ を実装するステップで新規に追加・修正された行数を用いて評価し，その重要度を用いて要件の統合の判断基準として使用する．
具体的には，$i$番目の要件$r_i$に基づき生成したソースコードのスナップショット$S_i$において，ソースコードの総行数を$LoC_i$とする．連続する2つのスナップショット対を$S_{i-1}$から$S_i$までで追加及び修正された行数を$\Delta LoC_i = S_i - S_{i-1}$ とする．


\memo{書きたい事\\
・$r_i$から生成されたコード行数から，$r_i$の重要度を定義\\
・重要度の閾値は，全体行数 LoC / N（1要件から作成される平均コード行数）
}

式(\ref{form:delta})で算出した差分行数$\Delta LoC_i$が，本研究で決定した閾値を下回ると，要件$r_i$は直前の要件$r_{i-1)}$と統合する．

\begin{equation}\label{form:delta}
    \Delta LoC_i \leq LoC_n / n
\end{equation}

その後に，統合した要件群を基に再度コードを生成し，統合の可否について調査を実施し，テストを通過したケースの統合後の要件を取得する．
取得した要件の中から無作為にサンプルを抽出し，計画フェーズと同様にfew-shotの例として提示し，要求から要件への再分割を実施し，それを基にコードの生成を実施する．

以上のような統合と再分割により，分割粒度や要件の並び順などの最適化を目指す．


%%%%%%%%%%%%%%%%%%%%%%%%%%%
%4
\section{評価実験}
\label{sec:evaluation}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

%4.1
\subsection{データセット}
本研究では，満たすべき要件が自然言語で明確に記述され，かつ入出力サンプルにより生成されたコードの正当性を評価可能である事から，競技プログラミングサイトであるAtCdoerをデータセットとして活用した．
その中でも，few-shotの分割サンプル用データとして入出力サンプルを25件持つ問題8問と，実験用データとして入出力サンプルを合計541件含む，200問の問題を取得した．
難易度の低い問題では要件の分割により，タスク粒度が過度に小さくなってしまう可能性を考慮して，C問題とD問題をそれぞれ100問ずつ選定した．
各問題は2〜4件程度の入出力サンプルを備えており，これを評価用テストとして活用し，生成したコードの品質評価に用いる．

満たすべき要件が自然言語で書かれた問題文や，生成されたコードを評価するための入出力セットが備わっていることから競技プログラミングサイトであるAtCoder\cite{AtCoder}より541件の入出力テストをもつ200問の問題を取得した．
尚，難易度の低い問題では分割の必要がないことから，難易度はC問題，D問題からそれぞれ100問ずつ取得した．

又，LLMの事前学習に用いられる学習用データの多くは英語が中心であり，多言語と比較して性能の差が挙げられる\cite{LLM_En} ．
そのため，要件の理解の一貫性や再現性を担保しやすいと考えられるため，問題などの自然言語は全て英語のものを取得した．

%4.2
\subsection{実験設定}
本研究の計画フェーズでは，著者が手動で要求分から要件分を作成し，それらをLLMにfew-shotとして学習させ，AtCoderの問題200問の分割の自動化を行った．
LLMに対して要求分と要件群の例以外に，根幹となる機能ほど順番を前にする事，分割コストの観点から分割の上限数を10個に制限する事の2点を追加で指示を行った．
Jiangらの研究上で，要件の分割を行う際にfew-shotで与えるべき分割例の最適な数は4~8個と述べられているため，本研究では8個(C問題，D問題で各4問)の例を提示した．

又，LLMは実行ごとに生成結果にばらつきが発生するため，AtCoderの問題200問に対して，要件の細分化とコードの生成を各問題あたり3回実施することで，再現性を確保した．
評価に関しては，問題ごとに提供される入出力サンプルを入出力テストとして扱い，全体のテスト通過率をベースに評価を実施する．
AtCoderの問題の特性上，入出力は標準入力・出力が想定されているため，3.1節で拡張した段階的に開発を行う各LLMに対して，アプリケーションのようなインタフェースは作成しないように命令を追加した．

本研究では要件の細分化やプログラマやコードレビュアーなどの段階的コード生成において，料金と性能を考慮し，LLMとして"GPT-4o-mini"\cite{openai_gpt_4o_mini}を使用した．


%4.3
\subsection{RQ}
本節では，本研究の効果を後続の3つの軸を定める．

%4.3.1
\subsubsection{RQ1: 全体概要の学習とfew-shotによる要件の細分化は生成されるコードのテスト通過率に影響を及ぼすか？}
LLMに対して全体概要を学習させる事で断片化抑制と整合性担保，few-shot学習による分割で正しく与えられた要件文から要求を抽出が可能かを，テスト通過率をベースに比較比較し，評価を実施する．
本RQにおいては，要件の分割を行わない従来のChatDevとの比較だけでなく，対照実験のようにfew-shotのみを行わなかった場合(zero-shotによる要件の細分化と各LLMに対する全体概要共有を実施)と，全体概要の提示のみを行わなかった場合(few-shoによる要件の細分化を実施し，全体概要の共有を実施しない)場合とで比較した．

%4.3.2
\subsubsection{RQ2: 細分化した要件の再統合は，生成されるコードの品質を劣化させないか？}
3.3節で述べた「スナップショット差分行数に基づく統合指標」により，粒度が過小な要件を正しく選定可能か，過小な要件を統合が生成されるコードのテスト通過率に影響を与えるかを調査した．
これは，統合する事によりテスト通過率の劣化が発生する場合，統合後の要件は統合前の要件より劣化したとみられるため，再分割の指標として「差分行数に基づく統合指標」は正しいものかを確認する事が本RQの目的である．
そのため，統合後同様に同様に200問の問題に対して3回の分割とコード生成を実施し，統合前のテスト通過率と比較し，評価を行う．


%4.3.3
\subsubsection{RQ3: 再統合した要件からの要件の再分割は生成されるコードのテスト通過率を向上させうるか？}
統合後に再分割を行うコストに見合うテスト通過率の向上が確認されるかを検証し，「テスト通過率が低下・変化がない場合には，再分割は不要である」という仮説に対して実証を行う．

具体的には，統合を実施した要件と，分割前の要件文をペアとして，3.2節で手動で作成した分割例と置換を行い，再度few-shotによる要件の分割を実施し，それに基づいてコードの生成を行う．
他RQ同様，テスト通過率で評価を実施する．

再分割して，テスト通過率変わらないならやる意味ないやんって話

%%%%%%%%%%%%%%%%%%%%%%%%%%%
%5
\section{結果}
\label{sec:result}
%%%%%%%%%%%%%%%%%%%%%%%%%%%

%5.1
\subsection{RQ1}
200問各3回に対するテスト通過率の結果を図\ref{ses2025}に示す．
要件の分割を行わない一括生成では，テスト通過率は16.48\%，few-shotや全体概要の学習を行わなかった場合にはそれぞれ40.92\%，18.92\%となり，両方を実施した場合には67.07\%となった．そのため，few-shotと全体概要の学習の2つを組み合わせる事により，テスト通過率を向上させうる事が確認された．

\todo{具体的な数字・分布を載せる}
zero-shotの場合は，テストで失敗したケースにおいても入出力でエラーが発生したケースは少なく，入出力の取り扱いは概ね正しく実装されているものの，出力不一致などによる失敗が中心であった．
これは全体概要の学習により，関数の呼び出しやデータの入出力構造などをはじめとする全体の整合性が保たれる一方で，局所的推論の部分でテスト失敗となっているケースが多く確認された．
一方で，全体概要の学習を行わず，few-shotのみの場合においては，タイムアウトや関数呼び出しなど，実行時の構造的不整合に起因するエラーが相対的に多くみられた．
これは，局所的な構造自体は与えられているが，全体像が欠如している事による開発の断片化により発生したものであると考えられる．

以上により，全体概要の学習は生成されるコードの整合性の分野において効力を発揮し，few-shotによる要件の細分化は，要求抽出，ひいては局所的最適化に貢献しうる事が示唆される．


\begin{figure}[t]
    \centering
    \includegraphics[width=1.0\linewidth]{./Toyoshima_fig/SIGSE_fig1.pdf}
    \caption{few-shotと全体概要の有無におけるテスト通過率比較}
    \label{ses2025}
\end{figure}

\subsection{RQ2}
統合前後でのテストは，合計で1,623件のテストが実施されたのに対して，要件の統合前の場合には67.84\%であるのに対して，統合後では68.76\%である事が確認された．
又，統合前にテストを通過した/通過しなかったケースをそれぞれPassed/Failed，統合後にテストを通過した/通過しなかったケースをそれぞれPass/Failと定義した時の，それぞれの分布を図\ref{rq2_1}で示す．
尚，本RQにおいてテストを通過する，とは問題単位で用意された入出力テストを全て通過したケースを指す．

PassedかつFailとなるケースは，要件の統合により「劣化」したケース，FailedかつPassとなるケースは，「改善」されたケースであり，それ以外の2項目は統合が生成されるコードの品質に影響を及ぼさなかったケースと考えられる．
それぞれの割合を確認すると，劣化・改善がみられたのは全体の12.5\%であり，概ね変化がみられないことが確認された．

以上のことから，テスト通過率は概ね横ばいであり，通過する問題の構成も大きく変化しないことから，提案する統合手法は，生成されるコードの品質を損なわせるものではない事が示唆される．

\begin{figure}[t]
    \centering
    \includegraphics[width=1.0\linewidth]{./Toyoshima_fig/SIGSE_PF.pdf}
    \caption{few-shotと全体概要の有無におけるテスト通過率比較\protect\footnotemark}
    \label{rq2_1}
\end{figure}

\subsection{RQ3}
統合した結果，品質の劣化が発生しないことが確認されたことから，統合前後の両方でテストを通過したケース(Passed かつ Pass)のケースより8件の分割例と問題文を抽出し，few-shot学習と再分割を実施した．
尚，分割例はC問題とD問題よりそれぞれ4問ずつ取得し，これらの問題は再分割・コード生成のデータセットからは除外し，それぞれ96問ずつで実験を実施した．
RQ2で定義した問題単位のテスト結果の分布を図\ref{rq3_1}に示す．

用意されたテストを全て通過した問題数がC問題で252問，D問題で231問となり，総テスト通過率は83.85\%となることが確認された．又，改善が見られたケース(Failed かつ Pass)が全体の36\%と通過したテストの半分近くを占める結果となった．

以上より，本論文が提案する，統合に基づく要件の再分割は，要件に含まれる要求を正しく抽出できる可能性が示される．

\begin{figure}[t]
    \centering
    \includegraphics[width=1.0\linewidth]{./Toyoshima_fig/RQ3_1.pdf}
    \caption{few-shotと全体概要の有無におけるテスト通過率比較\protect\footnotemark}
    \label{rq3_1}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%
%6
\section{考察}
\label{sec:discussion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%
%6.1
\subsection{テスト通過率の向上した理由について考察\todo{サブタイ変更}}
ケーススタディ的に考えていく．


%6.1.1
\subsubsection{ケース1: 統合前・統合後・再分割後の全てでテストを通過したケース}
\memo{実際の分割例ってどこに置くか考える．付録か...？}

本研究で扱った特定の問題において，統合前と再分割後の細分化された要件を目視で比較する．
統合前の場合1つあたりの要件は，変数や関数の宣言，値の代入，条件分岐の作成などと言った単発の作業の単位で区切られているのに対して，再分割後の要件は宣言・初期化・関数への引き渡しまでを同じまとまりとするような，意味のつながった一連の作業をひとかたまりとしてコードを生成可能単位に移行された事が確認された．\todo{絶対伝わるわけない気がするので要推敲}

%6.1.2
\subsubsection{ケース2: 再分割により改善が見られたケース}
要件の統合前と統合後では入出力テストを通過せず，再分割を実施することでテストを通過するようなったケースについて目視の比較を実施した．
統合によって，6.1.1節で述べたように要件1つあたりの粒度が問題の構造に合わせて変化した事に加えて，再分割の過程を通じて，それまで拾い切れていなかった意図を要件レベルで明示的に取り込めるようになったケースが確認された．
具体的には，細かな値の更新や条件分岐の制御に加え，停止条件の明確化，境界／同値の扱い，入出力形式と整合チェック，例外時の扱い，数値型・桁幅の固定，優先順位・適用範囲の明記といった要素が，要件の中に含まれることを確認した．

併せて，要件1つあたりの粒度が上昇したことで，少ないよう件数で同等の内容を包含できるようになり，その分だけ要件に含まれる細部の意図を詰めることが可能となった．
結果として，工程間の繋ぎ目が減少し，前提や出力の解釈の揺れの制御が行われ，先述した意図が一貫して反映されるようになったことが，入出力テストの通過に寄与したと考えられる．


%6.2
\subsection{妥当性の脅威}
\todo{たいせな}
又，本研究はLLMとして，GPT-4o-miniのみで評価が実施されており，学習データや推論モデルの異なる他モデルを使用した場合においても検証が必要である．

本研究の評価対象は，主に競技プログラミングサイトであるAtCoderの問題群であり，非機能要件や状態管理，長期保守など多種多様な事象を留意すべき業務アプリケーションやソフトウェアなどの開発とは前提が異なる．
実装言語や環境なども限定的であり，それらが結果に与える影響については十分な検証が行われていない．
同様に，評価の中心指標として入出力サンプルの通過率を使用しているため，境界値の取りこぼしなどの可能性が拭いきれず，十分に要件を満たしたコードの生成が実施されているか否かは確認出来ていない．
又，few-shotの提示する例の選定や，提示様式には研究者の裁量が入りやすく，それらの内容や難易度，スタイルの差が通過率に影響を及ぼす可能性を完全には否定できない．
加えて，データセットが公開されたものであるため，問題やその解法が既に学習済みである可能性と，それが結果に影響する余地も存在する．
\todo{あの閾値はなんとなくで決めたやつやから正しいかどうかもわからんって話を絶対に入れる．}

%%%%%%%%%%%%%%%%%%%%%%%%%%%
%7
\section{おわりに}
\label{sec:conclusion}
%%%%%%%%%%%%%%%%%%%%%%%%%%%
本研究では，LLMによるコード自動生成において，複数の要求を内包する複雑な要件に対して要件に対して生じがちな断片化と整合性の崩れの問題に着目し，few-shotによる要件の細分化と全体概要を与えた段階的実装，さらに生成結果に基づく要件の統合と再分割を実施する反復プロセスを提案した．

評価実験としては，RQ1で述べたようにfew-shotによる要件の細分化と，全体概要の共有を併用により，従来の一括生成や片方のみを導入した場合と比較して，した場合にテスト通過率が有意に向上した．
又，スナップショット差分行数に基づく要件の統合は品質の劣化を招かず，多くのケースで安定した挙動を示し，統合結果を新たな分割例として再分割を行う事によりテスト通過率の更なる向上が確認された．
これらの所見は，全体整合性の担保と局所最適化並びに，「自己最適化サイクル」が有効に働く事を示唆する．

ChatDevをベースとして開発を行う各ステップで分割された要件文と全体概要の学習により，それらを思考のガイドとしての役割を持たせながら開発の断片化を防ぐ事や，統合と再分割により，分割後の要件群の粒度最適化を図り，LLMフレンドリーな要件の粒度を模索する事が本研究の特徴と言える．

一方で，本研究の検証は競技プログラミングサイトの問題をベースに実施しており，様々な要素が複雑に絡み合う実務的開発へ流用可能であるかは追加検証が必要である．
又，LLMとして単一モデルを使用した事や，統合判定の閾値の根拠が乏しい事も課題として挙げられるため，今後はGitHubなどに公開されている小規模な実務的課題を持つリポジトリなどを対象として再現性の検証を実施すると共に，統合判定の閾値の最適化アプローチや，他モデルを用いることへの影響についても考察していく．

\textbf{謝辞} ありがとうございました

\bibliographystyle{ipsjunsrt}
\bibliography{bibsample}

\end{document}