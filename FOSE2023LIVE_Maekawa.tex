% 英文で執筆する場合はクラスファイルへのオプションを[T,E]としてください．
% If you want to write your paper in English, pass to [T,E] options to document class.
\documentclass[T,J]{fose} % 「コンピュータソフトウェア」用のクラスファイルは compsoft です．
\taikai{2023} % 固定です．出版委員長が毎年変更してAuthor Kitを配布してください．

\usepackage [dvipdfmx] {graphicx}

% ユーザが定義したマクロなどはここに置く．ただし学会誌のスタイルの
% 再定義は原則として避けること．

% 以下は説明のために使用したパッケージであるため，削除可能．
\usepackage{fancyvrb}
\usepackage{xurl}
\usepackage{cite}
\usepackage{color}
\usepackage{listings}
\usepackage{multirow}

\renewcommand{\lstlistingname}{Program}
\newcommand{\todo}[1]{\colorbox{yellow}{{\bf TODO}:}{\color{red} {\textbf{[#1]}}}}

\begin{document}

% 論文のタイトル
\title{JavaScriptテストコード変更内容に基づく\\後方互換性損失の検出の試み}
% 以下の \etitle（と\@etitle）はFOSE論文フォーマット独自のマクロです．
% FOSEに投稿した論文を発展させてコンピュータソフトウェアに投稿される場合はコメントアウトしてください．
% \setetitleは奇数ページのヘッダに表示する文字列（\etitle）を設定するためのマクロです．
% タイトルが2行に渡る場合は "\\" を 使用することで任意の位置で改行をすることができます．
\setetitle{Toward Detecting a Lack of Backward Compatibility Based on JavaScript Test Code Change Types}
%\setetitle{Long Long Long Long Long Long \\ Long Long Long Long Long \\ Long Long Long Long Long Long Long Long Long Long Long Long Paper Title}

% タイトル，著者などが複数行にわたり，論文冒頭の著者名が日本語アブストと重複して描画された場合に以下のコメントアウトを外してください．
%\longtitle

% 著者
% 和文論文の場合，姓と名の間には半角スペースを入れ，
% 複数の著者の間は全角スペースで区切る
%
\author{前川　大樹　伊原　彰紀　大森　楓己
%
% ここにタイトル英訳 (英文の場合は和訳) を書く．
% 英語タイトルは論文1ページ目左下，著者らの名前・所属一覧の一番上に表示される
%
% 上記\setetitle中で改行した場合は "\etitle" を削除し，改行(\\)を入れていないタイトルを記載してください．
% \ejtitleは1ページ目左下に挿入されるタイトルとして使用されます．
% また，"\etitle"はFOSE論文フォーマット独自のマクロです．
\ejtitle{\etitle}
%
% ここに著者英文表記 および
% 所属 (和文および英文) を書く．
% 複数著者の所属はまとめてよい．
%
%\shozoku{Daiki Maekawa}{和歌山大学}
%{Wakayama University}
% 複数著者の所属は以下のようにまとめてよい．
\shozoku{Daiki Maekawa, Akinori Ihara, Fuki Omori}{和歌山大学}
{Wakayama University}
}

%
% 和文アブストラクト
% In English paper, content of Jabstract will be ignored. 
\Jabstract{
ライブラリ更新には後方互換性の損失を伴うことがあるが，ライブラリの利用者が後方互換性を正確に判断することは困難である．従来研究では，ライブラリの動作を検証するテストの変更有無に基づき後方互換性の損失を検出する手法が提案されているが，誤検出が多い．本研究では，テストの変更内容を考慮する後方互換性の損失の検出手法を提案し，その精度を検証した．
}
%
% 英文アブストラクト（本サンプルの原論文にはなし）
% \Eabstract{
% \todo{英語アブストラクト}
% }
%
\maketitle \thispagestyle {empty}

% \begin{table*}[t]
% \label{table_test_pattern}
% \caption{テストコード変更内容と実際の後方互換性の有無}
% \begin{tabular}{|c|l|r|r|}
% \hline
% 従来研究の分類 & \multicolumn{1}{c|}{本研究の分類} & \multicolumn{1}{l|}{実際に後方互換性あり} & \multicolumn{1}{l|}{実際に後方互換性なし} \\ \hline
% \multirow{2}{*}{\begin{tabular}[c]{@{}c@{}}テスト追加\\ （後方互換性ありと判定）\end{tabular}} & テストスイートの追加 & 20（69\%） & 9（31\%） \\ \cline{2-4} 
%  & テストケースの追加 & 84（79\%） & 23（21\%） \\ \hline
% \multirow{2}{*}{\begin{tabular}[c]{@{}c@{}}テスト削除\\ （後方互換性なしと判定）\end{tabular}} & テストスイートの削除 & 4（40\%） & 6（60\%） \\ \cline{2-4} 
%  & テストケースの削除 & 8（42\%） & 11（58\%） \\ \hline
% \multirow{6}{*}{\begin{tabular}[c]{@{}c@{}}テスト変更\\ （後方互換性なしと判定）\end{tabular}} & アサーションの追加 & 35（83\%） & 7（17\%） \\ \cline{2-4} 
%  & アサーションの削除 & 8（100\%） & 0（0\%） \\ \cline{2-4} 
%  & 入力値の変更 & 7（100\%） & 0（0\%） \\ \cline{2-4} 
%  & 期待値の変更 & 23（72\%） & 9（28\%） \\ \cline{2-4} 
%  & 前提条件の変更 & 9（100\%） & 0（0\%） \\ \cline{2-4} 
%  & リファクタリング & 129（83\%） & 27（17\%） \\ \hline
% \end{tabular}
% \end{table*}

\section{はじめに}
サードパーティ製ライブラリ（以降，ライブラリ）は頻繁に更新されており，利用者は適宜ライブラリのバージョン更新が必要となる．利用者が安全にライブラリを更新するために，ライブラリ開発者はバージョン名によって後方互換性損失の有無を利用者に共有しているが，マイナー変更にもかかわらず後方互換性が損失していることも少なくない．
% 利用者が安全にライブラリを更新するために，パッケージマネージャはバージョン名によって後方互換性を管理しているが，誤ったバージョン名により後方互換性の損失が見落とされてしまうことも多い．
% この問題は，実行時までコードの不整合が検出されないJavaScriptのような動的な言語において顕著であるため，JavaScriptライブラリの
% 後方互換性を判定する研究が行われている．
JavaScriptのような動的な言語において，この問題は自身のソフトウェアを実行するまで検出されないことが多く，ユーザがライブラリのバージョン変更前にJavaScriptライブラリの後方互換性の損失を検出するための研究が行われている．

松田らは，後方互換性を損失するライブラリの更新は，プログラムの更新と合わせてテストコードも修正すると考え，テストの変更有無による後方互換性の判定手法を提案した\cite{matsuda}．しかし，テスト変更内容を考慮していないため，誤検出も多い．
% しかし，テストコードの変更内容を考慮しておらず，テストの誤り修正や実行手順の修正など，ライブラリ変更とは無関係のテストコード変更についても後方互換性を損失したと誤検出する．

本研究では，後方互換性の損失に関係するテスト変更内容を明らかにし，テスト変更内容に基づく後方互換性の損失を検出する手法を検証する．


\section{後方互換性の損失に関係するテスト変更の分析}\label{rq1}

\subsection{調査方法}
% データセットとして，松田らのデータセット\cite{matsuda}を使用する．松田らは，人気の238件のJavaScriptライブラリについて，合計2,111件のライブラリバージョンを分析し，各バージョンの実際の後方互換性と，ライブラリのテスト変更有無をまとめている．

本分析では，松田らのデータセットに含まれるライブラリバージョン2,111件から，ライブラリテストに変更がある1,027件を抽出し，95％の信頼区間でサンプリングした280件を目視で確認した．

% \vspace{-10pt}
\subsection{調査結果}

% ========================
\begin{table}[]
\caption{テスト変更内容による後方互換性の損失有無}
\scalebox{0.95}[0.95]{
\begin{tabular}{l|r|r}
\hline
\multirow{2}{*}{テスト変更内容} & \multicolumn{2}{c}{後方互換性損失}  \\ \cline{2-3}
 & \multicolumn{1}{c|}{有り} & \multicolumn{1}{c}{無し} \\ \hline
テスト追加 & 104（76\%） & 32（24\%） \\ \hline
テスト削除 & 12（41\%） & 17（59\%） \\ \hline
期待値の変更 & 23（72\%） & 9（28\%） \\ \hline
リファクタリング & 129（83\%） & 27（17\%） \\ \hline
\end{tabular}
\label{table_test_pattern}
}
\end{table}
% ========================

表\ref{table_test_pattern}は，テスト変更内容による後方互換性損失の有無を示す．本論文では，紙面の都合上，特徴的な変更内容のみを示す．

ライブラリのテストが削除された場合，従来研究の仮説と同様に後方互換性を損失していた割合が高い．
%く，後方互換性の損失に関係するテスト変更であると示唆される．
一方で，リファクタリングは件数も多くほとんどが実際には後方互換性を保っているため，従来研究の手法では誤検出となる．その他，テスト変更内容とライブラリの変更内容には次のような関係があることがわかった．

\begin{itemize}
    \item 機能拡張によって後方互換性を損失している場合，テスト追加していることが多い
    \item 機能削除によって後方互換性を損失している場合，テスト削除していることが多い
    \item APIの仕様変更によって後方互換性を損失している場合，アサーションの期待値を変更していることが多い
\end{itemize}

\section{テストコード変更内容に基づく後方互換性の損失の検出実験}
\subsection{パターンの作成}\label{create_pattern}
本研究では，\ref{rq1}章で述べた変更をそれぞれを検出するツールを開発し，後方互換性損失の検出精度を検証する．本ツールは，テスト内容を抽象構文木で定義し，コード差分解析ツールGumTree\cite{gumtree}を用いて変更情報を取得し，変更内容を次の方法で検出する．

% \subsubsection{テストコード内容の定義}
% JavaScriptの単体テストフレームワークとして使用される，JestやMochaの慣習に倣い，テストコード内容の定義を行う．

% \noindent\textbf{テストコードの定義：}関数呼び出しで，関数名がdescribeまたはitまたはtestであり，第一引数が文字列，第二引数が関数呼び出しのものを，テストコードとする.

% \noindent\textbf{アサーションの定義：}アサーションの記述形式はフレームワークにより異なるが，本分析では以下のように定義を行った．

% \subsubsection{テスト変更パターンの作成}\label{test_change_pattern}
\noindent\textbf{機能拡張によるテスト追加：}GumTreeでinsert-treeと判定されたノードツリーがテストコードであればテスト追加と判定する．その上で，追加されたテストが，変更前に定義されたテストスイート内であれば機能拡張によるテスト追加と判定する．

\noindent\textbf{テスト削除：}GumTreeでdelete-treeと判定されたノードツリーがテストコードであれば，テスト削除と判定する．

\noindent\textbf{アサーションの期待値の変更：}GumTreeでupdate-nodeと判定されたノードが，期待値であり，入力値のノードがupdate-nodeとして検出されていなければ，APIの仕様変更によるアサーションの期待値の変更と判定する．

本分析では，
%定義したパターンが１つでも検出されれば，後方互換性を損失したと判定する．また，
松田らのデータセットに含まれる2,111件のライブラリのうち，リポジトリが削除・または非公開されアクセスできないもの19件と，GumTree上でエラーになったもの141件を省いた1,951件を用いる．

% \begin{enumerate}
%     \item ファイルパスにtestまたはspecを含み，かつファイル名の末尾が.js または.ts であるものをテストファイルとして収集する．ただし，ファイル末尾が.d.tsのものは型定義ファイルとして収集しない
%     \item 変更されたテストファイルについて，変更前後のコードをGumTreeに入力する．この時，入力のサイズに対して外れ値検定を行い，165,957バイト以上のもの56件は対象外とした
%     \item 作成したパターンに一致する変更が１つでも検出された場合，そのバージョンは後方互換性を損失したと判定する
% \end{enumerate}

% 詳細
% \noindent\textbf{手順１：テストファイルの収集 - }ファイルパスにtestまたはspecを含み，かつファイル名の末尾が.js または.ts であるものをテストファイルとして収集する．ただし，ファイル末尾が.d.tsのものは型定義ファイルとして収集しない
% \noindent\textbf{手順2：GumTreeへの入力の作成 - }各バージョンで変更されたテストファイル群に対して，GumTreeへの入力を作成する．GumTreeでは，変更前後のソースコードを入力する必要がある．ただし，テストファイル単位で入力を作成すると，ファイル名の変更やディレクトリ構造の変更などのリファクタリングに対して誤検出の原因となる．そのため，変更されたファイルをすべてひとつにまとめバージョン単位で入力を作成する．この時，変数名の重複による構文エラーを防ぐために，ファイルごとにコードブロックで囲み，改行で繋げる．import宣言またはexport宣言が含まれる場合，これらはファイルのトップレベルで宣言する必要があるため，コードブロックの外に出し，モジュールのオブジェクト名の末尾にエスケープ処理をしたファイル名を付与することで重複を防ぐ．
% \noindent\textbf{手順3：後方互換性の判定 - }作成したパターンに一致する変更が１つでも検出された場合，そのバージョンは後方互換性を損失したと判定する．

% \vspace{-10pt}
\subsection{結果}

% ======================
\begin{table}[]
\centering
\caption{テストコード変更内容による後方互換性の検出結果}
\begin{tabular}{l|r|r}
\hline
\multicolumn{1}{c|}{} & \multicolumn{1}{c|}{変更パターン} & \multicolumn{1}{c}{変更パターン} \\ 
\multicolumn{1}{c|}{} & \multicolumn{1}{c|}{検出} & \multicolumn{1}{c}{未検出} \\ \hline
後方互換性無 & 80 & 150 \\ \hline
後方互換性有 & 403 & 1,318 \\ \hline
\end{tabular}
\label{table_pattern}
\end{table}

% ======================

表\ref{table_pattern}は，テストコード変更内容による後方互換性損失の検出結果を示す．変更パターンを検出し，実際に後方互換性を損失していた割合（適合率）は16\%，実際に後方互換性を損失し，変更パターンを検出した割合（再現率）は34\%であり，予測精度は低い結果となった．一方で，正解率は71\%であり，従来研究の問題点であったリファクタリングなどの変更も後方互換性なしと誤検出してしまう課題は改善された．

% \vspace{-10pt}
\subsection{考察}
本研究の提案により，従来手法で検出できなかった後方互換性の損失を検出することができた．しかし，テスト変更内容に基づく後方互換性の検出手法は適合率，再現率が低い結果となった．本手法ではコードの差分解析にGumTreeを利用しており，GumTreeは入力する変更規模が大きいほど変更パターンを誤って分類していることを確認した．本手法ではバージョン単位で変更前後のテストを取得したため，入力するコードが大きくなるため今後の研究で改善する．

%，改善の余地が存在する．しかし，後方互換性の損失に伴う変更パターンを一定数検出することができており，手法自体は悪くないことも示唆された．

% 本手法ではコードの差分解析にGumTreeを利用している．しかしGumTreeの精度は入力が大きいほど不十分であり，パターンを想定通りに検出できないものが多数存在した．本手法ではバージョン単位で変更前後のテストを取得したため，入力が大きくなりやすく精度を下げてしまったと考えられる．今後はGumTreeの代替案の検討や入力を小さくする手法も検討する．

\section{おわりに}
本研究では，ライブラリテスト変更内容に基づく後方互換性損失の検出手法を提案し，従来手法で検出できなかった後方互換性の損失を検出することができた．しかし，適合率，再現率は低い結果となった．今後は，テスト変更パターンを再評価し，後方互換性損失の検出精度向上を目指す．

%\begin{adjustvboxheight} % needed only when Appendix follows
\bibliographystyle{junsrt}
\bibliography{maekawa}
%\end{adjustvboxheight} % needed only when Appendix follows

% 以下はbibtexを使用しない場合の例です．
% 332行目と333行目をコメントアウトしてから使用してください．
% なお，この例では年数順に文献が並んでいるので適切な並び順ではありません．
%\begin{adjustvboxheight} % needed only when Appendix follows
%\begin{thebibliography}{9}
%\bibitem{fose2021} 名倉 正剛，関澤 俊弦 編：ソフトウェア工学の基礎28,日本ソフトウェア科学会{\em FOSE2021}, 近代科学社, 2021.
%\bibitem{fose2022} 角田 雅照，まつ本 真佑 編：ソフトウェア工学の基礎29,日本ソフトウェア科学会{\em FOSE2022}, 近代科学社, 2022.
%\bibitem{fose2023} 吉田 則裕，槇原 絵里奈 編：ソフトウェア工学の基礎30,日本ソフトウェア科学会{\em FOSE2023}, 近代科学社, 2023. （to appear）
%\end{thebibliography}
%\end{adjustvboxheight} % needed only when Appendix follows

%以下は付録の例です．必要ならコメントアウトして使用してください．
%なお，その際には参考文献の前後にある adjustvboxheight 環境のコメントアウトを解除してください．
%\appendix
%\section{付録A} 
%これは付録の例です．

\end{document}

