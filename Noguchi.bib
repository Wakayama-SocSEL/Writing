% Encoding: UTF-8

@inproceedings{findBug,
    title	= {Why Don't Software Developers Use Static Analysis Tools to Find Bugs?},
    author	= {Brittany Johnson and Yoonki Song and Emerson Murphy-Hill and Robert Bowdidge},
    year	= {2013},URL	= {http://dl.acm.org/citation.cfm?id=2486877},
    booktitle	= {International Conference on Software Engineering},
    pages	= {672-681}
}

@inproceedings{Junjie,
author = {Wang, Junjie and Wang, Song and Wang, Qing},
title = {Is There a "Golden" Feature Set for Static Warning Identification? An Experimental Evaluation},
year = {2018},
isbn = {9781450358231},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3239235.3239523},
doi = {10.1145/3239235.3239523},
abstract = {Background: The most important challenge regarding the use of static analysis tools (e.g., FindBugs) is that there are a large number of warnings that are not acted on by developers. Many features have been proposed to build classification models for the automatic identification of actionable warnings. Through analyzing these features and related studies, we observe several limitations that make the users lack practical guides to apply these features.Aims: This work aims at conducting a systematic experimental evaluation of all the public available features, and exploring whether there is a golden feature set for actionable warning identification.Method: We first conduct a systematic literature review to collect all public available features for warning identification. We employ 12 projects with totally 60 revisions as our subject projects. We then implement a tool to extract the values of all features for each project revision to prepare the experimental data.Results: Experimental evaluation on 116 collected features demonstrates that there is a common set of features (23 features) which take effect in warning identification for most project revisions. These features can achieve satisfied performance with far less time cost for warning identification.Conclusions: These commonly-selected features can be treated as the golden feature set for identifying actionable warnings. This finding can serve as a practical guideline for facilitating real-world warning identification.},
booktitle = {Proceedings of the 12th ACM/IEEE International Symposium on Empirical Software Engineering and Measurement},
articleno = {17},
numpages = {10},
keywords = {experimental evaluation, static analysis, actionable warning identification},
location = {Oulu, Finland},
series = {ESEM '18}
}

@inproceedings{kameoka,
  author = {亀岡　令 and 伊原　彰紀 and 大森　楓己},
  title = {複数プロジェクト開発履歴を用いた修正を要する規約違反ソースコード予測の試み},
  booktitle = {FOSE2023　第30回ソフトウェア工学の基礎ワークショップ},
  year = {2023}, 
  pages = {129-134},
}

@inproceedings{article2,
  Author = {Suhaib Mujahid, Rabe Abdalkareem, Emad Shihab, Shane McIntosh},
  Title = {{Using Others' Tests to Identify Breaking Updates}},
  Year = {2020},
  Booktitle = {Proc. of the International Conference on Mining Software Repositories (MSR)},
  Pages = {466–476}
}

@inproceedings{10.1145/3183399.3183401,
author = {Bodden, Eric},
title = {Self-adaptive static analysis},
year = {2018},
isbn = {9781450356626},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3183399.3183401},
doi = {10.1145/3183399.3183401},
abstract = {Static code analysis is a powerful approach to detect quality deficiencies such as performance bottlenecks, safety violations or security vulnerabilities already during a software system's implementation. Yet, as current software systems continue to grow, current static-analysis systems more frequently face the problem of insufficient scalability. We argue that this is mainly due to the fact that current static analyses are implemented fully manually, often in general-purpose programming languages such as Java or C, or in declarative languages such as Datalog. This design choice predefines the way in which the static analysis evaluates, and limits the optimizations and extensions static-analysis designers can apply.To boost scalability to a new level, we propose to fuse static-analysis with just-in-time-optimization technology, introducing for the first time static analyses that are managed and inherently self-adaptive. Those analyses automatically adapt themselves to yield a performance/precision tradeoff that is optimal with respect to the analyzed software system and to the analysis itself.Self-adaptivity is enabled by the novel idea of designing a dedicated intermediate representation, not for the analyzed program but for the analysis itself. This representation allows for an automatic optimization and adaptation of the analysis code, both ahead-of-time (through static analysis of the static analysis) as well as just-in-time during the analysis' execution, similar to just-in-time compilers.},
booktitle = {Proceedings of the 40th International Conference on Software Engineering: New Ideas and Emerging Results},
pages = {45–48},
numpages = {4},
location = {Gothenburg, Sweden},
series = {ICSE-NIER '18}
}


@Comment{jabref-meta: databaseType:bibtex;}
